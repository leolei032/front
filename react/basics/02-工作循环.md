# React 工作循环

React 运行时存在两大核心循环，它们协同工作完成整个渲染流程。

## 两大循环概览

```
┌────────────────────────────────────────┐
│       任务调度循环 (Scheduler)          │
│                                        │
│  ┌──────────────────────────────┐    │
│  │   任务队列（最小堆）           │    │
│  │   Task1 → Task2 → Task3      │    │
│  └──────────────────────────────┘    │
│            ↓ 循环消费                 │
│  ┌──────────────────────────────┐    │
│  │   执行优先级最高的任务         │    │
│  └──────────────────────────────┘    │
└────────────────┬───────────────────────┘
                 ↓ Task 执行
┌────────────────────────────────────────┐
│      Fiber 构造循环 (Reconciler)        │
│                                        │
│  ┌──────────────────────────────┐    │
│  │   深度优先遍历 Fiber 树        │    │
│  │   beginWork → completeWork   │    │
│  └──────────────────────────────┘    │
│            ↓                          │
│  ┌──────────────────────────────┐    │
│  │   构造完整的 Fiber 树          │    │
│  └──────────────────────────────┘    │
└────────────────────────────────────────┘
```

## 任务调度循环

### 位置
`packages/scheduler/src/Scheduler.js`

### 数据结构
**二叉堆（最小堆）**
- 堆顶永远是优先级最高的任务
- 保证任务按优先级顺序执行

### 核心逻辑
```javascript
// 简化的调度循环逻辑
function workLoop(currentTime) {
  // 1. 获取堆顶任务（优先级最高）
  let currentTask = peek(taskQueue);

  while (currentTask !== null) {
    // 2. 检查是否需要让出主线程
    if (currentTime < deadline && !needsPaint) {
      // 3. 执行任务回调
      const callback = currentTask.callback;
      currentTask.callback = null;
      callback();
    } else {
      // 时间切片：让出主线程
      break;
    }

    // 4. 获取下一个任务
    currentTask = peek(taskQueue);
  }
}
```

### 关键特性

#### 1. 异步执行
通过 `MessageChannel` 实现宏任务调度：
```javascript
const channel = new MessageChannel();
const port = channel.port2;

// 异步调度
port.postMessage(null);
```

#### 2. 时间切片
默认 5ms 切片周期，保证浏览器能及时响应：
```javascript
const yieldInterval = 5; // 5ms
const shouldYield = currentTime >= deadline;
```

#### 3. 优先级调度
不同优先级的任务在队列中按优先级排序。

## Fiber 构造循环

### 位置
`packages/react-reconciler/src/ReactFiberWorkLoop.js`

### 数据结构
**树形结构**
- 通过 `child`、`sibling`、`return` 指针连接
- 采用深度优先遍历

### 核心逻辑

```javascript
// 简化的 Fiber 构造循环
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork(unitOfWork) {
  // 1. 开始阶段：构造当前 fiber 节点
  const next = beginWork(unitOfWork);

  if (next === null) {
    // 2. 完成阶段：收集副作用
    completeUnitOfWork(unitOfWork);
  } else {
    // 3. 继续处理子节点
    workInProgress = next;
  }
}
```

### 遍历流程

```
        App (1.beginWork)
         ↓
    ┌────┴────┐
    │         │
  Header    Content (2.beginWork)
    ↓         ↓
    │      ┌──┴──┐
    │      │     │
    │     p1    p2 (3.beginWork)
    │      ↓     ↓
    │   (4.complete) (5.complete)
    │         ↓
    │    (6.complete Content)
    ↓
(7.complete Header)
    ↓
(8.complete App)
```

### 两个阶段

#### 1. beginWork - 向下构造
- 根据 ReactElement 创建或更新 Fiber 节点
- 标记副作用 flags
- 返回子节点继续处理

#### 2. completeWork - 向上归并
- 创建或更新 DOM 节点
- 收集子节点的副作用
- 形成副作用链表

## 两大循环的关系

### 区别

| 特性 | 任务调度循环 | Fiber 构造循环 |
|------|-------------|---------------|
| 数据结构 | 二叉堆 | 树 |
| 遍历方式 | 堆排序 | 深度优先遍历 |
| 职责 | 调度 task | 实现 task |
| 粒度 | 宏观 | 微观 |
| 可独立性 | 可脱离 React 使用 | React 专属 |

### 联系

```
大循环（调度）
  └─ 调度 Task
       └─ Task 内容
            ├─ 小循环（Fiber 构造） ← 主要部分
            ├─ DOM 渲染
            └─ 调度检测
```

**从属关系**：Fiber 构造循环是任务调度循环中 task 的一部分。

## 主干逻辑

React 的核心流程就是「输入 → 输出」：

```
1. 输入阶段
   setState / dispatchAction
        ↓
   创建 Update 对象
        ↓

2. 注册调度任务
   scheduleUpdateOnFiber
        ↓
   ensureRootIsScheduled
        ↓
   将 performSyncWorkOnRoot 或
   performConcurrentWorkOnRoot
   注册为 task
        ↓

3. 执行任务（两大循环配合）
   Scheduler 调度循环
        ↓ 执行 task
   Fiber 构造循环
        ↓ 构造 fiber 树

4. 输出阶段
   commitRoot
        ↓
   渲染到页面
```

## 可中断渲染实现

两大循环配合实现可中断渲染：

### Concurrent 模式
```javascript
function workLoopConcurrent() {
  // 每次循环都检查是否需要中断
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

### 中断与恢复
```javascript
if (shouldYield()) {
  // 1. 保存当前 workInProgress
  // 2. 返回新的任务函数
  // 3. 等待下次调度恢复
  return performConcurrentWorkOnRoot.bind(null, root);
}
```

## 总结

React 的两大循环是其核心机制：

1. **任务调度循环**
   - 在宏观层面控制任务执行
   - 实现优先级调度和时间切片
   - 保证浏览器流畅响应

2. **Fiber 构造循环**
   - 在微观层面实现具体任务
   - 构造完整的 Fiber 树
   - 收集副作用供后续提交

两者配合实现了 React 的高性能渲染和良好的用户体验。
