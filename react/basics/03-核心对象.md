# React 核心对象

React 运行时涉及多个核心对象，理解它们的结构和关系是深入 React 的基础。

## ReactElement 对象

### 概念
- JSX 编译后生成的对象
- 描述 UI 结构的数据结构
- 通过 `React.createElement()` 创建

### 数据结构
```typescript
type ReactElement = {
  // 标识符，用于辨别 ReactElement
  $$typeof: Symbol | number,

  // 核心属性
  type: string | function | Symbol,  // 节点类型
  key: string | null,                // 列表 key
  ref: Ref | null,                   // ref 引用
  props: Object,                     // 属性对象

  // 内部属性
  _owner: Fiber | null,              // 创建该元素的 Fiber 节点
}
```

### type 属性的含义
```javascript
// 字符串：原生 DOM 节点
<div /> → type: 'div'

// 函数：函数组件
function App() {} → type: App

// 类：类组件
class App extends React.Component {} → type: App

// Symbol：React 内置类型
<Fragment /> → type: Symbol(react.fragment)
<Context.Provider /> → type: Symbol(react.provider)
```

### JSX 编译示例
```javascript
// JSX 代码
<div className="app">
  <header>header</header>
  <Content />
</div>

// 编译后
React.createElement(
  'div',
  { className: 'app' },
  React.createElement('header', null, 'header'),
  React.createElement(Content, null)
)
```

### 内存结构
```
ReactElement (App)
  ├─ type: App
  ├─ props:
  │   └─ children: [
  │       ReactElement (div)
  │         ├─ type: 'div'
  │         └─ props:
  │             └─ children: [
  │                 ReactElement (header),
  │                 ReactElement (Content)
  │             ]
  │     ]
  └─ key: null
```

## Fiber 对象

### 概念
- React 内部的节点数据结构
- 一个组件可能对应两个 Fiber（current 和 workInProgress）
- 通过链表结构连接成 Fiber 树

### 核心属性
```typescript
type Fiber = {
  // 节点类型标识
  tag: WorkTag,                    // Fiber 类型（25 种）
  key: string | null,
  elementType: any,
  type: any,
  stateNode: any,                 // 关联的真实节点

  // Fiber 树结构
  return: Fiber | null,           // 父节点
  child: Fiber | null,            // 第一个子节点
  sibling: Fiber | null,          // 下一个兄弟节点
  index: number,

  // 状态相关
  pendingProps: any,              // 新的 props
  memoizedProps: any,             // 上次渲染的 props
  memoizedState: any,             // 上次渲染的 state
  updateQueue: UpdateQueue,       // 更新队列

  // 副作用相关
  flags: Flags,                   // 副作用标记
  nextEffect: Fiber | null,       // 下一个有副作用的节点
  firstEffect: Fiber | null,      // 第一个有副作用的子节点
  lastEffect: Fiber | null,       // 最后一个有副作用的子节点

  // 优先级
  lanes: Lanes,                   // 本节点优先级
  childLanes: Lanes,              // 子节点优先级

  // 双缓冲
  alternate: Fiber | null,        // 对应的另一棵树的 Fiber
}
```

### Fiber 树结构

```
        HostRootFiber
              ↓ (child)
            App Fiber ←────────┐
              ↓                │
        ┌─────┴─────┐         │ (return)
        ↓           ↓          │
    div Fiber   Content Fiber ─┘
        ↓           ↓
        │      ┌────┴────┐
        ↓      ↓         ↓
   header    p Fiber   p Fiber
              ↓         ↑
              └─(sibling)
```

### 与 ReactElement 的关系

```
ReactElement (描述 UI)
    ↓ reconciler 阶段
Fiber (工作单元)
    ↓ commit 阶段
DOM (实际渲染)
```

## Update & UpdateQueue

### 概念
- Update：状态更新对象
- UpdateQueue：挂载在 Fiber 上的更新队列
- 环形链表结构

### Update 对象
```typescript
type Update = {
  eventTime: number,              // 更新时间
  lane: Lane,                     // 优先级

  tag: UpdateTag,                 // 更新类型
  payload: any,                   // 更新内容（对象或函数）
  callback: Function | null,      // 回调函数

  next: Update | null,            // 下一个 Update
}
```

### UpdateQueue 对象
```typescript
type UpdateQueue = {
  baseState: State,               // 基础状态
  firstBaseUpdate: Update | null, // 基础队列头
  lastBaseUpdate: Update | null,  // 基础队列尾

  shared: {
    pending: Update | null,       // 待处理的更新
  },

  effects: Array<Update> | null,  // 有 callback 的 Update
}
```

### 工作流程
```
1. setState 调用
    ↓
2. 创建 Update 对象
    ↓
3. 加入 fiber.updateQueue.shared.pending
    ↓
4. 调度更新
    ↓
5. 处理 updateQueue，计算新状态
    ↓
6. 执行 callback
```

### 示例
```javascript
// 调用 setState
this.setState({ count: 1 });
this.setState({ count: 2 });

// 生成 Update 链表
Update1 { payload: { count: 1 }, next: Update2 }
Update2 { payload: { count: 2 }, next: null }

// 合并到 updateQueue
fiber.updateQueue.shared.pending = Update2（环形链表）
```

## Hook 对象

### 概念
- 用于函数组件的状态管理
- 通过链表连接多个 Hook
- 挂载在 `fiber.memoizedState` 上

### Hook 数据结构
```typescript
type Hook = {
  memoizedState: any,             // Hook 的状态
  baseState: any,                 // 基础状态
  baseQueue: Update | null,       // 基础更新队列
  queue: UpdateQueue | null,      // 更新队列
  next: Hook | null,              // 下一个 Hook
}
```

### Hook 的 UpdateQueue
```typescript
type UpdateQueue = {
  pending: Update | null,         // 待处理更新
  dispatch: Function | null,      // dispatch 函数
  lastRenderedReducer: Function,  // reducer 函数
  lastRenderedState: any,         // 上次渲染的状态
}
```

### Hook 链表结构
```
Fiber.memoizedState
    ↓
Hook1 (useState)
  ├─ memoizedState: 0
  ├─ queue: UpdateQueue
  └─ next ↓
        Hook2 (useEffect)
          ├─ memoizedState: effect
          ├─ queue: null
          └─ next ↓
                Hook3 (useState)
                  ├─ memoizedState: 'hello'
                  └─ next: null
```

### 为什么 Hook 必须按顺序调用

```javascript
// ❌ 错误：条件调用会打乱链表顺序
function App() {
  const [a, setA] = useState(1);
  if (condition) {
    const [b, setB] = useState(2);  // 链表顺序不稳定
  }
  const [c, setC] = useState(3);
}

// ✅ 正确：保持链表顺序稳定
function App() {
  const [a, setA] = useState(1);    // Hook1
  const [b, setB] = useState(2);    // Hook2
  const [c, setC] = useState(3);    // Hook3
}
```

## Task 对象

### 概念
- Scheduler 中的任务对象
- 存储在最小堆中
- 控制回调函数的执行

### 数据结构
```javascript
const task = {
  id: taskIdCounter++,            // 唯一标识
  callback: Function,             // 任务回调（reconciler 提供）
  priorityLevel: Priority,        // 优先级
  startTime: number,              // 开始时间
  expirationTime: number,         // 过期时间
  sortIndex: number,              // 排序索引（越小越优先）
}
```

### 任务队列
```
taskQueue（最小堆数组）
  [0] Task3 (sortIndex: 1, 最高优先级)
  [1] Task1 (sortIndex: 5)
  [2] Task2 (sortIndex: 10)
```

## 对象关系图

```
                    ReactElement 树
                          ↓ render
    ┌────────────────────────────────────┐
    │         Fiber 树结构                │
    │                                     │
    │  Fiber ← alternate → Fiber         │
    │    ↓                                │
    │  updateQueue (Update 链表)          │
    │    ↓                                │
    │  memoizedState (Hook 链表)          │
    └────────────────────────────────────┘
                          ↓
                    Task (Scheduler)
                          ↓
                      DOM 树
```

## 总结

| 对象 | 所属包 | 作用 | 数据结构 |
|------|--------|------|---------|
| ReactElement | react | 描述 UI | 树（父子） |
| Fiber | react-reconciler | 工作单元 | 树（链表） |
| Update | react-reconciler | 状态更新 | 链表 |
| Hook | react-reconciler | 函数组件状态 | 链表 |
| Task | scheduler | 调度任务 | 最小堆 |

这些对象贯穿 React 的整个运行时，理解它们是深入 React 源码的基础。
