# React 应用启动流程

## 三种启动模式

React v17.0.2 支持三种启动模式：

### 1. Legacy 模式（遗留模式）
```javascript
// 当前最常用的模式
ReactDOM.render(<App />, document.getElementById('root'));
```
- 不支持 Concurrent 特性
- 同步渲染，不可中断

### 2. Blocking 模式（过渡模式）
```javascript
// 实验性 API
const root = ReactDOM.createBlockingRoot(
  document.getElementById('root')
);
root.render(<App />);
```
- 支持部分 Concurrent 特性
- 作为向 Concurrent 模式迁移的过渡

### 3. Concurrent 模式（并发模式）
```javascript
// 实验性 API，未来的默认模式
const root = ReactDOM.createRoot(
  document.getElementById('root')
);
root.render(<App />);
```
- 支持所有新特性
- 可中断渲染
- 时间切片
- Suspense

## 启动前的状态

```
┌─────────────────┐       ┌──────────────┐
│  ReactElement   │       │  DOM 节点    │
│    <App />      │       │  div#root    │
└─────────────────┘       └──────────────┘
     (内存中)                  (页面上)
        ↓                        ↓
    未关联，需要通过启动流程建立连接
```

## 三大全局对象

启动过程会创建三个核心对象：

### 1. ReactDOMRoot / ReactDOMBlockingRoot
```javascript
// 位置：react-dom 包
class ReactDOMRoot {
  _internalRoot: FiberRoot;

  render(children) {
    // 更新容器
    updateContainer(children, this._internalRoot);
  }

  unmount() {
    // 卸载应用
  }
}
```

**作用**：
- 提供 render、unmount 等 API
- 持有 FiberRoot 引用
- 暴露给开发者使用

### 2. FiberRoot
```javascript
// 位置：react-reconciler 包
type FiberRoot = {
  // 容器信息
  containerInfo: any,             // DOM 容器（div#root）
  current: Fiber,                 // 指向 HostRootFiber

  // 任务调度
  callbackNode: Task | null,      // 当前调度的任务
  callbackPriority: Lane,         // 任务优先级

  // 优先级管理
  pendingLanes: Lanes,            // 待处理的优先级
  finishedLanes: Lanes,           // 已完成的优先级

  // 完成的工作
  finishedWork: Fiber | null,     // 已完成的 Fiber 树
}
```

**作用**：
- React 运行时的全局上下文
- 存储 Fiber 构造循环的状态
- 控制整个应用的执行逻辑

### 3. HostRootFiber
```javascript
// 位置：react-reconciler 包
const HostRootFiber = {
  tag: HostRoot,                  // 根节点类型
  stateNode: FiberRoot,           // 指向 FiberRoot
  return: null,                   // 没有父节点
  child: null,                    // 子节点（App Fiber）
  updateQueue: UpdateQueue,       // 更新队列
}
```

**作用**：
- Fiber 树的根节点
- 应用的第一个 Fiber 对象
- 连接 FiberRoot 和 Fiber 树

## 启动流程详解

### Legacy 模式启动

```javascript
// 1. 调用入口
ReactDOM.render(<App />, document.getElementById('root'), callback);

// 2. 创建 ReactDOMRoot
const root = legacyCreateRootFromDOMContainer(container);

// 3. 创建 FiberRoot 和 HostRootFiber
const fiberRoot = createFiberRoot(container, LegacyRoot);

// 4. 启动更新
updateContainer(<App />, fiberRoot, null, callback);
```

### 创建过程

```
ReactDOM.render
    ↓
legacyRenderSubtreeIntoContainer
    ↓
legacyCreateRootFromDOMContainer
    ↓
createLegacyRoot
    ↓
new ReactDOMBlockingRoot(container, LegacyRoot)
    ↓
createRootImpl
    ↓
createContainer (react-reconciler)
    ↓
createFiberRoot
    ├─ 创建 FiberRoot
    └─ 创建 HostRootFiber
    └─ 相互引用
        fiberRoot.current = HostRootFiber
        HostRootFiber.stateNode = fiberRoot
```

### 对象关系图

```
┌──────────────────────────────────────┐
│     ReactDOMRoot (react-dom)         │
│  ┌────────────────────────────────┐ │
│  │  _internalRoot: FiberRoot      │ │
│  │  render(children) {...}        │ │
│  └────────────────────────────────┘ │
└───────────────┬──────────────────────┘
                ↓ _internalRoot
┌──────────────────────────────────────┐
│     FiberRoot (react-reconciler)     │
│  ┌────────────────────────────────┐ │
│  │  containerInfo: div#root       │ │
│  │  current: HostRootFiber ────┐  │ │
│  │  callbackNode: null          │  │ │
│  │  pendingLanes: 0            │  │ │
│  └────────────────────────────────┘ │
└───────────────────────────┬──────────┘
                            │
            ┌───────────────┘
            ↓ current
┌──────────────────────────────────────┐
│   HostRootFiber (react-reconciler)   │
│  ┌────────────────────────────────┐ │
│  │  tag: HostRoot                 │ │
│  │  stateNode: FiberRoot ←────────┼─┘
│  │  child: null (初始)            │
│  │  updateQueue: {...}            │
│  └────────────────────────────────┘ │
└──────────────────────────────────────┘
```

## updateContainer 详解

创建完三大对象后，进入更新流程：

```javascript
function updateContainer(
  element,      // <App />
  container,    // FiberRoot
  parentComponent,
  callback
) {
  // 1. 获取当前时间和优先级
  const current = container.current;  // HostRootFiber
  const eventTime = requestEventTime();
  const lane = requestUpdateLane(current);

  // 2. 创建 Update 对象
  const update = createUpdate(eventTime, lane);
  update.payload = { element };  // 将 <App /> 挂载到 payload
  update.callback = callback;

  // 3. 将 Update 加入更新队列
  enqueueUpdate(current, update);

  // 4. 进入调度流程
  scheduleUpdateOnFiber(current, lane, eventTime);

  return lane;
}
```

### 此时的内存结构

```
HostRootFiber
    ↓
updateQueue
    ↓
shared.pending ──→ Update
                      ↓
                   payload: {
                     element: <App />
                   }
```

## 进入 Reconciler 流程

updateContainer 调用 scheduleUpdateOnFiber 后：

```
scheduleUpdateOnFiber (输入)
    ↓
ensureRootIsScheduled (注册调度)
    ↓
scheduleCallback (Scheduler)
    ↓
performSyncWorkOnRoot / performConcurrentWorkOnRoot
    ↓
renderRootSync / renderRootConcurrent (Fiber 构造)
    ↓
commitRoot (输出)
    ↓
DOM 更新完成
```

## 三种模式的差异

| 特性 | Legacy | Blocking | Concurrent |
|------|--------|----------|------------|
| RootTag | LegacyRoot | BlockingRoot | ConcurrentRoot |
| 渲染方式 | 同步 | 部分可中断 | 完全可中断 |
| 时间切片 | ✗ | ✓ | ✓ |
| 优先级调度 | 简单 | 中等 | 完整 |
| Suspense | 基础支持 | 支持 | 完整支持 |
| useTransition | ✗ | ✗ | ✓ |

### RootTag 的作用

```javascript
// 影响渲染行为
function scheduleUpdateOnFiber(fiber, lane) {
  const root = markUpdateLaneFromFiberToRoot(fiber, lane);

  if (lane === SyncLane) {
    // Legacy 模式：同步执行
    if (root.tag === LegacyRoot) {
      performSyncWorkOnRoot(root);
    }
  } else {
    // Concurrent 模式：异步调度
    ensureRootIsScheduled(root);
  }
}
```

## 启动完成后的状态

```
┌────────────────────────────────────────┐
│          ReactDOMRoot                  │
└───────────────┬────────────────────────┘
                ↓
┌────────────────────────────────────────┐
│           FiberRoot                    │
│  containerInfo: div#root               │
│  current: HostRootFiber                │
└───────────────┬────────────────────────┘
                ↓
┌────────────────────────────────────────┐
│        HostRootFiber                   │
│  child: App Fiber ──→ 继续构造         │
│  updateQueue: Update { element: <App />}│
└────────────────────────────────────────┘
```

## 总结

React 应用启动过程：

1. **创建三大对象**
   - ReactDOMRoot：用户交互接口
   - FiberRoot：全局上下文
   - HostRootFiber：Fiber 树根节点

2. **建立连接关系**
   - ReactDOMRoot._internalRoot → FiberRoot
   - FiberRoot.current → HostRootFiber
   - HostRootFiber.stateNode → FiberRoot

3. **触发首次渲染**
   - 创建 Update 对象
   - 挂载 ReactElement
   - 进入 Reconciler 流程

4. **模式决定行为**
   - Legacy：同步渲染
   - Blocking：部分异步
   - Concurrent：完全异步

启动完成后，应用进入正常的更新循环。
