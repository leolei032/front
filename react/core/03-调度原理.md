# Scheduler 调度原理

Scheduler 是 React 的调度中心，控制着所有任务的执行时机，是实现可中断渲染和时间切片的核心。

## 核心概念

### 调度的目的
1. **时间切片**：将长任务分割，避免阻塞浏览器
2. **优先级调度**：紧急任务优先执行
3. **异步可中断**：支持 Concurrent 模式

### 工作原理
```
任务队列（最小堆）
    ↓
按优先级取出任务
    ↓
执行任务（可中断）
    ↓
检查是否需要让出主线程
    ├─ 是 → 暂停，等待下次调度
    └─ 否 → 继续执行
```

## 核心 API

Scheduler 提供 8 个核心函数：

### 1. 调度相关

#### requestHostCallback
```javascript
// 请求执行回调
let scheduledHostCallback = null;

const channel = new MessageChannel();
const port = channel.port2;

channel.port1.onmessage = performWorkUntilDeadline;

requestHostCallback = function(callback) {
  // 保存回调
  scheduledHostCallback = callback;

  if (!isMessageLoopRunning) {
    isMessageLoopRunning = true;
    // 通过 MessageChannel 触发宏任务
    port.postMessage(null);
  }
};
```

**关键点**：
- 使用 MessageChannel 实现异步调度
- 属于宏任务，不会阻塞微任务
- 保证异步执行

#### cancelHostCallback
```javascript
// 取消回调
cancelHostCallback = function() {
  scheduledHostCallback = null;
};
```

### 2. 时间切片相关

#### getCurrentTime
```javascript
// 获取当前时间（高精度）
const getCurrentTime = () => performance.now();
```

#### shouldYieldToHost
```javascript
// 是否需要让出主线程
const yieldInterval = 5;  // 默认 5ms
let deadline = 0;

shouldYieldToHost = function() {
  const currentTime = getCurrentTime();

  // 超过时间切片 且 需要绘制
  return currentTime >= deadline && needsPaint;
};
```

**时间切片机制**：
```
执行开始
    ↓
设置 deadline = currentTime + 5ms
    ↓
执行任务
    ↓
每个工作单元后检查
    ├─ currentTime < deadline → 继续执行
    └─ currentTime >= deadline → 让出主线程
```

#### requestPaint
```javascript
// 请求绘制（标记需要绘制）
requestPaint = function() {
  needsPaint = true;
};
```

## 任务调度流程

### 1. scheduleCallback - 调度入口

```javascript
function unstable_scheduleCallback(priorityLevel, callback, options) {
  // 1. 获取当前时间
  const currentTime = getCurrentTime();

  // 2. 计算开始时间
  let startTime;
  if (typeof options === 'object' && options !== null) {
    const delay = options.delay;
    startTime = currentTime + (typeof delay === 'number' ? delay : 0);
  } else {
    startTime = currentTime;
  }

  // 3. 根据优先级计算过期时间
  let timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT;  // -1
      break;
    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;  // 250ms
      break;
    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT;  // 1073741823ms
      break;
    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT;  // 10000ms
      break;
    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT;  // 5000ms
      break;
  }

  const expirationTime = startTime + timeout;

  // 4. 创建任务对象
  const newTask = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    sortIndex: -1,
  };

  // 5. 加入队列
  if (startTime > currentTime) {
    // 延时任务：加入 timerQueue
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);

    // 如果是最早的延时任务，设置定时器
    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
      if (isHostTimeoutScheduled) {
        cancelHostTimeout();
      }
      isHostTimeoutScheduled = true;
      requestHostTimeout(handleTimeout, startTime - currentTime);
    }
  } else {
    // 普通任务：加入 taskQueue
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);

    // 开始调度
    if (!isHostCallbackScheduled && !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
  }

  return newTask;
}
```

### 2. 任务队列管理

```
timerQueue（延时任务）    taskQueue（就绪任务）
  按 startTime 排序         按 expirationTime 排序
        ↓                          ↑
    时间到了                       │
        └──────────────────────────┘
              advanceTimers()
```

#### 队列转换
```javascript
function advanceTimers(currentTime) {
  // 检查 timerQueue 中的任务
  let timer = peek(timerQueue);

  while (timer !== null) {
    if (timer.callback === null) {
      // 任务被取消，移除
      pop(timerQueue);
    } else if (timer.startTime <= currentTime) {
      // 时间到了，移动到 taskQueue
      pop(timerQueue);
      timer.sortIndex = timer.expirationTime;
      push(taskQueue, timer);
    } else {
      // 还没到时间
      return;
    }
    timer = peek(timerQueue);
  }
}
```

### 3. workLoop - 执行任务

```javascript
function workLoop(hasTimeRemaining, initialTime) {
  let currentTime = initialTime;

  // 1. 转移到期的延时任务
  advanceTimers(currentTime);

  // 2. 获取优先级最高的任务
  currentTask = peek(taskQueue);

  while (currentTask !== null) {
    // 3. 检查是否需要中断
    if (
      currentTask.expirationTime > currentTime &&
      (!hasTimeRemaining || shouldYieldToHost())
    ) {
      // 时间切片：让出主线程
      break;
    }

    // 4. 执行任务
    const callback = currentTask.callback;
    if (typeof callback === 'function') {
      currentTask.callback = null;
      currentPriorityLevel = currentTask.priorityLevel;

      const didUserCallbackTimeout =
        currentTask.expirationTime <= currentTime;

      const continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();

      // 5. 处理返回值
      if (typeof continuationCallback === 'function') {
        // 任务返回了 continuation，保留任务继续执行
        currentTask.callback = continuationCallback;
      } else {
        // 任务完成，移除
        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
      }

      advanceTimers(currentTime);
    } else {
      // 任务被取消
      pop(taskQueue);
    }

    // 6. 获取下一个任务
    currentTask = peek(taskQueue);
  }

  // 7. 返回是否还有任务
  if (currentTask !== null) {
    return true;  // 还有任务
  } else {
    // 检查是否有延时任务
    const firstTimer = peek(timerQueue);
    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
    return false;  // 没有任务了
  }
}
```

### 4. performWorkUntilDeadline - 调度循环

```javascript
const performWorkUntilDeadline = () => {
  if (scheduledHostCallback !== null) {
    const currentTime = getCurrentTime();

    // 更新 deadline
    deadline = currentTime + yieldInterval;

    const hasTimeRemaining = true;

    try {
      // 执行工作循环
      const hasMoreWork = scheduledHostCallback(
        hasTimeRemaining,
        currentTime,
      );

      if (!hasMoreWork) {
        // 所有任务完成
        isMessageLoopRunning = false;
        scheduledHostCallback = null;
      } else {
        // 还有任务，继续调度
        port.postMessage(null);
      }
    } catch (error) {
      // 发生错误，重新调度
      port.postMessage(null);
      throw error;
    }
  } else {
    isMessageLoopRunning = false;
  }

  needsPaint = false;
};
```

## 优先级体系

### 5 种调度优先级

```javascript
const ImmediatePriority = 1;      // 立即执行（-1ms）
const UserBlockingPriority = 2;   // 用户阻塞（250ms）
const NormalPriority = 3;          // 普通（5000ms）
const LowPriority = 4;             // 低优先级（10000ms）
const IdlePriority = 5;            // 空闲（永不过期）
```

### 优先级与过期时间

```javascript
过期时间 = 开始时间 + timeout

timeout 值越小 → 过期时间越早 → 优先级越高
```

### 最小堆排序

```
taskQueue（最小堆）
  [0] Task1 (expirationTime: 100)  ← 优先级最高
  [1] Task2 (expirationTime: 200)
  [2] Task3 (expirationTime: 300)

peek(taskQueue) → Task1（堆顶）
```

## 可中断渲染实现

### Concurrent 模式的支持

```javascript
// React Reconciler 中
function performConcurrentWorkOnRoot(root) {
  // 返回 continuation 实现中断
  return function continueConcurrentWork() {
    // 继续未完成的工作
  };
}

// Scheduler 中
const continuationCallback = callback(didUserCallbackTimeout);

if (typeof continuationCallback === 'function') {
  // 保留任务，下次继续执行
  currentTask.callback = continuationCallback;
}
```

### 中断与恢复

```
第一次调度
    ↓
执行部分工作
    ↓
shouldYieldToHost() === true
    ↓
返回 continuation
    ↓
保存任务到队列
    ↓
（等待下次调度）
    ↓
第二次调度
    ↓
继续执行 continuation
    ↓
完成
```

## 调度流程图

```
scheduleCallback
    ↓
创建 Task
    ↓
加入队列
    ├─ timerQueue（延时）
    └─ taskQueue（就绪）
    ↓
requestHostCallback(flushWork)
    ↓
port.postMessage(null)
    ↓
（宏任务执行）
    ↓
performWorkUntilDeadline
    ↓
workLoop
    ├─ advanceTimers（转移延时任务）
    ├─ peek(taskQueue)（获取任务）
    ├─ shouldYield？（检查中断）
    ├─ callback()（执行任务）
    └─ 有更多任务？
        ├─ 是 → port.postMessage(null)
        └─ 否 → 完成
```

## 与浏览器的配合

### MessageChannel 的选择

**为什么不用 setTimeout？**
- setTimeout 有 4ms 延迟
- 嵌套调用会增加延迟
- 性能不如 MessageChannel

**为什么不用 requestIdleCallback？**
- 兼容性问题
- 执行频率不可控（最低 20fps）
- FPS 下降时调用频率降低

**MessageChannel 的优势**：
- 宏任务，优先级合适
- 没有额外延迟
- 浏览器兼容性好

### 时间切片的意义

```
没有时间切片：
┌──────────────────────────────┐
│  React 长任务（100ms）        │ ← 阻塞
└──────────────────────────────┘
  用户点击无响应 ✗

有时间切片：
┌───┐  ┌───┐  ┌───┐  ┌───┐
│ 5 │  │ 5 │  │ 5 │  │ 5 │ ← 分片
└───┘  └───┘  └───┘  └───┘
  ↑      ↑      ↑      ↑
  可以处理用户输入/绘制 ✓
```

## 总结

Scheduler 的核心机制：

1. **任务队列管理**
   - 最小堆实现优先级队列
   - 延时任务和就绪任务分离

2. **时间切片**
   - 默认 5ms 切片
   - shouldYieldToHost 控制让出

3. **异步调度**
   - MessageChannel 实现
   - 宏任务异步执行

4. **可中断支持**
   - continuation 机制
   - 保存和恢复任务状态

5. **优先级调度**
   - 5 种优先级
   - 过期时间控制执行顺序

Scheduler 是 React 高性能的关键，使得 React 能够在不阻塞浏览器的情况下完成复杂的更新。
