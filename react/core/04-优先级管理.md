# React 优先级管理

React 内部有三套优先级体系，它们协同工作实现了高效的任务调度和渲染。

## 三套优先级体系

```
┌──────────────────────────────────┐
│    ReactPriorityLevel (转换层)    │
│  连接 Lane 和 Scheduler 优先级    │
└────────┬──────────────┬──────────┘
         ↓              ↓
┌──────────────┐  ┌──────────────┐
│ LanePriority │  │SchedulerPrio │
│(Reconciler)  │  │ (Scheduler)  │
│ Fiber 优先级  │  │  调度优先级   │
└──────────────┘  └──────────────┘
```

## Lane 优先级（车道模型）

### 为什么叫 Lane？

Lane（车道）是 React 17 引入的新优先级模型，替代了之前的 expirationTime。

**车道模型的优势**：
1. 使用位运算，性能更好
2. 可以表达多个任务的组合
3. 更容易判断优先级关系

### Lane 的定义

```typescript
// 31 条车道，使用 31 位二进制表示
export type Lanes = number;
export type Lane = number;

// 核心 Lane 定义
const NoLanes: Lanes = 0b0000000000000000000000000000000;
const NoLane: Lane = 0b0000000000000000000000000000000;

const SyncLane: Lane = 0b0000000000000000000000000000001;

const InputContinuousHydrationLane: Lane = 0b0000000000000000000000000000010;
const InputContinuousLane: Lanes = 0b0000000000000000000000000000100;

const DefaultHydrationLane: Lane = 0b0000000000000000000000000001000;
const DefaultLane: Lanes = 0b0000000000000000000000000010000;

// ... 更多 Lane 定义
```

### Lane 的优先级层次

```javascript
// 从高到低
SyncLane                    // 1   - 最高优先级（同步）
InputContinuousLane         // 2   - 连续输入（拖拽、滚动）
DefaultLane                 // 3   - 默认优先级
TransitionLanes             // 4-15 - 过渡优先级
IdleLane                    // 31  - 空闲优先级
```

### 位运算的优势

#### 1. 判断单个任务是否在批量任务中

```javascript
// expirationTime 方式
const isTaskIncludedInBatch =
  taskPriority <= highestPriorityInRange &&
  taskPriority >= lowestPriorityInRange;

// Lane 方式（一次位运算）
const isTaskIncludedInBatch = (task & batchOfTasks) !== 0;
```

#### 2. 任务的添加和删除

```javascript
// 添加任务到批量
lanes = lanes | newLane;

// 从批量中删除任务
lanes = lanes & ~removeLane;

// 示例
let lanes = 0b0001;           // Task1
lanes = lanes | 0b0010;       // 添加 Task2 → 0b0011
lanes = lanes | 0b0100;       // 添加 Task3 → 0b0111
lanes = lanes & ~0b0010;      // 删除 Task2 → 0b0101
```

#### 3. 任务分组

```javascript
// 多个任务组合成一组
const TransitionLanes: Lanes =
  0b0000000001111111111111111000000;

// 判断是否是过渡任务
function isTransition(lane) {
  return (lane & TransitionLanes) !== 0;
}
```

### Lane 相关的关键函数

#### getHighestPriorityLane
```javascript
// 获取最高优先级的 Lane
function getHighestPriorityLane(lanes: Lanes): Lane {
  // 分离出最右边的 1（最高优先级）
  return lanes & -lanes;
}

// 示例
lanes = 0b0110;  // 有两个任务
getHighestPriorityLane(lanes);  // 0b0010（优先级更高）
```

#### mergeLanes
```javascript
// 合并 Lanes
function mergeLanes(a: Lanes, b: Lanes): Lanes {
  return a | b;
}
```

#### removeLanes
```javascript
// 移除 Lanes
function removeLanes(set: Lanes, subset: Lanes): Lanes {
  return set & ~subset;
}
```

#### intersectLanes
```javascript
// 交集
function intersectLanes(a: Lanes, b: Lanes): Lanes {
  return a & b;
}
```

## Scheduler 优先级

### 五种调度优先级

```javascript
// scheduler/src/SchedulerPriorities.js
export const NoPriority = 0;
export const ImmediatePriority = 1;       // 立即执行
export const UserBlockingPriority = 2;    // 用户阻塞
export const NormalPriority = 3;          // 普通
export const LowPriority = 4;             // 低优先级
export const IdlePriority = 5;            // 空闲
```

### 优先级对应的超时时间

```javascript
const IMMEDIATE_PRIORITY_TIMEOUT = -1;           // 立即执行
const USER_BLOCKING_PRIORITY_TIMEOUT = 250;      // 250ms
const NORMAL_PRIORITY_TIMEOUT = 5000;            // 5s
const LOW_PRIORITY_TIMEOUT = 10000;              // 10s
const IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // 永不过期
```

### 过期时间机制

```javascript
// 计算过期时间
const expirationTime = startTime + timeout;

// 判断是否过期
const isExpired = currentTime >= expirationTime;

// 过期的任务会被同步执行
if (isExpired) {
  performSyncWorkOnRoot(root);
}
```

## ReactPriorityLevel（转换层）

### 作用
连接 Lane 和 Scheduler 优先级，实现两套体系的转换。

### Lane → Scheduler 优先级

```javascript
// react-reconciler/src/SchedulerWithReactIntegration.js
export function lanePriorityToSchedulerPriority(
  lanePriority: LanePriority,
): SchedulerPriority {
  switch (lanePriority) {
    case SyncLanePriority:
    case SyncBatchedLanePriority:
      return ImmediateSchedulerPriority;

    case InputDiscreteHydrationLanePriority:
    case InputDiscreteLanePriority:
    case InputContinuousHydrationLanePriority:
    case InputContinuousLanePriority:
      return UserBlockingSchedulerPriority;

    case DefaultHydrationLanePriority:
    case DefaultLanePriority:
    case TransitionHydrationPriority:
    case TransitionPriority:
    case SelectiveHydrationLanePriority:
    case RetryLanePriority:
      return NormalSchedulerPriority;

    case IdleHydrationLanePriority:
    case IdleLanePriority:
    case OffscreenLanePriority:
      return IdleSchedulerPriority;

    default:
      return NormalSchedulerPriority;
  }
}
```

### Scheduler 优先级 → Lane

```javascript
export function schedulerPriorityToLanePriority(
  schedulerPriorityLevel: SchedulerPriority,
): LanePriority {
  switch (schedulerPriorityLevel) {
    case ImmediateSchedulerPriority:
      return SyncLanePriority;

    case UserBlockingSchedulerPriority:
      return InputContinuousLanePriority;

    case NormalSchedulerPriority:
    case LowSchedulerPriority:
      return DefaultLanePriority;

    case IdleSchedulerPriority:
      return IdleLanePriority;

    default:
      return NoLanePriority;
  }
}
```

## 优先级在运作流程中的应用

### 1. 创建 Update 时分配 Lane

```javascript
// 用户触发更新
function dispatchAction(fiber, queue, action) {
  // 1. 请求优先级
  const lane = requestUpdateLane(fiber);

  // 2. 创建 update
  const update = {
    lane,
    action,
    // ...
  };

  // 3. 加入队列
  enqueueUpdate(fiber, update);

  // 4. 调度更新
  scheduleUpdateOnFiber(fiber, lane);
}
```

### 2. 调度阶段转换优先级

```javascript
function ensureRootIsScheduled(root, currentTime) {
  // 1. 获取下一批要处理的 lanes
  const nextLanes = getNextLanes(root, NoLanes);

  // 2. 获取 lane 优先级
  const newCallbackPriority = returnNextLanesPriority();

  // 3. 转换为 scheduler 优先级
  const schedulerPriorityLevel =
    lanePriorityToSchedulerPriority(newCallbackPriority);

  // 4. 注册调度任务
  const newCallbackNode = scheduleCallback(
    schedulerPriorityLevel,
    performConcurrentWorkOnRoot.bind(null, root),
  );
}
```

### 3. Fiber 树构造时使用 Lane

```javascript
function renderRootConcurrent(root, lanes) {
  // 记录当前渲染的 lanes
  workInProgressRootRenderLanes = lanes;

  // 构造 Fiber 树
  workLoopConcurrent();

  // 检查是否有更高优先级的更新
  if (includesSomeLane(
    workInProgressRootIncludedLanes,
    workInProgressRootUpdatedLanes
  )) {
    // 有更高优先级的更新，重新开始
    prepareFreshStack(root, NoLanes);
  }
}
```

### 4. Commit 阶段处理优先级

```javascript
function commitRootImpl(root) {
  // 获取本次提交的 lanes
  const finishedWork = root.finishedWork;
  const lanes = root.finishedLanes;

  // 提交更新
  commitBeforeMutationEffects();
  commitMutationEffects(root, lanes);
  commitLayoutEffects(root, lanes);

  // 清除已完成的 lanes
  root.finishedLanes = NoLanes;
}
```

## 优先级的传播

### 向上标记优先级

```javascript
// 从触发更新的 fiber 向上标记到 root
function markUpdateLaneFromFiberToRoot(
  sourceFiber: Fiber,
  lane: Lane,
): FiberRoot | null {
  // 标记当前 fiber
  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);

  let node = sourceFiber;
  let parent = node.return;

  // 向上遍历，标记所有祖先节点
  while (parent !== null) {
    parent.childLanes = mergeLanes(parent.childLanes, lane);

    node = parent;
    parent = parent.return;
  }

  // 返回 FiberRoot
  return node.stateNode;
}
```

### 向下检查优先级

```javascript
function beginWork(current, workInProgress, renderLanes) {
  // 检查子节点是否有需要更新的 lanes
  const childLanes = workInProgress.childLanes;

  if (!includesSomeLane(renderLanes, childLanes)) {
    // 子树没有需要更新的内容，跳过
    return bailoutOnAlreadyFinishedWork(
      current,
      workInProgress,
      renderLanes,
    );
  }

  // 子树有更新，继续处理
  // ...
}
```

## 优先级的实际应用

### 1. 高优先级插队

```javascript
// 正在渲染 NormalPriority 的更新
renderRootConcurrent(root, DefaultLane);

// 突然来了一个 UserBlockingPriority 的更新
scheduleUpdateOnFiber(fiber, InputContinuousLane);

// 中断当前渲染，处理高优先级更新
if (newLane > currentLane) {
  prepareFreshStack(root, NoLanes);
  renderRootSync(root, InputContinuousLane);
}
```

### 2. 批量更新

```javascript
// 多个 setState 合并为一次更新
setState({ a: 1 });  // Lane: 0b0010
setState({ b: 2 });  // Lane: 0b0010
setState({ c: 3 });  // Lane: 0b0010

// 合并为同一批
lanes = 0b0010;  // 只触发一次渲染
```

### 3. Suspense 与优先级

```javascript
// CPU 密集任务
renderHighPriorityUpdate(SyncLane);

// IO 密集任务（Suspense）
renderLowPriorityUpdate(TransitionLane);

// 分离 IO 任务，优先处理 CPU 任务
const cpuLanes = lanes & ~TransitionLanes;
renderRootSync(root, cpuLanes);
```

## 优先级流转图

```
用户操作（点击、输入）
        ↓
requestUpdateLane()
        ↓ 分配 Lane
    Lane (Fiber 优先级)
        ↓
markUpdateLaneFromFiberToRoot()
        ↓ 向上传播
    FiberRoot.pendingLanes
        ↓
ensureRootIsScheduled()
        ↓ Lane → Scheduler 转换
    SchedulerPriority
        ↓
scheduleCallback()
        ↓ 加入任务队列
    按优先级排序
        ↓
performWorkOnRoot()
        ↓ 使用 Lane 渲染
    renderRoot(root, lanes)
        ↓
commitRoot()
        ↓ 清除 lanes
    FiberRoot.finishedLanes = NoLanes
```

## 总结

React 的三套优先级体系各司其职：

| 优先级体系 | 位置 | 作用 | 表示方式 |
|-----------|------|------|---------|
| Lane | react-reconciler | Fiber 树优先级管理 | 31 位二进制 |
| SchedulerPriority | scheduler | 任务调度优先级 | 1-5 数字 |
| ReactPriorityLevel | reconciler | 转换层 | 枚举 |

**核心机制**：
1. Lane 使用位运算实现高效的优先级操作
2. Scheduler 优先级控制任务执行顺序
3. ReactPriorityLevel 连接两套体系

**关键特性**：
- 高优先级可以插队
- 多个相同优先级可以合并
- 支持任务的中断和恢复
- 实现了时间切片和并发渲染

优先级管理是 React 实现高性能的核心机制之一。
