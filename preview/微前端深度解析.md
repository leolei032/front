# 微前端深度解析

## 目录
1. [微前端核心概念](#一微前端核心概念)
2. [主流微前端方案对比](#二主流微前端方案对比)
3. [qiankun 实现原理深度解析](#三qiankun-实现原理深度解析)
4. [样式隔离方案](#四样式隔离方案)
5. [JavaScript 沙箱机制](#五javascript-沙箱机制)
6. [应用间通信](#六应用间通信)
7. [Webpack5 模块联邦](#七webpack5-模块联邦)
8. [常见面试问题](#八常见面试问题)

---

## 一、微前端核心概念

### 1.1 什么是微前端？

微前端是一种将**前端应用分解为多个独立的、可独立开发和部署的小型应用**的架构风格，这些小应用最终组合成一个完整的应用。

**核心思想：**
- **技术栈无关**：不同子应用可以使用不同的技术栈（React、Vue、Angular）
- **独立开发部署**：各团队独立开发、测试、部署
- **增量升级**：可以逐步迁移老项目，而不是一次性重写
- **运行时集成**：在浏览器中动态加载和卸载子应用

### 1.2 为什么需要微前端？

**业务场景：**
- 大型单体应用难以维护，构建时间长
- 多团队协作，技术栈不统一
- 老项目需要逐步重构，不能停止业务
- 不同业务模块需要独立发版

**解决的问题：**
- 代码库过大，开发效率低
- 技术债务难以偿还
- 团队协作冲突多
- 部署风险高

---

## 二、主流微前端方案对比

### 2.1 iframe 方案

**原理：** 最简单的微前端方案，通过 iframe 加载子应用

**优点：**
- 天然隔离（样式、JS、全局变量）
- 实现简单

**缺点：**
- URL 不同步（浏览器前进后退问题）
- 性能差（每个 iframe 都是独立的浏览器上下文）
- 通信复杂（postMessage）
- 弹窗、遮罩层等 UI 问题
- SEO 不友好

### 2.2 single-spa

**原理：** 微前端框架的鼻祖，提供应用注册、加载、卸载的生命周期管理

**核心概念：**
- 提供路由劫持和应用生命周期
- 子应用需要导出 `bootstrap`、`mount`、`unmount` 三个生命周期函数
- 不提供 JS 沙箱和样式隔离，需要自己实现

**特点：**
- 轻量级，只做应用调度
- 需要配合其他方案实现隔离

### 2.3 qiankun（阿里）

**原理：** 基于 single-spa 封装，提供了更完善的沙箱和样式隔离方案

**核心能力：**
- 基于 single-spa 的应用加载
- JS 沙箱（Proxy 沙箱、快照沙箱）
- 样式隔离（Shadow DOM、scoped CSS）
- 资源预加载
- 应用间通信

**特点：**
- 开箱即用，配置简单
- 生态完善，社区活跃
- 适合中大型项目

### 2.4 Webpack5 模块联邦（Module Federation）

**原理：** 通过 Webpack 构建时的能力，实现应用间的模块共享

**核心特点：**
- 构建时方案，不是运行时方案
- 可以共享代码和依赖
- 性能更好
- 需要 Webpack 5+

### 2.5 Web Components

**原理：** 使用浏览器原生的 Web Components 标准

**特点：**
- 原生支持，无需框架
- 天然隔离（Shadow DOM）
- 兼容性问题

---

## 三、qiankun 实现原理深度解析

### 3.1 整体架构

qiankun 的核心是**应用加载 + 沙箱隔离 + 样式隔离**

```
主应用
  ├── 注册子应用（registerMicroApps）
  ├── 启动 qiankun（start）
  └── 监听路由变化
       ├── 匹配子应用
       ├── 加载子应用资源（HTML、JS、CSS）
       ├── 创建沙箱环境
       ├── 渲染子应用
       └── 卸载时清理
```

### 3.2 应用加载流程

**核心步骤：**

1. **注册阶段**
   - 主应用调用 `registerMicroApps` 注册子应用配置
   - 配置包括：name、entry、container、activeRule

2. **路由监听**
   - qiankun 劫持 `pushState`、`replaceState`、`hashchange` 等事件
   - 当路由变化时，判断是否需要加载/卸载子应用

3. **资源加载**
   - 通过 `fetch` 获取子应用的 HTML
   - 解析 HTML，提取 JS、CSS 资源
   - 加载并执行 JS 文件

4. **沙箱创建**
   - 为子应用创建独立的 JS 沙箱
   - 拦截全局变量的读写

5. **挂载应用**
   - 调用子应用的 `mount` 生命周期
   - 将子应用渲染到指定容器

**关键代码理解：**

```javascript
// 主应用注册子应用
registerMicroApps([
  {
    name: 'app1',
    entry: '//localhost:8080',  // 子应用地址
    container: '#subapp',        // 渲染容器
    activeRule: '/app1',         // 激活路由
  }
]);

// 启动 qiankun
start();
```

### 3.3 HTML Entry 原理

qiankun 使用 **HTML Entry** 而不是 JS Entry，这是它的一大特色。

**为什么用 HTML Entry？**
- 子应用可以独立运行（直接访问 HTML）
- 不需要额外配置入口文件
- 更接近传统的 Web 应用开发方式

**实现原理：**

```javascript
// 1. fetch 获取 HTML
const html = await fetch(entry).then(res => res.text());

// 2. 解析 HTML，提取资源
const { template, scripts, styles } = parseHTML(html);

// 3. 加载 JS 和 CSS
const jsCode = await Promise.all(scripts.map(src => fetch(src)));
const cssCode = await Promise.all(styles.map(href => fetch(href)));

// 4. 在沙箱中执行 JS
sandbox.execScripts(jsCode);
```

**核心逻辑：**
- 通过正则表达式解析 HTML 中的 `<script>` 和 `<link>` 标签
- 将外联资源转换为内联资源
- 在沙箱环境中执行

### 3.4 import-html-entry

qiankun 底层使用 `import-html-entry` 库来处理 HTML 解析和资源加载。

**核心功能：**
- 解析 HTML 字符串
- 提取 JS、CSS 资源
- 处理资源加载顺序
- 支持 `<script type="module">`

---

## 四、样式隔离方案

样式隔离是微前端的核心问题之一，qiankun 提供了多种方案。

### 4.1 为什么需要样式隔离？

**问题场景：**
- 主应用和子应用的样式互相污染
- 多个子应用之间的样式冲突
- 全局样式（body、html）被覆盖

### 4.2 strictStyleIsolation（严格样式隔离）

**原理：** 使用 **Shadow DOM** 实现完全隔离

```javascript
start({
  sandbox: {
    strictStyleIsolation: true  // 开启严格样式隔离
  }
});
```

**Shadow DOM 原理：**
- 为子应用的容器创建 Shadow Root
- 子应用的样式只在 Shadow DOM 内生效
- 完全隔离，主应用样式无法影响子应用

**优点：**
- 完全隔离，不会有样式冲突

**缺点：**
- 弹窗、tooltip 等挂载到 body 的元素样式会丢失
- 第三方 UI 库可能不兼容
- 调试困难

**实现理解：**

```javascript
// qiankun 内部实现
const shadowRoot = container.attachShadow({ mode: 'open' });
shadowRoot.innerHTML = subAppHTML;
```

### 4.3 experimentalStyleIsolation（实验性样式隔离）

**原理：** 使用 **CSS Scoped** 方案，为子应用的样式添加特殊前缀

```javascript
start({
  sandbox: {
    experimentalStyleIsolation: true
  }
});
```

**实现原理：**
- 动态改写子应用的 CSS 选择器
- 为每个选择器添加特定的属性选择器

**转换示例：**

```css
/* 原始样式 */
.button { color: red; }

/* 转换后 */
div[data-qiankun="app1"] .button { color: red; }
```

**优点：**
- 不影响弹窗等元素
- 兼容性好

**缺点：**
- 不是完全隔离
- 权重可能被覆盖

### 4.4 手动样式隔离方案

**方案一：CSS Modules**
- 构建时生成唯一的类名
- 适合新项目

**方案二：CSS-in-JS**
- 样式写在 JS 中，动态生成
- 天然隔离

**方案三：约定式命名**
- 为每个子应用添加统一前缀
- 如：`.app1-button`、`.app2-button`

**方案四：动态样式加载/卸载**
- 子应用挂载时加载样式
- 卸载时移除样式标签

```javascript
// 子应用生命周期
export async function mount(props) {
  // 加载样式
  const style = document.createElement('link');
  style.href = '/app1.css';
  style.setAttribute('data-app', 'app1');
  document.head.appendChild(style);
}

export async function unmount() {
  // 移除样式
  const styles = document.querySelectorAll('[data-app="app1"]');
  styles.forEach(style => style.remove());
}
```

---

## 五、JavaScript 沙箱机制

JS 沙箱是微前端的核心技术，用于隔离子应用的全局变量，防止污染。

### 5.1 为什么需要 JS 沙箱？

**问题场景：**
- 子应用修改了 `window` 对象（如 `window.name`）
- 多个子应用使用同一个全局变量
- 子应用卸载后，全局变量没有清理

### 5.2 快照沙箱（SnapshotSandbox）

**适用场景：** 单个子应用，不支持多实例

**原理：** 在应用激活时记录 `window` 快照，卸载时恢复

**实现思路：**

```javascript
class SnapshotSandbox {
  constructor() {
    this.windowSnapshot = {};
    this.modifyPropsMap = {};
  }

  // 激活沙箱
  active() {
    // 1. 保存当前 window 状态
    for (const prop in window) {
      this.windowSnapshot[prop] = window[prop];
    }

    // 2. 恢复上次的修改
    Object.keys(this.modifyPropsMap).forEach(prop => {
      window[prop] = this.modifyPropsMap[prop];
    });
  }

  // 失活沙箱
  inactive() {
    // 1. 记录修改了哪些属性
    for (const prop in window) {
      if (window[prop] !== this.windowSnapshot[prop]) {
        this.modifyPropsMap[prop] = window[prop];
        // 2. 恢复原始值
        window[prop] = this.windowSnapshot[prop];
      }
    }
  }
}
```

**核心思想：**
- 激活时：保存快照 + 恢复上次修改
- 失活时：记录修改 + 恢复快照

**优点：**
- 实现简单
- 兼容性好（不需要 Proxy）

**缺点：**
- 性能差（需要遍历 window）
- 不支持多实例

### 5.3 Proxy 沙箱（ProxySandbox）

**适用场景：** 支持多个子应用同时运行

**原理：** 使用 ES6 Proxy 代理 `window` 对象，拦截属性的读写

**实现思路：**

```javascript
class ProxySandbox {
  constructor() {
    this.fakeWindow = {};  // 假的 window 对象
    this.proxyWindow = null;

    this.proxyWindow = new Proxy(this.fakeWindow, {
      get: (target, prop) => {
        // 优先从 fakeWindow 读取
        if (prop in target) {
          return target[prop];
        }
        // 否则从真实 window 读取
        return window[prop];
      },

      set: (target, prop, value) => {
        // 所有修改都记录到 fakeWindow
        target[prop] = value;
        return true;
      }
    });
  }

  active() {
    // 激活时，子应用使用 proxyWindow
  }

  inactive() {
    // 失活时，fakeWindow 保留，不影响 window
  }
}
```

**核心思想：**
- 为每个子应用创建一个 `fakeWindow`
- 子应用的所有全局变量操作都在 `fakeWindow` 上
- 不会污染真实的 `window`

**优点：**
- 支持多实例
- 性能好（不需要遍历）
- 隔离彻底

**缺点：**
- 不兼容 IE（需要 Proxy 支持）

### 5.4 LegacyProxySandbox（遗留 Proxy 沙箱）

**适用场景：** 单实例，但使用 Proxy 实现

**原理：** 直接代理 `window`，记录修改，卸载时恢复

```javascript
class LegacySandbox {
  constructor() {
    this.addedPropsMap = {};     // 新增的属性
    this.modifiedPropsMap = {};  // 修改的属性
    this.currentPropsMap = {};   // 当前的属性值

    const { addedPropsMap, modifiedPropsMap, currentPropsMap } = this;

    this.proxyWindow = new Proxy(window, {
      get(target, prop) {
        return target[prop];
      },

      set(target, prop, value) {
        if (!target.hasOwnProperty(prop)) {
          // 新增属性
          addedPropsMap[prop] = value;
        } else if (!modifiedPropsMap.hasOwnProperty(prop)) {
          // 第一次修改，记录原始值
          modifiedPropsMap[prop] = target[prop];
        }

        currentPropsMap[prop] = value;
        target[prop] = value;
        return true;
      }
    });
  }

  active() {
    // 恢复修改
    Object.keys(this.currentPropsMap).forEach(prop => {
      window[prop] = this.currentPropsMap[prop];
    });
  }

  inactive() {
    // 删除新增的属性
    Object.keys(this.addedPropsMap).forEach(prop => {
      delete window[prop];
    });

    // 恢复修改的属性
    Object.keys(this.modifiedPropsMap).forEach(prop => {
      window[prop] = this.modifiedPropsMap[prop];
    });
  }
}
```

### 5.5 沙箱对比总结

| 沙箱类型 | 多实例 | 性能 | 兼容性 | 隔离程度 |
|---------|--------|------|--------|---------|
| SnapshotSandbox | ❌ | 差 | 好 | 中 |
| LegacyProxySandbox | ❌ | 好 | 需要 Proxy | 中 |
| ProxySandbox | ✅ | 好 | 需要 Proxy | 高 |

### 5.6 沙箱的局限性

**无法隔离的场景：**
- DOM 操作（如 `document.body.appendChild`）
- 事件监听（如 `window.addEventListener`）
- 定时器（如 `setTimeout`、`setInterval`）
- 网络请求（如 `fetch`、`XMLHttpRequest`）

**解决方案：**
- 在子应用卸载时手动清理
- 使用 qiankun 提供的生命周期钩子

---

## 六、应用间通信

### 6.1 通信方式

**1. Props 传递（推荐）**

```javascript
// 主应用
registerMicroApps([
  {
    name: 'app1',
    entry: '//localhost:8080',
    container: '#subapp',
    activeRule: '/app1',
    props: {
      data: { user: 'admin' },
      onGlobalStateChange: () => {},
    }
  }
]);

// 子应用
export async function mount(props) {
  console.log(props.data);  // { user: 'admin' }
}
```

**2. 全局状态管理（initGlobalState）**

```javascript
// 主应用
import { initGlobalState } from 'qiankun';

const actions = initGlobalState({ user: 'admin' });

actions.onGlobalStateChange((state, prev) => {
  console.log('主应用监听到变化', state);
});

actions.setGlobalState({ user: 'new user' });

// 子应用
export async function mount(props) {
  props.onGlobalStateChange((state, prev) => {
    console.log('子应用监听到变化', state);
  });

  props.setGlobalState({ user: 'from sub app' });
}
```

**3. 自定义事件（CustomEvent）**

```javascript
// 发送事件
window.dispatchEvent(new CustomEvent('app1-event', {
  detail: { data: 'hello' }
}));

// 监听事件
window.addEventListener('app1-event', (e) => {
  console.log(e.detail.data);
});
```

**4. 共享状态库（Redux、Mobx）**

```javascript
// 主应用创建 store
import { createStore } from 'redux';

const store = createStore(reducer);

registerMicroApps([
  {
    name: 'app1',
    entry: '//localhost:8080',
    container: '#subapp',
    activeRule: '/app1',
    props: {
      store,  // 传递 store
    }
  }
]);

// 子应用使用 store
export async function mount(props) {
  const { store } = props;

  // 订阅状态变化
  store.subscribe(() => {
    console.log('状态变化', store.getState());
  });

  // 派发 action
  store.dispatch({ type: 'UPDATE_USER', payload: { name: 'admin' } });
}
```

**5. 通过主应用中转（子应用间通信）**

当子应用之间需要通信时，可以通过主应用作为中转站。

```javascript
// 主应用：创建事件总线
class EventBus {
  constructor() {
    this.events = {};
  }

  // 订阅事件
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }

  // 发布事件
  emit(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(callback => callback(data));
    }
  }

  // 取消订阅
  off(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }
}

const eventBus = new EventBus();

// 注册时传递给所有子应用
registerMicroApps([
  {
    name: 'app1',
    entry: '//localhost:8080',
    container: '#subapp',
    activeRule: '/app1',
    props: { eventBus }
  },
  {
    name: 'app2',
    entry: '//localhost:8081',
    container: '#subapp',
    activeRule: '/app2',
    props: { eventBus }
  }
]);

// 子应用 A：发送消息
export async function mount(props) {
  const { eventBus } = props;

  // 发送消息给其他子应用
  eventBus.emit('app1:message', { text: 'Hello from App1' });
}

// 子应用 B：接收消息
export async function mount(props) {
  const { eventBus } = props;

  // 监听来自其他子应用的消息
  eventBus.on('app1:message', (data) => {
    console.log('收到 App1 的消息', data);
  });
}

// 卸载时清理
export async function unmount(props) {
  const { eventBus } = props;
  eventBus.off('app1:message');
}
```

**6. 共享存储（LocalStorage/SessionStorage）**

适用于需要持久化或跨页面共享的数据。

```javascript
// 子应用 A：写入数据
export async function mount() {
  localStorage.setItem('shared-user', JSON.stringify({
    name: 'admin',
    token: 'xxx'
  }));

  // 触发 storage 事件通知其他应用
  window.dispatchEvent(new StorageEvent('storage', {
    key: 'shared-user',
    newValue: JSON.stringify({ name: 'admin', token: 'xxx' })
  }));
}

// 子应用 B：读取数据
export async function mount() {
  // 读取共享数据
  const userData = JSON.parse(localStorage.getItem('shared-user'));
  console.log('共享的用户数据', userData);

  // 监听其他应用的数据变化
  window.addEventListener('storage', (e) => {
    if (e.key === 'shared-user') {
      console.log('用户数据更新', JSON.parse(e.newValue));
    }
  });
}

// 使用封装的工具类
class SharedStorage {
  static set(key, value) {
    const data = JSON.stringify(value);
    localStorage.setItem(key, data);
    // 主动触发事件（同页面通信）
    window.dispatchEvent(new CustomEvent('shared-storage-change', {
      detail: { key, value }
    }));
  }

  static get(key) {
    const data = localStorage.getItem(key);
    return data ? JSON.parse(data) : null;
  }

  static watch(key, callback) {
    // 监听跨页面变化
    window.addEventListener('storage', (e) => {
      if (e.key === key) {
        callback(JSON.parse(e.newValue), JSON.parse(e.oldValue));
      }
    });

    // 监听同页面变化
    window.addEventListener('shared-storage-change', (e) => {
      if (e.detail.key === key) {
        callback(e.detail.value);
      }
    });
  }
}

// 使用示例
SharedStorage.set('user', { name: 'admin' });
SharedStorage.watch('user', (newValue) => {
  console.log('用户数据变化', newValue);
});
```

**7. SharedWorker（高性能实时通信）**

SharedWorker 可以在多个浏览器上下文间共享，适合高性能实时通信场景。

```javascript
// shared-worker.js
const connections = [];

self.addEventListener('connect', (e) => {
  const port = e.ports[0];
  connections.push(port);

  port.addEventListener('message', (event) => {
    const { type, data, from } = event.data;

    // 广播消息给所有连接
    connections.forEach(conn => {
      if (conn !== port) {
        conn.postMessage({ type, data, from });
      }
    });
  });

  port.start();
});

// 主应用或子应用使用
class SharedWorkerBus {
  constructor() {
    this.worker = new SharedWorker('/shared-worker.js');
    this.port = this.worker.port;
    this.callbacks = {};

    this.port.addEventListener('message', (e) => {
      const { type, data, from } = e.data;
      if (this.callbacks[type]) {
        this.callbacks[type].forEach(cb => cb(data, from));
      }
    });

    this.port.start();
  }

  // 发送消息
  emit(type, data, from) {
    this.port.postMessage({ type, data, from });
  }

  // 监听消息
  on(type, callback) {
    if (!this.callbacks[type]) {
      this.callbacks[type] = [];
    }
    this.callbacks[type].push(callback);
  }

  // 取消监听
  off(type, callback) {
    if (this.callbacks[type]) {
      this.callbacks[type] = this.callbacks[type].filter(cb => cb !== callback);
    }
  }
}

// 子应用 A
export async function mount() {
  const bus = new SharedWorkerBus();

  // 发送消息
  bus.emit('user:update', { name: 'admin' }, 'app1');

  // 监听消息
  bus.on('user:update', (data, from) => {
    console.log(`收到来自 ${from} 的消息`, data);
  });
}

// 子应用 B 也可以使用相同的方式通信
```

**注意事项：**
- **SharedWorker 兼容性**：不支持 Safari、IE
- **同源限制**：只能在同源的应用间使用
- **调试困难**：需要在 Chrome DevTools 的 `chrome://inspect/#workers` 中调试

### 6.2 通信方案对比与选择建议

| 通信方式 | 适用场景 | 优点 | 缺点 | 推荐指数 |
|---------|---------|------|------|----------|
| **Props** | 父子简单通信 | 官方支持，简单直接 | 只能主→子，不适合复杂场景 | ⭐⭐⭐⭐⭐ |
| **initGlobalState** | 全局状态管理 | 官方方案，双向通信，维护性好 | 需要主应用协调，状态管理复杂 | ⭐⭐⭐⭐⭐ |
| **CustomEvent** | 事件驱动通信 | 原生支持，灵活，解耦 | 需要手动管理监听器，容易内存泄漏 | ⭐⭐⭐⭐ |
| **通过主应用中转** | 子应用间通信 | 集中管理，可控性强，易于调试 | 主应用复杂度增加，单点故障 | ⭐⭐⭐⭐ |
| **共享存储** | 数据持久化共享 | 跨页面，数据持久化，简单 | 安全性考虑，需要序列化，容量限制 | ⭐⭐⭐ |
| **SharedWorker** | 高性能实时通信 | 真正的多应用共享，性能好 | 浏览器兼容性差，调试困难 | ⭐⭐ |
| **状态管理库** | 复杂状态共享 | 生态完善，工具丰富，状态可追溯 | 学习成本高，包体积大，耦合度高 | ⭐⭐⭐⭐ |

### 6.3 通信方案选择指南

**场景一：主应用向子应用传递初始数据**
- 推荐：**Props**
- 理由：简单直接，官方推荐

**场景二：主应用和子应用需要双向通信**
- 推荐：**initGlobalState**
- 理由：官方提供，专为微前端设计

**场景三：子应用之间需要通信**
- 推荐：**通过主应用中转** 或 **CustomEvent**
- 理由：可控性强，便于管理

**场景四：需要持久化存储的数据（如用户 token）**
- 推荐：**共享存储（LocalStorage）**
- 理由：数据持久化，刷新不丢失

**场景五：复杂的状态管理（如购物车、用户权限）**
- 推荐：**状态管理库（Redux/Mobx）**
- 理由：状态可追溯，生态完善

**场景六：高频实时通信（如聊天、实时数据）**
- 推荐：**SharedWorker**（如果兼容性允许）
- 备选：**通过主应用中转 + 防抖/节流**

**场景七：简单的事件通知**
- 推荐：**CustomEvent**
- 理由：原生支持，轻量级

### 6.4 通信最佳实践

**1. 命名规范**

```javascript
// 使用应用名前缀，避免冲突
eventBus.emit('app1:user:login', data);
eventBus.emit('app2:order:create', data);

// LocalStorage 也使用前缀
localStorage.setItem('micro-fe:app1:token', token);
```

**2. 避免内存泄漏**

```javascript
// 错误示例：未清理监听器
export async function mount(props) {
  props.onGlobalStateChange((state) => {
    console.log(state);
  });
}

// 正确示例：卸载时清理
let unsubscribe;

export async function mount(props) {
  unsubscribe = props.onGlobalStateChange((state) => {
    console.log(state);
  });
}

export async function unmount() {
  unsubscribe && unsubscribe();
}
```

**3. 数据格式约定**

```javascript
// 定义统一的消息格式
interface Message {
  type: string;      // 消息类型
  from: string;      // 发送者
  to?: string;       // 接收者（可选）
  data: any;         // 消息数据
  timestamp: number; // 时间戳
}

// 使用
eventBus.emit('message', {
  type: 'user:login',
  from: 'app1',
  data: { userId: 123 },
  timestamp: Date.now()
});
```

**4. 错误处理**

```javascript
// 通信失败时的降级方案
async function sendMessage(data) {
  try {
    // 尝试使用 SharedWorker
    sharedWorker.emit('message', data);
  } catch (error) {
    console.warn('SharedWorker 不可用，降级到 CustomEvent', error);
    // 降级到 CustomEvent
    window.dispatchEvent(new CustomEvent('message', { detail: data }));
  }
}
```

**5. 类型安全（TypeScript）**

```typescript
// 定义通信接口
interface GlobalState {
  user: {
    id: number;
    name: string;
  };
  token: string;
}

interface MicroAppProps {
  onGlobalStateChange: (
    callback: (state: GlobalState, prev: GlobalState) => void
  ) => void;
  setGlobalState: (state: Partial<GlobalState>) => void;
}

// 使用
export async function mount(props: MicroAppProps) {
  props.onGlobalStateChange((state, prev) => {
    // TypeScript 会提供类型提示和检查
    console.log(state.user.name);
  });
}
```

---

## 七、Webpack5 模块联邦

### 7.1 什么是模块联邦（Module Federation）？

模块联邦是 Webpack 5 引入的新特性，允许**多个独立的构建可以在运行时共享代码和依赖**。

**核心概念：**
- **Host（宿主应用）**：消费其他应用的模块
- **Remote（远程应用）**：提供模块给其他应用使用
- **Shared（共享依赖）**：多个应用共享的依赖（如 React、Vue）

### 7.2 为什么需要模块联邦？

**传统微前端的问题：**
- 每个子应用都打包了 React/Vue，重复加载
- 子应用之间无法共享代码
- 需要运行时加载整个应用

**模块联邦的优势：**
- **依赖共享**：多个应用共享同一份 React
- **按需加载**：只加载需要的模块
- **版本管理**：自动处理依赖版本冲突
- **构建时优化**：比运行时方案性能更好

### 7.3 模块联邦配置

**应用 A（Remote）：提供模块**

```javascript
// webpack.config.js
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'app1',  // 应用名称
      filename: 'remoteEntry.js',  // 入口文件
      exposes: {
        // 暴露的模块
        './Button': './src/components/Button',
        './utils': './src/utils',
      },
      shared: {
        // 共享的依赖
        react: { singleton: true },
        'react-dom': { singleton: true },
      },
    }),
  ],
};
```

**应用 B（Host）：消费模块**

```javascript
// webpack.config.js
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'app2',
      remotes: {
        // 远程应用
        app1: 'app1@http://localhost:3001/remoteEntry.js',
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
      },
    }),
  ],
};
```

**使用远程模块：**

```javascript
// 应用 B 中使用应用 A 的组件
import Button from 'app1/Button';

function App() {
  return <Button>Click me</Button>;
}
```

### 7.4 模块联邦实现原理

**核心流程：**

1. **构建阶段**
   - Remote 应用打包时，生成 `remoteEntry.js`
   - 这个文件包含了模块的元信息和加载逻辑

2. **运行时加载**
   - Host 应用启动时，加载 `remoteEntry.js`
   - 注册 Remote 应用的模块

3. **模块获取**
   - 当代码中 `import` 远程模块时
   - Webpack 通过 `remoteEntry.js` 动态加载对应的 chunk

4. **依赖共享**
   - 检查 shared 配置
   - 如果版本兼容，使用 Host 的依赖
   - 否则加载 Remote 的依赖

**关键概念理解：**

```javascript
// remoteEntry.js 的核心逻辑（简化版）
window.app1 = {
  get(module) {
    return () => {
      // 动态加载模块
      return import('./Button.chunk.js');
    };
  },
  init(shared) {
    // 初始化共享依赖
    this.shared = shared;
  }
};
```

### 7.5 Shared 共享依赖策略

**singleton（单例模式）**

```javascript
shared: {
  react: {
    singleton: true,  // 只加载一个版本
    requiredVersion: '^18.0.0',
  }
}
```

- 确保全局只有一个 React 实例
- 如果版本不兼容，会报错或警告

**eager（预加载）**

```javascript
shared: {
  react: {
    eager: true,  // 立即加载，不异步
  }
}
```

- 不使用异步加载
- 适合主应用的核心依赖

**strictVersion（严格版本）**

```javascript
shared: {
  react: {
    strictVersion: true,
    requiredVersion: '18.2.0',
  }
}
```

- 版本必须完全匹配
- 否则报错

### 7.6 模块联邦 vs qiankun

| 对比项 | 模块联邦 | qiankun |
|-------|---------|---------|
| 方案类型 | 构建时 | 运行时 |
| 技术栈 | 需要 Webpack 5 | 技术栈无关 |
| 依赖共享 | 自动共享 | 手动处理 |
| 粒度 | 模块级别 | 应用级别 |
| 性能 | 更好 | 较差 |
| 灵活性 | 较低 | 更高 |
| 独立运行 | 不支持 | 支持 |

**选择建议：**
- **模块联邦**：适合新项目，技术栈统一，追求性能
- **qiankun**：适合老项目改造，技术栈多样，需要独立部署

### 7.7 模块联邦最佳实践

**1. 版本管理**
- 使用 `singleton` 确保依赖唯一
- 明确 `requiredVersion` 范围

**2. 错误处理**
- 使用 `React.lazy` + `Suspense` 处理加载失败
- 提供降级方案

```javascript
const RemoteButton = React.lazy(() =>
  import('app1/Button').catch(() => {
    return { default: () => <div>加载失败</div> };
  })
);

function App() {
  return (
    <Suspense fallback={<div>加载中...</div>}>
      <RemoteButton />
    </Suspense>
  );
}
```

**3. 类型支持**
- 为远程模块提供 TypeScript 类型声明

```typescript
// app1/types.d.ts
declare module 'app1/Button' {
  export const Button: React.FC<{ children: React.ReactNode }>;
}
```

**4. 缓存策略**
- 合理设置 `remoteEntry.js` 的缓存
- 使用版本号或 hash

---

## 八、常见面试问题

### 8.1 基础概念类

**Q1: 什么是微前端？解决了什么问题？**

**答案要点：**
- 定义：将前端应用拆分为多个独立的小应用
- 解决的问题：
  - 大型应用难以维护
  - 技术栈不统一
  - 团队协作冲突
  - 增量升级困难

**Q2: 微前端和微服务的区别？**

**答案要点：**
- 微服务：后端架构，服务拆分
- 微前端：前端架构，应用拆分
- 相同点：都是为了解决单体应用的问题
- 不同点：
  - 微服务运行在不同进程
  - 微前端运行在同一个浏览器

**Q3: 微前端有哪些实现方案？**

**答案要点：**
- iframe：最简单，隔离好，但体验差
- single-spa：轻量级，需要自己实现隔离
- qiankun：基于 single-spa，提供沙箱和样式隔离
- 模块联邦：Webpack 5，构建时方案
- Web Components：浏览器原生

### 8.2 qiankun 原理类

**Q4: qiankun 是如何加载子应用的？**

**答案要点：**
1. 通过 fetch 获取子应用的 HTML
2. 解析 HTML，提取 JS、CSS 资源
3. 创建沙箱环境
4. 在沙箱中执行 JS
5. 调用子应用的 mount 生命周期
6. 渲染到指定容器

**Q5: qiankun 的 HTML Entry 和 JS Entry 有什么区别？**

**答案要点：**
- **JS Entry**：
  - 需要配置入口 JS 文件
  - 子应用不能独立运行
  - single-spa 使用
- **HTML Entry**：
  - 直接加载 HTML
  - 子应用可以独立运行
  - qiankun 使用
  - 更符合传统开发习惯

**Q6: qiankun 如何实现路由劫持？**

**答案要点：**
- 劫持 `pushState`、`replaceState`
- 监听 `popstate`、`hashchange` 事件
- 当路由变化时，匹配子应用的 `activeRule`
- 决定加载或卸载子应用

### 8.3 沙箱机制类

**Q7: qiankun 有哪些沙箱方案？各有什么特点？**

**答案要点：**
- **SnapshotSandbox**：
  - 快照方式
  - 不支持多实例
  - 兼容性好
- **LegacyProxySandbox**：
  - Proxy 代理 window
  - 不支持多实例
  - 需要 Proxy 支持
- **ProxySandbox**：
  - 为每个应用创建 fakeWindow
  - 支持多实例
  - 隔离最彻底

**Q8: Proxy 沙箱是如何实现的？**

**答案要点：**
1. 为每个子应用创建一个 `fakeWindow` 对象
2. 使用 Proxy 代理 `fakeWindow`
3. get 操作：优先从 `fakeWindow` 读，否则从 `window` 读
4. set 操作：所有修改都写入 `fakeWindow`
5. 子应用的全局变量操作都在 `fakeWindow` 上
6. 不会污染真实的 `window`

**Q9: 沙箱有哪些局限性？**

**答案要点：**
- 无法隔离 DOM 操作
- 无法隔离事件监听
- 无法隔离定时器
- 无法隔离网络请求
- 需要在卸载时手动清理

### 8.4 样式隔离类

**Q10: qiankun 有哪些样式隔离方案？**

**答案要点：**
- **strictStyleIsolation**：
  - 使用 Shadow DOM
  - 完全隔离
  - 弹窗等元素样式会丢失
- **experimentalStyleIsolation**：
  - 动态改写 CSS 选择器
  - 添加属性选择器前缀
  - 兼容性好
- **手动方案**：
  - CSS Modules
  - CSS-in-JS
  - 约定式命名
  - 动态加载/卸载

**Q11: Shadow DOM 的优缺点？**

**答案要点：**
- **优点**：
  - 完全隔离
  - 不会有样式冲突
- **缺点**：
  - 弹窗等挂载到 body 的元素样式会丢失
  - 第三方 UI 库可能不兼容
  - 调试困难
  - 需要浏览器支持

**Q12: 如何解决弹窗样式丢失问题？**

**答案要点：**
- 不使用 Shadow DOM
- 使用 experimentalStyleIsolation
- 手动将弹窗挂载到 Shadow DOM 内
- 使用 CSS-in-JS

### 8.5 应用通信类

**Q13: 微前端应用间如何通信？有哪些方案？**

**答案要点：**
- **Props 传递**：主应用 → 子应用，适合简单数据传递
- **GlobalState**：qiankun 提供的全局状态，适合双向通信
- **CustomEvent**：自定义事件，适合事件驱动
- **通过主应用中转**：子应用间通信，集中管理
- **共享存储**：LocalStorage/SessionStorage，适合持久化数据
- **SharedWorker**：高性能实时通信，兼容性较差
- **状态管理库**：Redux、Mobx，适合复杂状态管理

**Q14: qiankun 的 GlobalState 是如何实现的？**

**答案要点：**
- 基于**发布订阅模式**
- 主应用调用 `initGlobalState` 创建全局状态
- 通过 props 传递 `onGlobalStateChange` 和 `setGlobalState` 给子应用
- 子应用可以监听和修改状态
- 状态变化时，所有订阅的应用都会收到通知
- 内部维护一个状态对象和订阅者列表

**Q14.5: 子应用之间如何通信？**

**答案要点：**
1. **通过主应用中转**（推荐）
   - 主应用创建事件总线（EventBus）
   - 通过 props 传递给所有子应用
   - 子应用通过事件总线发送和接收消息
   - 优点：集中管理，可控性强

2. **使用 GlobalState**
   - 子应用 A 修改全局状态
   - 子应用 B 监听状态变化
   - 适合需要共享状态的场景

3. **CustomEvent**
   - 子应用通过 `window.dispatchEvent` 发送事件
   - 其他子应用通过 `window.addEventListener` 监听
   - 注意命名冲突和内存泄漏

4. **共享存储**
   - 使用 LocalStorage/SessionStorage
   - 通过 storage 事件监听变化
   - 适合需要持久化的数据

**Q14.6: 微前端通信容易遇到哪些问题？如何解决？**

**答案要点：**

**问题一：内存泄漏**
- 原因：监听器未清理
- 解决：在 unmount 生命周期中移除监听器
```javascript
export async function unmount() {
  unsubscribe && unsubscribe();
  eventBus.off('event-name');
}
```

**问题二：命名冲突**
- 原因：多个子应用使用相同的事件名
- 解决：使用应用名前缀，如 `app1:user:login`

**问题三：数据一致性**
- 原因：多个子应用同时修改共享状态
- 解决：
  - 使用状态管理库（Redux）
  - 实现乐观锁或版本控制
  - 在主应用统一管理状态修改

**问题四：类型安全**
- 原因：通信数据格式不统一
- 解决：使用 TypeScript 定义接口，统一消息格式

**问题五：性能问题**
- 原因：高频通信导致性能下降
- 解决：
  - 使用防抖/节流
  - 批量更新
  - 使用 SharedWorker（如果兼容性允许）

### 8.6 模块联邦类

**Q15: 什么是 Webpack 模块联邦？**

**答案要点：**
- Webpack 5 的新特性
- 允许多个独立构建共享代码和依赖
- 构建时方案，不是运行时方案
- 核心概念：Host、Remote、Shared

**Q16: 模块联邦和 qiankun 的区别？**

**答案要点：**
- **模块联邦**：
  - 构建时方案
  - 需要 Webpack 5
  - 模块级别共享
  - 性能更好
  - 不支持独立运行
- **qiankun**：
  - 运行时方案
  - 技术栈无关
  - 应用级别加载
  - 支持独立运行
  - 更灵活

**Q17: 模块联邦的 shared 配置有什么作用？**

**答案要点：**
- 用于配置共享依赖
- `singleton`：确保只有一个实例
- `eager`：立即加载，不异步
- `requiredVersion`：指定版本范围
- `strictVersion`：严格版本匹配
- 避免重复加载依赖

**Q18: 模块联邦如何处理版本冲突？**

**答案要点：**
1. 检查 shared 配置的版本范围
2. 如果版本兼容，使用 Host 的依赖
3. 如果不兼容且 `singleton: true`，会警告或报错
4. 如果不兼容且没有 singleton，加载各自的版本
5. 可以通过 `requiredVersion` 控制版本范围

### 8.7 性能优化类

**Q19: 微前端有哪些性能问题？如何优化？**

**答案要点：**
- **问题**：
  - 子应用加载慢
  - 重复加载依赖
  - 首屏时间长
- **优化方案**：
  - 预加载：`prefetch`
  - 预渲染：提前渲染子应用
  - 依赖共享：externals 或模块联邦
  - 按需加载：路由懒加载
  - 缓存策略：合理设置 HTTP 缓存

**Q20: qiankun 的预加载是如何实现的？**

**答案要点：**
```javascript
start({
  prefetch: 'all',  // 预加载所有子应用
  // prefetch: true,  // 空闲时预加载
  // prefetch: ['app1', 'app2'],  // 指定预加载
});
```
- 在浏览器空闲时（requestIdleCallback）
- 提前 fetch 子应用的资源
- 缓存到内存中
- 真正加载时直接使用缓存

### 8.8 实战问题类

**Q21: 子应用如何判断是否在微前端环境中运行？**

**答案要点：**
```javascript
// 方式一：通过 window 上的标识
if (window.__POWERED_BY_QIANKUN__) {
  // 在 qiankun 中运行
}

// 方式二：通过生命周期
export async function mount(props) {
  // 如果有 props，说明在微前端环境
  if (props) {
    // 微前端环境
  } else {
    // 独立运行
  }
}
```

**Q22: 如何处理子应用的公共路径问题？**

**答案要点：**
```javascript
// webpack 配置
if (window.__POWERED_BY_QIANKUN__) {
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
}

// 或在 webpack.config.js 中
module.exports = {
  output: {
    publicPath: process.env.NODE_ENV === 'production'
      ? 'https://cdn.com/app1/'
      : '/',
  },
};
```

**Q23: 如何处理子应用的环境变量？**

**答案要点：**
- 通过 props 传递
- 通过 GlobalState 共享
- 子应用独立配置
- 使用 `.env` 文件

**Q24: 微前端项目如何调试？**

**答案要点：**
- 使用浏览器 DevTools
- 子应用独立运行调试
- 使用 `console.log` 区分应用
- 关闭沙箱和样式隔离
- 使用 Source Map

**Q25: 如何处理子应用的错误边界？**

**答案要点：**
```javascript
// 主应用
start({
  errorHandler: (error) => {
    console.error('子应用加载失败', error);
    // 显示错误页面
  },
});

// 子应用（React）
class ErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    console.error('子应用运行错误', error);
  }

  render() {
    if (this.state.hasError) {
      return <div>出错了</div>;
    }
    return this.props.children;
  }
}
```

---

## 九、总结

### 9.1 微前端核心要点

1. **应用加载**：HTML Entry、资源解析、生命周期管理
2. **JS 隔离**：快照沙箱、Proxy 沙箱、多实例支持
3. **样式隔离**：Shadow DOM、CSS Scoped、手动方案
4. **应用通信**：Props、GlobalState、事件、共享 Store
5. **性能优化**：预加载、依赖共享、缓存策略

### 9.2 qiankun vs 模块联邦

- **qiankun**：运行时方案，灵活，适合老项目改造
- **模块联邦**：构建时方案，性能好，适合新项目

### 9.3 技术选型建议

**选择 qiankun 的场景：**
- 技术栈多样（React + Vue + Angular）
- 需要独立部署
- 老项目改造
- 不想改动构建配置

**选择模块联邦的场景：**
- 技术栈统一（都是 React 或 Vue）
- 使用 Webpack 5
- 追求性能
- 新项目

**选择 iframe 的场景：**
- 极简场景
- 对性能要求不高
- 需要完全隔离

### 9.4 面试准备建议

1. **理解核心原理**：不要死记硬背，理解为什么这样设计
2. **动手实践**：搭建一个简单的微前端项目
3. **对比方案**：理解不同方案的优缺点和适用场景
4. **关注细节**：沙箱、样式隔离的实现细节
5. **实战经验**：遇到的问题和解决方案

---

## 十、参考资料

- [qiankun 官方文档](https://qiankun.umijs.org/)
- [single-spa 官方文档](https://single-spa.js.org/)
- [Webpack Module Federation](https://webpack.js.org/concepts/module-federation/)
- [微前端的核心价值](https://micro-frontends.org/)

---

**文档版本：** v1.0
**最后更新：** 2025-12-20

