# 微前端深度解析

## 目录
1. [微前端核心概念](#一微前端核心概念)
2. [主流微前端方案对比](#二主流微前端方案对比)
3. [qiankun 实现原理深度解析](#三qiankun-实现原理深度解析)
4. [样式隔离方案](#四样式隔离方案)
5. [JavaScript 沙箱机制](#五javascript-沙箱机制)
6. [应用间通信](#六应用间通信)
7. [Webpack5 模块联邦](#七webpack5-模块联邦)
8. [常见面试问题](#八常见面试问题)

---

## 一、微前端核心概念

### 1.1 什么是微前端？

微前端是一种将**前端应用分解为多个独立的、可独立开发和部署的小型应用**的架构风格，这些小应用最终组合成一个完整的应用。

**核心思想：**
- **技术栈无关**：不同子应用可以使用不同的技术栈（React、Vue、Angular）
- **独立开发部署**：各团队独立开发、测试、部署
- **增量升级**：可以逐步迁移老项目，而不是一次性重写
- **运行时集成**：在浏览器中动态加载和卸载子应用

### 1.2 为什么需要微前端？

**业务场景：**
- 大型单体应用难以维护，构建时间长
- 多团队协作，技术栈不统一
- 老项目需要逐步重构，不能停止业务
- 不同业务模块需要独立发版

**解决的问题：**
- 代码库过大，开发效率低
- 技术债务难以偿还
- 团队协作冲突多
- 部署风险高

---

## 二、主流微前端方案对比

### 2.1 iframe 方案

**原理：** 最简单的微前端方案，通过 iframe 加载子应用

**优点：**
- 天然隔离（样式、JS、全局变量）
- 实现简单

**缺点：**
- URL 不同步（浏览器前进后退问题）
- 性能差（每个 iframe 都是独立的浏览器上下文）
- 通信复杂（postMessage）
- 弹窗、遮罩层等 UI 问题
- SEO 不友好

### 2.2 single-spa

**原理：** 微前端框架的鼻祖，提供应用注册、加载、卸载的生命周期管理

**核心概念：**
- 提供路由劫持和应用生命周期
- 子应用需要导出 `bootstrap`、`mount`、`unmount` 三个生命周期函数
- 不提供 JS 沙箱和样式隔离，需要自己实现

**特点：**
- 轻量级，只做应用调度
- 需要配合其他方案实现隔离

### 2.3 qiankun（阿里）

**原理：** 基于 single-spa 封装，提供了更完善的沙箱和样式隔离方案

**核心能力：**
- 基于 single-spa 的应用加载
- JS 沙箱（Proxy 沙箱、快照沙箱）
- 样式隔离（Shadow DOM、scoped CSS）
- 资源预加载
- 应用间通信

**特点：**
- 开箱即用，配置简单
- 生态完善，社区活跃
- 适合中大型项目

### 2.4 Webpack5 模块联邦（Module Federation）

**原理：** 通过 Webpack 构建时的能力，实现应用间的模块共享

**核心特点：**
- 构建时方案，不是运行时方案
- 可以共享代码和依赖
- 性能更好
- 需要 Webpack 5+

### 2.5 Web Components

**原理：** 使用浏览器原生的 Web Components 标准

**特点：**
- 原生支持，无需框架
- 天然隔离（Shadow DOM）
- 兼容性问题

---

## 三、qiankun 实现原理深度解析

### 3.1 整体架构

qiankun 的核心是**应用加载 + 沙箱隔离 + 样式隔离**

```
主应用
  ├── 注册子应用（registerMicroApps）
  ├── 启动 qiankun（start）
  └── 监听路由变化
       ├── 匹配子应用
       ├── 加载子应用资源（HTML、JS、CSS）
       ├── 创建沙箱环境
       ├── 渲染子应用
       └── 卸载时清理
```

### 3.2 应用加载流程

**核心步骤：**

1. **注册阶段**
   - 主应用调用 `registerMicroApps` 注册子应用配置
   - 配置包括：name、entry、container、activeRule

2. **路由监听**
   - qiankun 劫持 `pushState`、`replaceState`、`hashchange` 等事件
   - 当路由变化时，判断是否需要加载/卸载子应用

3. **资源加载**
   - 通过 `fetch` 获取子应用的 HTML
   - 解析 HTML，提取 JS、CSS 资源
   - 加载并执行 JS 文件

4. **沙箱创建**
   - 为子应用创建独立的 JS 沙箱
   - 拦截全局变量的读写

5. **挂载应用**
   - 调用子应用的 `mount` 生命周期
   - 将子应用渲染到指定容器

**关键代码理解：**

```javascript
// 主应用注册子应用
registerMicroApps([
  {
    name: 'app1',
    entry: '//localhost:8080',  // 子应用地址
    container: '#subapp',        // 渲染容器
    activeRule: '/app1',         // 激活路由
  }
]);

// 启动 qiankun
start();
```

### 3.3 HTML Entry 原理

qiankun 使用 **HTML Entry** 而不是 JS Entry，这是它的一大特色。

**为什么用 HTML Entry？**
- 子应用可以独立运行（直接访问 HTML）
- 不需要额外配置入口文件
- 更接近传统的 Web 应用开发方式

**实现原理：**

```javascript
// 1. fetch 获取 HTML
const html = await fetch(entry).then(res => res.text());

// 2. 解析 HTML，提取资源
const { template, scripts, styles } = parseHTML(html);

// 3. 加载 JS 和 CSS
const jsCode = await Promise.all(scripts.map(src => fetch(src)));
const cssCode = await Promise.all(styles.map(href => fetch(href)));

// 4. 在沙箱中执行 JS
sandbox.execScripts(jsCode);
```

**核心逻辑：**
- 通过正则表达式解析 HTML 中的 `<script>` 和 `<link>` 标签
- 将外联资源转换为内联资源
- 在沙箱环境中执行

### 3.4 import-html-entry

qiankun 底层使用 `import-html-entry` 库来处理 HTML 解析和资源加载。

**核心功能：**
- 解析 HTML 字符串
- 提取 JS、CSS 资源
- 处理资源加载顺序
- 支持 `<script type="module">`

---

## 四、样式隔离方案

样式隔离是微前端的核心问题之一，qiankun 提供了多种方案。

### 4.1 为什么需要样式隔离？

**问题场景：**
- 主应用和子应用的样式互相污染
- 多个子应用之间的样式冲突
- 全局样式（body、html）被覆盖

### 4.2 strictStyleIsolation（严格样式隔离）

**原理：** 使用 **Shadow DOM** 实现完全隔离

```javascript
start({
  sandbox: {
    strictStyleIsolation: true  // 开启严格样式隔离
  }
});
```

**Shadow DOM 原理：**
- 为子应用的容器创建 Shadow Root
- 子应用的样式只在 Shadow DOM 内生效
- 完全隔离，主应用样式无法影响子应用

**优点：**
- 完全隔离，不会有样式冲突

**缺点：**
- 弹窗、tooltip 等挂载到 body 的元素样式会丢失
- 第三方 UI 库可能不兼容
- 调试困难

**实现理解：**

```javascript
// qiankun 内部实现
const shadowRoot = container.attachShadow({ mode: 'open' });
shadowRoot.innerHTML = subAppHTML;
```

### 4.3 experimentalStyleIsolation（实验性样式隔离）

**原理：** 使用 **CSS Scoped** 方案，为子应用的样式添加特殊前缀

```javascript
start({
  sandbox: {
    experimentalStyleIsolation: true
  }
});
```

**实现原理：**
- 动态改写子应用的 CSS 选择器
- 为每个选择器添加特定的属性选择器

**转换示例：**

```css
/* 原始样式 */
.button { color: red; }

/* 转换后 */
div[data-qiankun="app1"] .button { color: red; }
```

**优点：**
- 不影响弹窗等元素
- 兼容性好

**缺点：**
- 不是完全隔离
- 权重可能被覆盖

### 4.4 手动样式隔离方案

**方案一：CSS Modules**
- 构建时生成唯一的类名
- 适合新项目

**方案二：CSS-in-JS**
- 样式写在 JS 中，动态生成
- 天然隔离

**方案三：约定式命名**
- 为每个子应用添加统一前缀
- 如：`.app1-button`、`.app2-button`

**方案四：动态样式加载/卸载**
- 子应用挂载时加载样式
- 卸载时移除样式标签

```javascript
// 子应用生命周期
export async function mount(props) {
  // 加载样式
  const style = document.createElement('link');
  style.href = '/app1.css';
  style.setAttribute('data-app', 'app1');
  document.head.appendChild(style);
}

export async function unmount() {
  // 移除样式
  const styles = document.querySelectorAll('[data-app="app1"]');
  styles.forEach(style => style.remove());
}
```

---

## 五、JavaScript 沙箱机制

JS 沙箱是微前端的核心技术，用于隔离子应用的全局变量，防止污染。

### 5.1 为什么需要 JS 沙箱？

**问题场景：**
- 子应用修改了 `window` 对象（如 `window.name`）
- 多个子应用使用同一个全局变量
- 子应用卸载后，全局变量没有清理

### 5.2 快照沙箱（SnapshotSandbox）

**适用场景：** 单个子应用，不支持多实例

**原理：** 在应用激活时记录 `window` 快照，卸载时恢复

**实现思路：**

```javascript
class SnapshotSandbox {
  constructor() {
    this.windowSnapshot = {};
    this.modifyPropsMap = {};
  }

  // 激活沙箱
  active() {
    // 1. 保存当前 window 状态
    for (const prop in window) {
      this.windowSnapshot[prop] = window[prop];
    }

    // 2. 恢复上次的修改
    Object.keys(this.modifyPropsMap).forEach(prop => {
      window[prop] = this.modifyPropsMap[prop];
    });
  }

  // 失活沙箱
  inactive() {
    // 1. 记录修改了哪些属性
    for (const prop in window) {
      if (window[prop] !== this.windowSnapshot[prop]) {
        this.modifyPropsMap[prop] = window[prop];
        // 2. 恢复原始值
        window[prop] = this.windowSnapshot[prop];
      }
    }
  }
}
```

**核心思想：**
- 激活时：保存快照 + 恢复上次修改
- 失活时：记录修改 + 恢复快照

**优点：**
- 实现简单
- 兼容性好（不需要 Proxy）

**缺点：**
- 性能差（需要遍历 window）
- 不支持多实例

### 5.3 Proxy 沙箱（ProxySandbox）

**适用场景：** 支持多个子应用同时运行

**原理：** 使用 ES6 Proxy 代理 `window` 对象，拦截属性的读写

**实现思路：**

```javascript
class ProxySandbox {
  constructor() {
    this.fakeWindow = {};  // 假的 window 对象
    this.proxyWindow = null;

    this.proxyWindow = new Proxy(this.fakeWindow, {
      get: (target, prop) => {
        // 优先从 fakeWindow 读取
        if (prop in target) {
          return target[prop];
        }
        // 否则从真实 window 读取
        return window[prop];
      },

      set: (target, prop, value) => {
        // 所有修改都记录到 fakeWindow
        target[prop] = value;
        return true;
      }
    });
  }

  active() {
    // 激活时，子应用使用 proxyWindow
  }

  inactive() {
    // 失活时，fakeWindow 保留，不影响 window
  }
}
```

**核心思想：**
- 为每个子应用创建一个 `fakeWindow`
- 子应用的所有全局变量操作都在 `fakeWindow` 上
- 不会污染真实的 `window`

**优点：**
- 支持多实例
- 性能好（不需要遍历）
- 隔离彻底

**缺点：**
- 不兼容 IE（需要 Proxy 支持）

### 5.4 LegacyProxySandbox（遗留 Proxy 沙箱）

**适用场景：** 单实例，但使用 Proxy 实现

**原理：** 直接代理 `window`，记录修改，卸载时恢复

```javascript
class LegacySandbox {
  constructor() {
    this.addedPropsMap = {};     // 新增的属性
    this.modifiedPropsMap = {};  // 修改的属性
    this.currentPropsMap = {};   // 当前的属性值

    const { addedPropsMap, modifiedPropsMap, currentPropsMap } = this;

    this.proxyWindow = new Proxy(window, {
      get(target, prop) {
        return target[prop];
      },

      set(target, prop, value) {
        if (!target.hasOwnProperty(prop)) {
          // 新增属性
          addedPropsMap[prop] = value;
        } else if (!modifiedPropsMap.hasOwnProperty(prop)) {
          // 第一次修改，记录原始值
          modifiedPropsMap[prop] = target[prop];
        }

        currentPropsMap[prop] = value;
        target[prop] = value;
        return true;
      }
    });
  }

  active() {
    // 恢复修改
    Object.keys(this.currentPropsMap).forEach(prop => {
      window[prop] = this.currentPropsMap[prop];
    });
  }

  inactive() {
    // 删除新增的属性
    Object.keys(this.addedPropsMap).forEach(prop => {
      delete window[prop];
    });

    // 恢复修改的属性
    Object.keys(this.modifiedPropsMap).forEach(prop => {
      window[prop] = this.modifiedPropsMap[prop];
    });
  }
}
```

### 5.5 沙箱对比总结

| 沙箱类型 | 多实例 | 性能 | 兼容性 | 隔离程度 |
|---------|--------|------|--------|---------|
| SnapshotSandbox | ❌ | 差 | 好 | 中 |
| LegacyProxySandbox | ❌ | 好 | 需要 Proxy | 中 |
| ProxySandbox | ✅ | 好 | 需要 Proxy | 高 |

### 5.6 沙箱的局限性

**无法隔离的场景：**
- DOM 操作（如 `document.body.appendChild`）
- 事件监听（如 `window.addEventListener`）
- 定时器（如 `setTimeout`、`setInterval`）
- 网络请求（如 `fetch`、`XMLHttpRequest`）

**解决方案：**
- 在子应用卸载时手动清理
- 使用 qiankun 提供的生命周期钩子

---

## 六、应用间通信

### 6.1 通信方式

**1. Props 传递（推荐）**

```javascript
// 主应用
registerMicroApps([
  {
    name: 'app1',
    entry: '//localhost:8080',
    container: '#subapp',
    activeRule: '/app1',
    props: {
      data: { user: 'admin' },
      onGlobalStateChange: () => {},
    }
  }
]);

// 子应用
export async function mount(props) {
  console.log(props.data);  // { user: 'admin' }
}
```

**2. 全局状态管理（initGlobalState）**

```javascript
// 主应用
import { initGlobalState } from 'qiankun';

const actions = initGlobalState({ user: 'admin' });

actions.onGlobalStateChange((state, prev) => {
  console.log('主应用监听到变化', state);
});

actions.setGlobalState({ user: 'new user' });

// 子应用
export async function mount(props) {
  props.onGlobalStateChange((state, prev) => {
    console.log('子应用监听到变化', state);
  });

  props.setGlobalState({ user: 'from sub app' });
}
```

**3. 自定义事件（CustomEvent）**

```javascript
// 发送事件
window.dispatchEvent(new CustomEvent('app1-event', {
  detail: { data: 'hello' }
}));

// 监听事件
window.addEventListener('app1-event', (e) => {
  console.log(e.detail.data);
});
```

**4. 共享状态库（Redux、Mobx）**

- 主应用创建 store
- 通过 props 传递给子应用
- 子应用使用同一个 store

### 6.2 通信方案对比

| 方案 | 适用场景 | 优点 | 缺点 |
|-----|---------|------|------|
| Props | 简单数据传递 | 简单直接 | 只能主→子 |
| GlobalState | 全局状态共享 | 双向通信 | 状态管理复杂 |
| CustomEvent | 事件通知 | 解耦 | 需要手动清理 |
| 共享 Store | 复杂状态管理 | 统一管理 | 耦合度高 |

---

## 七、Webpack5 模块联邦

### 7.1 什么是模块联邦（Module Federation）？

模块联邦是 Webpack 5 引入的新特性，允许**多个独立的构建可以在运行时共享代码和依赖**。

**核心概念：**
- **Host（宿主应用）**：消费其他应用的模块
- **Remote（远程应用）**：提供模块给其他应用使用
- **Shared（共享依赖）**：多个应用共享的依赖（如 React、Vue）

### 7.2 为什么需要模块联邦？

**传统微前端的问题：**
- 每个子应用都打包了 React/Vue，重复加载
- 子应用之间无法共享代码
- 需要运行时加载整个应用

**模块联邦的优势：**
- **依赖共享**：多个应用共享同一份 React
- **按需加载**：只加载需要的模块
- **版本管理**：自动处理依赖版本冲突
- **构建时优化**：比运行时方案性能更好

### 7.3 模块联邦配置

**应用 A（Remote）：提供模块**

```javascript
// webpack.config.js
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'app1',  // 应用名称
      filename: 'remoteEntry.js',  // 入口文件
      exposes: {
        // 暴露的模块
        './Button': './src/components/Button',
        './utils': './src/utils',
      },
      shared: {
        // 共享的依赖
        react: { singleton: true },
        'react-dom': { singleton: true },
      },
    }),
  ],
};
```

**应用 B（Host）：消费模块**

```javascript
// webpack.config.js
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'app2',
      remotes: {
        // 远程应用
        app1: 'app1@http://localhost:3001/remoteEntry.js',
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
      },
    }),
  ],
};
```

**使用远程模块：**

```javascript
// 应用 B 中使用应用 A 的组件
import Button from 'app1/Button';

function App() {
  return <Button>Click me</Button>;
}
```

### 7.4 模块联邦实现原理

**核心流程：**

1. **构建阶段**
   - Remote 应用打包时，生成 `remoteEntry.js`
   - 这个文件包含了模块的元信息和加载逻辑

2. **运行时加载**
   - Host 应用启动时，加载 `remoteEntry.js`
   - 注册 Remote 应用的模块

3. **模块获取**
   - 当代码中 `import` 远程模块时
   - Webpack 通过 `remoteEntry.js` 动态加载对应的 chunk

4. **依赖共享**
   - 检查 shared 配置
   - 如果版本兼容，使用 Host 的依赖
   - 否则加载 Remote 的依赖

**关键概念理解：**

```javascript
// remoteEntry.js 的核心逻辑（简化版）
window.app1 = {
  get(module) {
    return () => {
      // 动态加载模块
      return import('./Button.chunk.js');
    };
  },
  init(shared) {
    // 初始化共享依赖
    this.shared = shared;
  }
};
```

### 7.5 Shared 共享依赖策略

**singleton（单例模式）**

```javascript
shared: {
  react: {
    singleton: true,  // 只加载一个版本
    requiredVersion: '^18.0.0',
  }
}
```

- 确保全局只有一个 React 实例
- 如果版本不兼容，会报错或警告

**eager（预加载）**

```javascript
shared: {
  react: {
    eager: true,  // 立即加载，不异步
  }
}
```

- 不使用异步加载
- 适合主应用的核心依赖

**strictVersion（严格版本）**

```javascript
shared: {
  react: {
    strictVersion: true,
    requiredVersion: '18.2.0',
  }
}
```

- 版本必须完全匹配
- 否则报错

### 7.6 模块联邦 vs qiankun

| 对比项 | 模块联邦 | qiankun |
|-------|---------|---------|
| 方案类型 | 构建时 | 运行时 |
| 技术栈 | 需要 Webpack 5 | 技术栈无关 |
| 依赖共享 | 自动共享 | 手动处理 |
| 粒度 | 模块级别 | 应用级别 |
| 性能 | 更好 | 较差 |
| 灵活性 | 较低 | 更高 |
| 独立运行 | 不支持 | 支持 |

**选择建议：**
- **模块联邦**：适合新项目，技术栈统一，追求性能
- **qiankun**：适合老项目改造，技术栈多样，需要独立部署

### 7.7 模块联邦最佳实践

**1. 版本管理**
- 使用 `singleton` 确保依赖唯一
- 明确 `requiredVersion` 范围

**2. 错误处理**
- 使用 `React.lazy` + `Suspense` 处理加载失败
- 提供降级方案

```javascript
const RemoteButton = React.lazy(() =>
  import('app1/Button').catch(() => {
    return { default: () => <div>加载失败</div> };
  })
);

function App() {
  return (
    <Suspense fallback={<div>加载中...</div>}>
      <RemoteButton />
    </Suspense>
  );
}
```

**3. 类型支持**
- 为远程模块提供 TypeScript 类型声明

```typescript
// app1/types.d.ts
declare module 'app1/Button' {
  export const Button: React.FC<{ children: React.ReactNode }>;
}
```

**4. 缓存策略**
- 合理设置 `remoteEntry.js` 的缓存
- 使用版本号或 hash

---

## 八、常见面试问题

### 8.1 基础概念类

**Q1: 什么是微前端？解决了什么问题？**

**答案要点：**
- 定义：将前端应用拆分为多个独立的小应用
- 解决的问题：
  - 大型应用难以维护
  - 技术栈不统一
  - 团队协作冲突
  - 增量升级困难

**Q2: 微前端和微服务的区别？**

**答案要点：**
- 微服务：后端架构，服务拆分
- 微前端：前端架构，应用拆分
- 相同点：都是为了解决单体应用的问题
- 不同点：
  - 微服务运行在不同进程
  - 微前端运行在同一个浏览器

**Q3: 微前端有哪些实现方案？**

**答案要点：**
- iframe：最简单，隔离好，但体验差
- single-spa：轻量级，需要自己实现隔离
- qiankun：基于 single-spa，提供沙箱和样式隔离
- 模块联邦：Webpack 5，构建时方案
- Web Components：浏览器原生

### 8.2 qiankun 原理类

**Q4: qiankun 是如何加载子应用的？**

**答案要点：**
1. 通过 fetch 获取子应用的 HTML
2. 解析 HTML，提取 JS、CSS 资源
3. 创建沙箱环境
4. 在沙箱中执行 JS
5. 调用子应用的 mount 生命周期
6. 渲染到指定容器

**Q5: qiankun 的 HTML Entry 和 JS Entry 有什么区别？**

**答案要点：**
- **JS Entry**：
  - 需要配置入口 JS 文件
  - 子应用不能独立运行
  - single-spa 使用
- **HTML Entry**：
  - 直接加载 HTML
  - 子应用可以独立运行
  - qiankun 使用
  - 更符合传统开发习惯

**Q6: qiankun 如何实现路由劫持？**

**答案要点：**
- 劫持 `pushState`、`replaceState`
- 监听 `popstate`、`hashchange` 事件
- 当路由变化时，匹配子应用的 `activeRule`
- 决定加载或卸载子应用

### 8.3 沙箱机制类

**Q7: qiankun 有哪些沙箱方案？各有什么特点？**

**答案要点：**
- **SnapshotSandbox**：
  - 快照方式
  - 不支持多实例
  - 兼容性好
- **LegacyProxySandbox**：
  - Proxy 代理 window
  - 不支持多实例
  - 需要 Proxy 支持
- **ProxySandbox**：
  - 为每个应用创建 fakeWindow
  - 支持多实例
  - 隔离最彻底

**Q8: Proxy 沙箱是如何实现的？**

**答案要点：**
1. 为每个子应用创建一个 `fakeWindow` 对象
2. 使用 Proxy 代理 `fakeWindow`
3. get 操作：优先从 `fakeWindow` 读，否则从 `window` 读
4. set 操作：所有修改都写入 `fakeWindow`
5. 子应用的全局变量操作都在 `fakeWindow` 上
6. 不会污染真实的 `window`

**Q9: 沙箱有哪些局限性？**

**答案要点：**
- 无法隔离 DOM 操作
- 无法隔离事件监听
- 无法隔离定时器
- 无法隔离网络请求
- 需要在卸载时手动清理

### 8.4 样式隔离类

**Q10: qiankun 有哪些样式隔离方案？**

**答案要点：**
- **strictStyleIsolation**：
  - 使用 Shadow DOM
  - 完全隔离
  - 弹窗等元素样式会丢失
- **experimentalStyleIsolation**：
  - 动态改写 CSS 选择器
  - 添加属性选择器前缀
  - 兼容性好
- **手动方案**：
  - CSS Modules
  - CSS-in-JS
  - 约定式命名
  - 动态加载/卸载

**Q11: Shadow DOM 的优缺点？**

**答案要点：**
- **优点**：
  - 完全隔离
  - 不会有样式冲突
- **缺点**：
  - 弹窗等挂载到 body 的元素样式会丢失
  - 第三方 UI 库可能不兼容
  - 调试困难
  - 需要浏览器支持

**Q12: 如何解决弹窗样式丢失问题？**

**答案要点：**
- 不使用 Shadow DOM
- 使用 experimentalStyleIsolation
- 手动将弹窗挂载到 Shadow DOM 内
- 使用 CSS-in-JS

### 8.5 应用通信类

**Q13: 微前端应用间如何通信？**

**答案要点：**
- Props 传递：主应用 → 子应用
- GlobalState：qiankun 提供的全局状态
- CustomEvent：自定义事件
- 共享 Store：Redux、Mobx
- LocalStorage：跨应用持久化

**Q14: qiankun 的 GlobalState 是如何实现的？**

**答案要点：**
- 发布订阅模式
- 主应用调用 `initGlobalState` 创建全局状态
- 通过 props 传递给子应用
- 子应用可以监听和修改状态
- 所有应用都会收到变化通知

### 8.6 模块联邦类

**Q15: 什么是 Webpack 模块联邦？**

**答案要点：**
- Webpack 5 的新特性
- 允许多个独立构建共享代码和依赖
- 构建时方案，不是运行时方案
- 核心概念：Host、Remote、Shared

**Q16: 模块联邦和 qiankun 的区别？**

**答案要点：**
- **模块联邦**：
  - 构建时方案
  - 需要 Webpack 5
  - 模块级别共享
  - 性能更好
  - 不支持独立运行
- **qiankun**：
  - 运行时方案
  - 技术栈无关
  - 应用级别加载
  - 支持独立运行
  - 更灵活

**Q17: 模块联邦的 shared 配置有什么作用？**

**答案要点：**
- 用于配置共享依赖
- `singleton`：确保只有一个实例
- `eager`：立即加载，不异步
- `requiredVersion`：指定版本范围
- `strictVersion`：严格版本匹配
- 避免重复加载依赖

**Q18: 模块联邦如何处理版本冲突？**

**答案要点：**
1. 检查 shared 配置的版本范围
2. 如果版本兼容，使用 Host 的依赖
3. 如果不兼容且 `singleton: true`，会警告或报错
4. 如果不兼容且没有 singleton，加载各自的版本
5. 可以通过 `requiredVersion` 控制版本范围

### 8.7 性能优化类

**Q19: 微前端有哪些性能问题？如何优化？**

**答案要点：**
- **问题**：
  - 子应用加载慢
  - 重复加载依赖
  - 首屏时间长
- **优化方案**：
  - 预加载：`prefetch`
  - 预渲染：提前渲染子应用
  - 依赖共享：externals 或模块联邦
  - 按需加载：路由懒加载
  - 缓存策略：合理设置 HTTP 缓存

**Q20: qiankun 的预加载是如何实现的？**

**答案要点：**
```javascript
start({
  prefetch: 'all',  // 预加载所有子应用
  // prefetch: true,  // 空闲时预加载
  // prefetch: ['app1', 'app2'],  // 指定预加载
});
```
- 在浏览器空闲时（requestIdleCallback）
- 提前 fetch 子应用的资源
- 缓存到内存中
- 真正加载时直接使用缓存

### 8.8 实战问题类

**Q21: 子应用如何判断是否在微前端环境中运行？**

**答案要点：**
```javascript
// 方式一：通过 window 上的标识
if (window.__POWERED_BY_QIANKUN__) {
  // 在 qiankun 中运行
}

// 方式二：通过生命周期
export async function mount(props) {
  // 如果有 props，说明在微前端环境
  if (props) {
    // 微前端环境
  } else {
    // 独立运行
  }
}
```

**Q22: 如何处理子应用的公共路径问题？**

**答案要点：**
```javascript
// webpack 配置
if (window.__POWERED_BY_QIANKUN__) {
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
}

// 或在 webpack.config.js 中
module.exports = {
  output: {
    publicPath: process.env.NODE_ENV === 'production'
      ? 'https://cdn.com/app1/'
      : '/',
  },
};
```

**Q23: 如何处理子应用的环境变量？**

**答案要点：**
- 通过 props 传递
- 通过 GlobalState 共享
- 子应用独立配置
- 使用 `.env` 文件

**Q24: 微前端项目如何调试？**

**答案要点：**
- 使用浏览器 DevTools
- 子应用独立运行调试
- 使用 `console.log` 区分应用
- 关闭沙箱和样式隔离
- 使用 Source Map

**Q25: 如何处理子应用的错误边界？**

**答案要点：**
```javascript
// 主应用
start({
  errorHandler: (error) => {
    console.error('子应用加载失败', error);
    // 显示错误页面
  },
});

// 子应用（React）
class ErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    console.error('子应用运行错误', error);
  }

  render() {
    if (this.state.hasError) {
      return <div>出错了</div>;
    }
    return this.props.children;
  }
}
```

---

## 九、总结

### 9.1 微前端核心要点

1. **应用加载**：HTML Entry、资源解析、生命周期管理
2. **JS 隔离**：快照沙箱、Proxy 沙箱、多实例支持
3. **样式隔离**：Shadow DOM、CSS Scoped、手动方案
4. **应用通信**：Props、GlobalState、事件、共享 Store
5. **性能优化**：预加载、依赖共享、缓存策略

### 9.2 qiankun vs 模块联邦

- **qiankun**：运行时方案，灵活，适合老项目改造
- **模块联邦**：构建时方案，性能好，适合新项目

### 9.3 技术选型建议

**选择 qiankun 的场景：**
- 技术栈多样（React + Vue + Angular）
- 需要独立部署
- 老项目改造
- 不想改动构建配置

**选择模块联邦的场景：**
- 技术栈统一（都是 React 或 Vue）
- 使用 Webpack 5
- 追求性能
- 新项目

**选择 iframe 的场景：**
- 极简场景
- 对性能要求不高
- 需要完全隔离

### 9.4 面试准备建议

1. **理解核心原理**：不要死记硬背，理解为什么这样设计
2. **动手实践**：搭建一个简单的微前端项目
3. **对比方案**：理解不同方案的优缺点和适用场景
4. **关注细节**：沙箱、样式隔离的实现细节
5. **实战经验**：遇到的问题和解决方案

---

## 十、参考资料

- [qiankun 官方文档](https://qiankun.umijs.org/)
- [single-spa 官方文档](https://single-spa.js.org/)
- [Webpack Module Federation](https://webpack.js.org/concepts/module-federation/)
- [微前端的核心价值](https://micro-frontends.org/)

---

**文档版本：** v1.0
**最后更新：** 2025-12-20

