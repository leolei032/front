# 前端性能优化全面方案

> 基于雅虎军规、WebPageTest、Lighthouse、Google Performance 最佳实践

## 目录

- [一、性能指标体系](#一性能指标体系)
- [二、网络层优化](#二网络层优化)
- [三、资源加载优化](#三资源加载优化)
- [四、图片优化](#四图片优化)
- [五、JavaScript 优化](#五javascript-优化)
- [六、CSS 优化](#六css-优化)
- [七、渲染性能优化](#七渲染性能优化)
- [八、缓存策略](#八缓存策略)
- [九、构建优化](#九构建优化)
- [十、监控与分析](#十监控与分析)

---

## 一、性能指标体系

### 1.1 核心 Web Vitals（Google 官方指标）

#### LCP (Largest Contentful Paint) - 最大内容绘制
- **定义**: 页面主要内容加载完成的时间
- **目标**: < 2.5s (优秀), < 4s (需改进), > 4s (差)
- **优化重点**:
  - 服务器响应时间
  - 资源加载时间
  - 客户端渲染时间

#### FID (First Input Delay) - 首次输入延迟
- **定义**: 用户首次交互到浏览器响应的时间
- **目标**: < 100ms (优秀), < 300ms (需改进), > 300ms (差)
- **优化重点**:
  - 减少 JavaScript 执行时间
  - 代码分割
  - 延迟加载非关键资源

#### CLS (Cumulative Layout Shift) - 累积布局偏移
- **定义**: 页面视觉稳定性，防止元素意外移动
- **目标**: < 0.1 (优秀), < 0.25 (需改进), > 0.25 (差)
- **优化重点**:
  - 为图片和视频设置尺寸
  - 避免在现有内容上方插入内容
  - 使用 transform 动画

### 1.2 其他重要指标

#### FCP (First Contentful Paint) - 首次内容绘制
- **定义**: 首次渲染任何文本、图像的时间
- **目标**: < 1.8s (优秀)
- **影响因素**: HTML 加载、CSS 解析、字体加载

#### TTI (Time to Interactive) - 可交互时间
- **定义**: 页面完全可交互的时间
- **目标**: < 3.8s (优秀)
- **影响因素**: JavaScript 执行、主线程空闲

#### TBT (Total Blocking Time) - 总阻塞时间
- **定义**: FCP 到 TTI 之间主线程被阻塞的总时间
- **目标**: < 200ms (优秀)
- **影响因素**: 长任务（> 50ms）

#### Speed Index - 速度指数
- **定义**: 页面内容可见填充的速度
- **目标**: < 3.4s (优秀)
- **测量工具**: Lighthouse, WebPageTest

---

## 二、网络层优化

### 2.1 DNS 优化

#### DNS 预解析
```html
<!-- 对即将访问的域名进行 DNS 预解析 -->
<link rel="dns-prefetch" href="//api.example.com">
<link rel="dns-prefetch" href="//cdn.example.com">
<link rel="dns-prefetch" href="//analytics.example.com">
```

**适用场景**:
- 第三方资源域名
- API 接口域名
- CDN 域名

**注意事项**:
- 不要预解析过多域名（建议 < 6 个）
- 对于 HTTPS，使用 `preconnect` 更好

#### DNS 预连接
```html
<!-- 提前建立连接（DNS + TCP + TLS） -->
<link rel="preconnect" href="https://api.example.com">
<link rel="preconnect" href="https://cdn.example.com" crossorigin>
```

**优势**:
- 包含 DNS 解析 + TCP 握手 + TLS 协商
- 减少关键资源的连接延迟

### 2.2 HTTP 协议优化

#### 启用 HTTP/2
**优势**:
- 多路复用：单个连接并行处理多个请求
- 头部压缩：减少请求头大小
- 服务器推送：主动推送资源
- 二进制分帧：更高效的传输

**配置示例** (Nginx):
```nginx
server {
    listen 443 ssl http2;
    server_name example.com;

    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;

    # HTTP/2 推送
    location / {
        http2_push /css/critical.css;
        http2_push /js/main.js;
    }
}
```

#### 启用 HTTP/3 (QUIC)
**优势**:
- 基于 UDP，减少连接建立时间
- 更好的弱网性能
- 连接迁移（网络切换不断连）

### 2.3 减少 HTTP 请求

#### 雅虎军规第一条：减少 HTTP 请求数量

**策略**:

1. **合并文件**
   - CSS 文件合并
   - JavaScript 文件合并（注意 HTTP/2 下可适当拆分）
   - 雪碧图（CSS Sprites）

2. **内联关键资源**
```html
<!-- 内联关键 CSS -->
<style>
  /* 首屏关键样式 */
  .header { ... }
  .hero { ... }
</style>

<!-- 内联小图片 -->
<img src="data:image/svg+xml;base64,..." alt="icon">
```

3. **使用字体图标**
   - 替代小图标
   - 减少图片请求

4. **懒加载非关键资源**
   - 图片懒加载
   - 组件懒加载
   - 路由懒加载

### 2.4 压缩传输

#### Gzip / Brotli 压缩

**Nginx 配置**:
```nginx
# Gzip 压缩
gzip on;
gzip_vary on;
gzip_min_length 1024;
gzip_comp_level 6;
gzip_types
    text/plain
    text/css
    text/xml
    text/javascript
    application/json
    application/javascript
    application/xml+rss
    application/rss+xml
    font/truetype
    font/opentype
    application/vnd.ms-fontobject
    image/svg+xml;

# Brotli 压缩（更高压缩率）
brotli on;
brotli_comp_level 6;
brotli_types
    text/plain
    text/css
    text/xml
    text/javascript
    application/json
    application/javascript
    application/xml+rss
    image/svg+xml;
```

**压缩效果对比**:
| 文件类型 | 原始大小 | Gzip | Brotli |
|---------|---------|------|--------|
| HTML    | 100KB   | ~30KB | ~25KB |
| CSS     | 100KB   | ~20KB | ~17KB |
| JS      | 100KB   | ~35KB | ~30KB |

### 2.5 CDN 加速

#### CDN 使用策略

**资源分类**:
```
静态资源 CDN：
├── 图片资源: images.cdn.example.com
├── JS/CSS:   static.cdn.example.com
├── 字体文件: fonts.cdn.example.com
└── 视频资源: video.cdn.example.com
```

**最佳实践**:
1. 使用多个 CDN 域名（突破浏览器并发限制，但 HTTP/2 下不推荐）
2. 启用 CDN 的智能压缩
3. 配置合理的缓存策略
4. 使用 CDN 的图片处理服务

---

## 三、资源加载优化

### 3.1 资源优先级控制

#### Preload - 预加载关键资源
```html
<!-- 预加载关键 CSS -->
<link rel="preload" href="/css/critical.css" as="style">

<!-- 预加载关键字体 -->
<link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>

<!-- 预加载关键 JS -->
<link rel="preload" href="/js/main.js" as="script">

<!-- 预加载关键图片 -->
<link rel="preload" href="/images/hero.webp" as="image">

<!-- 预加载视频 -->
<link rel="preload" href="/video/intro.mp4" as="video">
```

**使用场景**:
- 首屏关键资源
- 字体文件（避免 FOIT/FOUT）
- 异步加载但需要提前下载的资源

#### Prefetch - 预获取未来资源
```html
<!-- 预获取下一页可能用到的资源 -->
<link rel="prefetch" href="/page2.html">
<link rel="prefetch" href="/js/page2.js">
<link rel="prefetch" href="/images/page2-hero.webp">
```

**使用场景**:
- 用户可能访问的下一页
- 路由预加载
- 低优先级资源

#### Prerender - 预渲染页面
```html
<!-- 预渲染下一页（谨慎使用） -->
<link rel="prerender" href="/next-page.html">
```

**注意事项**:
- 会消耗大量资源
- 仅用于高概率访问的页面

### 3.2 消除阻塞渲染的资源

#### CSS 优化

**关键 CSS 内联**:
```html
<!DOCTYPE html>
<html>
<head>
  <!-- 内联首屏关键 CSS -->
  <style>
    /* Critical CSS - 首屏样式 */
    body { margin: 0; font-family: sans-serif; }
    .header { height: 60px; background: #fff; }
    .hero { height: 400px; }
  </style>

  <!-- 异步加载非关键 CSS -->
  <link rel="preload" href="/css/main.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="/css/main.css"></noscript>
</head>
```

**CSS 媒体查询**:
```html
<!-- 仅在打印时阻塞渲染 -->
<link rel="stylesheet" href="print.css" media="print">

<!-- 仅在大屏时阻塞渲染 -->
<link rel="stylesheet" href="desktop.css" media="(min-width: 1024px)">
```

#### JavaScript 优化

**Script 标签属性**:
```html
<!-- 阻塞解析（默认行为，避免使用） -->
<script src="/js/blocking.js"></script>

<!-- defer: 异步下载，HTML 解析完后按顺序执行 -->
<script defer src="/js/main.js"></script>
<script defer src="/js/utils.js"></script>

<!-- async: 异步下载，下载完立即执行（无顺序保证） -->
<script async src="/js/analytics.js"></script>

<!-- type="module": 默认 defer 行为 -->
<script type="module" src="/js/app.js"></script>
```

**最佳实践**:
- 关键脚本放在 `<head>` 中使用 `defer`
- 第三方脚本使用 `async`
- 非关键脚本放在 `</body>` 前
- 使用动态导入延迟加载

### 3.3 代码分割（Code Splitting）

#### 路由级别分割
```javascript
// React Router 懒加载
import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Products = lazy(() => import('./pages/Products'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/products" element={<Products />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

#### 组件级别分割
```javascript
// React 组件懒加载
import { lazy, Suspense } from 'react';

const HeavyComponent = lazy(() => import('./HeavyComponent'));

function MyComponent() {
  return (
    <div>
      <h1>My Page</h1>
      <Suspense fallback={<div>Loading component...</div>}>
        <HeavyComponent />
      </Suspense>
    </div>
  );
}
```

#### 第三方库分割
```javascript
// Webpack 配置
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        // 提取 node_modules 中的代码
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10,
        },
        // 提取公共代码
        common: {
          minChunks: 2,
          priority: 5,
          reuseExistingChunk: true,
        },
        // 单独提取大型库
        react: {
          test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/,
          name: 'react',
          priority: 20,
        },
        lodash: {
          test: /[\\/]node_modules[\\/]lodash[\\/]/,
          name: 'lodash',
          priority: 20,
        },
      },
    },
  },
};
```

#### Vite 代码分割
```javascript
// vite.config.js
export default {
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'react-vendor': ['react', 'react-dom'],
          'router': ['react-router-dom'],
          'ui-lib': ['antd', '@ant-design/icons'],
          'utils': ['lodash-es', 'dayjs'],
        },
      },
    },
  },
};
```

### 3.4 Tree Shaking

#### ES6 模块化
```javascript
// ❌ 错误：导入整个库
import _ from 'lodash';
_.debounce(fn, 300);

// ✅ 正确：按需导入
import debounce from 'lodash-es/debounce';
debounce(fn, 300);

// ✅ 更好：使用支持 Tree Shaking 的库
import { debounce } from 'lodash-es';
```

#### 配置 sideEffects
```json
// package.json
{
  "name": "my-library",
  "sideEffects": false,  // 所有代码无副作用
  // 或指定有副作用的文件
  "sideEffects": [
    "*.css",
    "*.scss",
    "./src/polyfills.js"
  ]
}
```

---

## 四、图片优化

### 4.1 图片格式选择

#### 格式对比

| 格式 | 特点 | 适用场景 | 浏览器支持 |
|-----|------|---------|-----------|
| **WebP** | 体积小 30-50%，支持透明和动画 | 通用场景 | 现代浏览器 95%+ |
| **AVIF** | 体积更小，质量更好 | 追求极致性能 | Chrome 85+, Firefox 93+ |
| **JPEG** | 有损压缩，适合照片 | 照片、复杂图像 | 所有浏览器 |
| **PNG** | 无损压缩，支持透明 | Logo、图标、需要透明 | 所有浏览器 |
| **SVG** | 矢量图，无限缩放 | 图标、简单图形 | 所有现代浏览器 |
| **GIF** | 支持动画，体积大 | 简单动画（建议用视频替代） | 所有浏览器 |

#### 响应式图片
```html
<!-- Picture 标签：根据浏览器支持选择格式 -->
<picture>
  <!-- AVIF 格式（最优） -->
  <source srcset="image.avif" type="image/avif">
  <!-- WebP 格式（次优） -->
  <source srcset="image.webp" type="image/webp">
  <!-- JPEG 降级 -->
  <img src="image.jpg" alt="描述" loading="lazy">
</picture>

<!-- 响应式尺寸 -->
<picture>
  <source media="(min-width: 1024px)" srcset="large.webp">
  <source media="(min-width: 768px)" srcset="medium.webp">
  <img src="small.webp" alt="描述" loading="lazy">
</picture>

<!-- srcset 和 sizes -->
<img
  srcset="small.jpg 480w, medium.jpg 800w, large.jpg 1200w"
  sizes="(max-width: 600px) 480px, (max-width: 1000px) 800px, 1200px"
  src="medium.jpg"
  alt="描述"
  loading="lazy"
>
```

### 4.2 图片压缩

#### 有损压缩
- **JPEG**: 质量设置 75-85（平衡质量和体积）
- **WebP**: 质量设置 75-90
- **工具**: ImageOptim, TinyPNG, Squoosh

#### 无损压缩
- **PNG**: 使用 OptiPNG, PNGQuant
- **工具**: ImageOptim, ImageMagick

#### 自动化压缩
```javascript
// Webpack - image-webpack-loader
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpe?g|gif|svg)$/i,
        use: [
          {
            loader: 'file-loader',
          },
          {
            loader: 'image-webpack-loader',
            options: {
              mozjpeg: { progressive: true, quality: 80 },
              optipng: { enabled: true },
              pngquant: { quality: [0.65, 0.90], speed: 4 },
              gifsicle: { interlaced: false },
              webp: { quality: 80 },
            },
          },
        ],
      },
    ],
  },
};
```

```javascript
// Vite - vite-plugin-imagemin
import viteImagemin from 'vite-plugin-imagemin';

export default {
  plugins: [
    viteImagemin({
      gifsicle: { optimizationLevel: 7 },
      optipng: { optimizationLevel: 7 },
      mozjpeg: { quality: 80 },
      pngquant: { quality: [0.8, 0.9], speed: 4 },
      svgo: {
        plugins: [
          { name: 'removeViewBox', active: false },
          { name: 'removeEmptyAttrs', active: true },
        ],
      },
    }),
  ],
};
```

### 4.3 图片懒加载

#### 原生懒加载
```html
<!-- 浏览器原生支持 -->
<img src="image.jpg" alt="描述" loading="lazy">

<!-- 配合占位符 -->
<img
  src="placeholder.jpg"
  data-src="real-image.jpg"
  alt="描述"
  loading="lazy"
>
```

#### Intersection Observer 懒加载
```javascript
// 高性能懒加载实现
const imageObserver = new IntersectionObserver(
  (entries, observer) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        const src = img.getAttribute('data-src');

        // 加载图片
        img.src = src;
        img.removeAttribute('data-src');

        // 停止观察
        observer.unobserve(img);
      }
    });
  },
  {
    // 提前 200px 开始加载
    rootMargin: '200px',
    threshold: 0.01,
  }
);

// 观察所有懒加载图片
document.querySelectorAll('img[data-src]').forEach(img => {
  imageObserver.observe(img);
});
```

#### React 懒加载组件
```javascript
import { useEffect, useRef, useState } from 'react';

function LazyImage({ src, alt, placeholder }) {
  const [imageSrc, setImageSrc] = useState(placeholder);
  const [isLoaded, setIsLoaded] = useState(false);
  const imgRef = useRef();

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setImageSrc(src);
          observer.disconnect();
        }
      },
      { rootMargin: '200px' }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => observer.disconnect();
  }, [src]);

  return (
    <img
      ref={imgRef}
      src={imageSrc}
      alt={alt}
      onLoad={() => setIsLoaded(true)}
      style={{
        opacity: isLoaded ? 1 : 0.5,
        transition: 'opacity 0.3s',
      }}
    />
  );
}
```

### 4.4 图片尺寸优化

#### 设置明确的宽高
```html
<!-- ✅ 正确：设置宽高，避免 CLS -->
<img src="image.jpg" alt="描述" width="800" height="600" loading="lazy">

<!-- ✅ 使用 aspect-ratio -->
<img
  src="image.jpg"
  alt="描述"
  style="width: 100%; aspect-ratio: 16/9;"
  loading="lazy"
>
```

```css
/* CSS 设置宽高比 */
.image-container {
  position: relative;
  width: 100%;
  aspect-ratio: 16 / 9;
}

.image-container img {
  position: absolute;
  width: 100%;
  height: 100%;
  object-fit: cover;
}
```

#### 避免图片 src 为空
```html
<!-- ❌ 错误：空 src 会导致额外请求 -->
<img src="" alt="描述">

<!-- ✅ 正确：使用占位符或不渲染 -->
<img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'/%3E" alt="描述">
```

### 4.5 图片 CDN 处理

#### URL 参数处理
```javascript
// 图片 CDN 实时处理
const getOptimizedImage = (url, options = {}) => {
  const { width, height, quality = 80, format = 'webp' } = options;

  const params = new URLSearchParams();
  if (width) params.append('w', width);
  if (height) params.append('h', height);
  params.append('q', quality);
  params.append('format', format);

  return `${url}?${params.toString()}`;
};

// 使用示例
const imageUrl = getOptimizedImage('https://cdn.example.com/image.jpg', {
  width: 800,
  quality: 80,
  format: 'webp',
});
```

#### 响应式图片 CDN
```javascript
// 根据设备像素比和屏幕尺寸生成图片
const getResponsiveImage = (url, containerWidth) => {
  const dpr = window.devicePixelRatio || 1;
  const width = Math.ceil(containerWidth * dpr);

  return getOptimizedImage(url, {
    width,
    quality: dpr > 1 ? 75 : 80, // 高 DPR 设备可降低质量
    format: 'webp',
  });
};
```

### 4.6 Base64 内联

#### 小图片内联
```css
/* 小于 2KB 的图片可以内联 */
.icon {
  background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0i...');
}
```

```javascript
// Webpack URL Loader
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpg|gif)$/i,
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 2048, // 小于 2KB 内联
              fallback: 'file-loader',
            },
          },
        ],
      },
    ],
  },
};
```

**注意事项**:
- 仅内联小图片（< 2KB）
- Base64 会增加 33% 体积
- 内联图片无法被单独缓存

---

## 五、JavaScript 优化

### 5.1 减少 JavaScript 执行时间

#### 代码分割和懒加载
```javascript
// 动态导入
const loadModule = async () => {
  const module = await import('./heavy-module.js');
  module.init();
};

// 条件加载
if (condition) {
  import('./feature.js').then(module => {
    module.initialize();
  });
}

// 路由懒加载
const routes = [
  {
    path: '/dashboard',
    component: () => import('./Dashboard.vue'),
  },
];
```

#### 长任务拆分
```javascript
// ❌ 错误：长任务阻塞主线程
function processLargeArray(items) {
  items.forEach(item => {
    // 耗时操作
    heavyComputation(item);
  });
}

// ✅ 正确：使用 requestIdleCallback 拆分任务
function processLargeArray(items) {
  const chunks = chunkArray(items, 100);

  function processChunk(index) {
    if (index >= chunks.length) return;

    requestIdleCallback((deadline) => {
      while (deadline.timeRemaining() > 0 && index < chunks.length) {
        const chunk = chunks[index];
        chunk.forEach(item => heavyComputation(item));
        index++;
      }

      if (index < chunks.length) {
        processChunk(index);
      }
    });
  }

  processChunk(0);
}

// ✅ 使用 Scheduler API（实验性）
function* processItems(items) {
  for (const item of items) {
    yield heavyComputation(item);
  }
}

async function runWithScheduler(items) {
  const generator = processItems(items);

  for (const _ of generator) {
    await scheduler.yield(); // 让出主线程
  }
}
```

#### Web Worker 处理密集计算
```javascript
// worker.js
self.addEventListener('message', (e) => {
  const { data } = e;

  // 密集计算
  const result = heavyComputation(data);

  self.postMessage(result);
});

// main.js
const worker = new Worker('worker.js');

worker.postMessage(largeData);

worker.addEventListener('message', (e) => {
  const result = e.data;
  console.log('计算结果:', result);
});
```

### 5.2 减少 JavaScript 体积

#### 移除未使用的代码
```javascript
// ❌ 导入整个库
import _ from 'lodash';

// ✅ 按需导入
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';

// ✅ 使用更小的替代库
import debounce from 'just-debounce-it'; // 更小
```

#### 压缩和混淆
```javascript
// Terser 配置（Webpack/Vite 内置）
module.exports = {
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true, // 移除 console
            drop_debugger: true, // 移除 debugger
            pure_funcs: ['console.log'], // 移除特定函数
          },
          mangle: true, // 变量名混淆
          output: {
            comments: false, // 移除注释
          },
        },
      }),
    ],
  },
};
```

#### Polyfill 按需加载
```javascript
// ❌ 错误：全量 Polyfill
import 'core-js';

// ✅ 正确：按需 Polyfill
import 'core-js/features/promise';
import 'core-js/features/array/includes';

// ✅ 更好：使用 @babel/preset-env 自动处理
// babel.config.js
module.exports = {
  presets: [
    ['@babel/preset-env', {
      useBuiltIns: 'usage', // 按需引入
      corejs: 3,
      targets: {
        browsers: ['> 1%', 'last 2 versions', 'not dead'],
      },
    }],
  ],
};
```

### 5.3 防抖和节流

#### 防抖（Debounce）
```javascript
// 防抖：延迟执行，频繁触发只执行最后一次
function debounce(func, wait) {
  let timeout;

  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };

    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// 使用场景：搜索框输入
const searchInput = document.querySelector('#search');
const handleSearch = debounce((e) => {
  console.log('搜索:', e.target.value);
  // API 请求
}, 300);

searchInput.addEventListener('input', handleSearch);
```

#### 节流（Throttle）
```javascript
// 节流：固定时间间隔执行
function throttle(func, limit) {
  let inThrottle;

  return function executedFunction(...args) {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;

      setTimeout(() => {
        inThrottle = false;
      }, limit);
    }
  };
}

// 使用场景：滚动事件
const handleScroll = throttle(() => {
  console.log('滚动位置:', window.scrollY);
  // 处理滚动逻辑
}, 200);

window.addEventListener('scroll', handleScroll);
```

#### React Hooks 版本
```javascript
import { useCallback, useRef } from 'react';

// 防抖 Hook
function useDebounce(callback, delay) {
  const timeoutRef = useRef(null);

  return useCallback((...args) => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    timeoutRef.current = setTimeout(() => {
      callback(...args);
    }, delay);
  }, [callback, delay]);
}

// 节流 Hook
function useThrottle(callback, limit) {
  const inThrottle = useRef(false);

  return useCallback((...args) => {
    if (!inThrottle.current) {
      callback(...args);
      inThrottle.current = true;

      setTimeout(() => {
        inThrottle.current = false;
      }, limit);
    }
  }, [callback, limit]);
}

// 使用
function SearchComponent() {
  const handleSearch = useDebounce((value) => {
    console.log('搜索:', value);
  }, 300);

  return <input onChange={(e) => handleSearch(e.target.value)} />;
}
```

### 5.4 避免内存泄漏

#### 常见内存泄漏场景

**1. 未清理的定时器**
```javascript
// ❌ 错误
componentDidMount() {
  this.timer = setInterval(() => {
    this.setState({ time: Date.now() });
  }, 1000);
}

// ✅ 正确
componentDidMount() {
  this.timer = setInterval(() => {
    this.setState({ time: Date.now() });
  }, 1000);
}

componentWillUnmount() {
  clearInterval(this.timer);
}
```

**2. 未移除的事件监听器**
```javascript
// ❌ 错误
componentDidMount() {
  window.addEventListener('resize', this.handleResize);
}

// ✅ 正确
componentDidMount() {
  window.addEventListener('resize', this.handleResize);
}

componentWillUnmount() {
  window.removeEventListener('resize', this.handleResize);
}
```

**3. 闭包引用**
```javascript
// ❌ 错误：闭包持有大对象引用
function createClosure() {
  const largeData = new Array(1000000).fill('data');

  return function() {
    console.log(largeData[0]); // 持有整个数组引用
  };
}

// ✅ 正确：只保留需要的数据
function createClosure() {
  const largeData = new Array(1000000).fill('data');
  const firstItem = largeData[0]; // 只保留需要的

  return function() {
    console.log(firstItem);
  };
}
```

**4. DOM 引用**
```javascript
// ❌ 错误：保留已移除 DOM 的引用
const elements = [];
document.querySelectorAll('.item').forEach(el => {
  elements.push(el);
});
// 即使 DOM 被移除，elements 仍持有引用

// ✅ 正确：使用 WeakMap
const elementsMap = new WeakMap();
document.querySelectorAll('.item').forEach(el => {
  elementsMap.set(el, { data: 'value' });
});
// DOM 被移除后，WeakMap 会自动清理
```

---

## 六、CSS 优化

### 6.1 减少 CSS 体积

#### 移除未使用的 CSS
```javascript
// PurgeCSS 配置
module.exports = {
  content: [
    './src/**/*.html',
    './src/**/*.js',
    './src/**/*.jsx',
    './src/**/*.ts',
    './src/**/*.tsx',
  ],
  css: ['./src/**/*.css'],
  safelist: [
    'active',
    'disabled',
    /^data-/,
  ],
};
```

```javascript
// Vite 配置
import { defineConfig } from 'vite';
import { purgeCss } from 'vite-plugin-purgecss';

export default defineConfig({
  plugins: [
    purgeCss({
      content: ['./src/**/*.{js,jsx,ts,tsx,html}'],
    }),
  ],
});
```

#### CSS 压缩
```javascript
// PostCSS 配置
module.exports = {
  plugins: [
    require('cssnano')({
      preset: ['default', {
        discardComments: { removeAll: true },
        normalizeWhitespace: true,
        minifyFontValues: true,
        minifySelectors: true,
      }],
    }),
  ],
};
```

### 6.2 优化 CSS 选择器

#### 选择器性能
```css
/* ❌ 慢：通用选择器 */
* { margin: 0; }

/* ❌ 慢：过度嵌套 */
.container .content .item .title .text { color: red; }

/* ❌ 慢：属性选择器 */
[data-attribute="value"] { color: blue; }

/* ✅ 快：类选择器 */
.text { color: red; }

/* ✅ 快：ID 选择器 */
#header { height: 60px; }

/* ✅ 快：简化嵌套 */
.item-text { color: red; }
```

**选择器性能排序**（从快到慢）:
1. ID 选择器: `#id`
2. 类选择器: `.class`
3. 标签选择器: `div`
4. 相邻选择器: `div + p`
5. 子选择器: `div > p`
6. 后代选择器: `div p`
7. 通配符选择器: `*`
8. 属性选择器: `[type="text"]`
9. 伪类选择器: `a:hover`

### 6.3 避免 CSS 阻塞渲染

#### 关键 CSS 提取
```javascript
// Critical CSS 提取（Webpack）
const CriticalCssPlugin = require('critical-css-webpack-plugin');

module.exports = {
  plugins: [
    new CriticalCssPlugin({
      base: 'dist/',
      src: 'index.html',
      dest: 'index.html',
      inline: true,
      minify: true,
      extract: true,
      width: 375,
      height: 812,
    }),
  ],
};
```

#### 异步加载非关键 CSS
```html
<!-- 方法 1: 使用 media 属性 -->
<link rel="stylesheet" href="non-critical.css" media="print" onload="this.media='all'">

<!-- 方法 2: 使用 preload -->
<link rel="preload" href="non-critical.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="non-critical.css"></noscript>

<!-- 方法 3: JavaScript 动态加载 -->
<script>
  const link = document.createElement('link');
  link.rel = 'stylesheet';
  link.href = 'non-critical.css';
  document.head.appendChild(link);
</script>
```

### 6.4 CSS 动画优化

#### 使用 transform 和 opacity
```css
/* ❌ 错误：触发重排和重绘 */
.box {
  transition: width 0.3s, height 0.3s, left 0.3s, top 0.3s;
}

.box:hover {
  width: 200px;
  height: 200px;
  left: 100px;
  top: 100px;
}

/* ✅ 正确：只触发合成 */
.box {
  transition: transform 0.3s, opacity 0.3s;
}

.box:hover {
  transform: translate(100px, 100px) scale(2);
  opacity: 0.8;
}
```

#### 使用 will-change
```css
/* 提示浏览器元素将要变化 */
.animated-element {
  will-change: transform, opacity;
}

/* 动画结束后移除 */
.animated-element.done {
  will-change: auto;
}
```

```javascript
// JavaScript 控制
element.addEventListener('mouseenter', () => {
  element.style.willChange = 'transform';
});

element.addEventListener('animationend', () => {
  element.style.willChange = 'auto';
});
```

#### 使用 CSS containment
```css
/* 限制浏览器重排范围 */
.card {
  contain: layout style paint;
}

/* 或使用 content-visibility */
.lazy-section {
  content-visibility: auto;
  contain-intrinsic-size: 0 500px; /* 预估高度 */
}
```

### 6.5 字体优化

#### 字体加载策略
```css
/* font-display 属性 */
@font-face {
  font-family: 'CustomFont';
  src: url('/fonts/custom.woff2') format('woff2');
  font-display: swap; /* 推荐：立即显示备用字体 */
  /* 其他选项:
     auto: 浏览器默认行为
     block: 短暂隐藏文本（最多 3s）
     swap: 立即显示备用字体
     fallback: 极短隐藏（100ms），3s 后放弃自定义字体
     optional: 极短隐藏，根据网络决定是否使用自定义字体
  */
}
```

#### 字体预加载
```html
<!-- 预加载关键字体 -->
<link
  rel="preload"
  href="/fonts/main.woff2"
  as="font"
  type="font/woff2"
  crossorigin
>
```

#### 字体子集化
```javascript
// 使用 Google Fonts 子集
// 只包含拉丁字符
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&subset=latin&display=swap" rel="stylesheet">

// 使用工具生成子集
// fonttools, glyphhanger
```

#### 可变字体
```css
/* 使用可变字体减少文件数量 */
@font-face {
  font-family: 'InterVariable';
  src: url('/fonts/Inter-Variable.woff2') format('woff2');
  font-weight: 100 900; /* 支持所有粗细 */
  font-display: swap;
}

.text {
  font-family: 'InterVariable';
  font-weight: 450; /* 任意粗细 */
}
```

---

## 七、渲染性能优化

### 7.1 减少重排（Reflow）和重绘（Repaint）

#### 触发重排的操作
- 修改元素几何属性: `width`, `height`, `padding`, `margin`, `border`
- 修改元素位置: `top`, `left`, `bottom`, `right`
- 修改字体大小: `font-size`
- 添加/删除 DOM 元素
- 读取某些属性: `offsetTop`, `scrollTop`, `clientTop`, `getComputedStyle()`

#### 优化策略

**1. 批量修改 DOM**
```javascript
// ❌ 错误：多次重排
element.style.width = '100px';
element.style.height = '100px';
element.style.margin = '10px';

// ✅ 正确：使用 cssText 一次性修改
element.style.cssText = 'width: 100px; height: 100px; margin: 10px;';

// ✅ 正确：使用 class
element.className = 'new-style';
```

**2. 离线操作 DOM**
```javascript
// ❌ 错误：每次插入都触发重排
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  document.body.appendChild(div);
}

// ✅ 正确：使用 DocumentFragment
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  fragment.appendChild(div);
}
document.body.appendChild(fragment);

// ✅ 正确：使用 innerHTML
const html = Array.from({ length: 1000 }, () => '<div></div>').join('');
container.innerHTML = html;
```

**3. 缓存布局信息**
```javascript
// ❌ 错误：每次循环都读取 offsetHeight
for (let i = 0; i < elements.length; i++) {
  elements[i].style.top = elements[i].offsetHeight + 'px';
}

// ✅ 正确：缓存布局信息
const heights = elements.map(el => el.offsetHeight);
for (let i = 0; i < elements.length; i++) {
  elements[i].style.top = heights[i] + 'px';
}
```

**4. 使用 transform 替代位置属性**
```javascript
// ❌ 错误：触发重排
element.style.left = '100px';
element.style.top = '100px';

// ✅ 正确：只触发合成
element.style.transform = 'translate(100px, 100px)';
```

### 7.2 虚拟滚动（Virtual Scrolling）

#### 长列表优化
```javascript
// React 虚拟滚动示例
import { FixedSizeList } from 'react-window';

function VirtualList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index].name}
    </div>
  );

  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}
```

#### 原生实现
```javascript
class VirtualScroll {
  constructor(container, items, itemHeight) {
    this.container = container;
    this.items = items;
    this.itemHeight = itemHeight;
    this.visibleCount = Math.ceil(container.clientHeight / itemHeight);
    this.startIndex = 0;

    this.init();
  }

  init() {
    // 创建占位容器
    this.scrollHeight = this.items.length * this.itemHeight;
    this.container.style.height = `${this.scrollHeight}px`;

    // 监听滚动
    this.container.addEventListener('scroll', () => {
      this.startIndex = Math.floor(this.container.scrollTop / this.itemHeight);
      this.render();
    });

    this.render();
  }

  render() {
    const endIndex = this.startIndex + this.visibleCount;
    const visibleItems = this.items.slice(this.startIndex, endIndex);

    // 渲染可见项
    this.container.innerHTML = visibleItems.map((item, index) => `
      <div style="
        position: absolute;
        top: ${(this.startIndex + index) * this.itemHeight}px;
        height: ${this.itemHeight}px;
      ">
        ${item.name}
      </div>
    `).join('');
  }
}
```

### 7.3 React 性能优化

#### 组件缓存
```javascript
import { memo, useMemo, useCallback } from 'react';

// 1. React.memo 缓存组件
const ExpensiveComponent = memo(({ data }) => {
  return <div>{/* 复杂渲染 */}</div>;
});

// 2. useMemo 缓存计算结果
function Component({ items }) {
  const sortedItems = useMemo(() => {
    return items.sort((a, b) => a.value - b.value);
  }, [items]);

  return <List items={sortedItems} />;
}

// 3. useCallback 缓存函数
function Parent() {
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);

  return <Child onClick={handleClick} />;
}
```

#### 列表 key 优化
```javascript
// ❌ 错误：使用 index 作为 key
items.map((item, index) => <Item key={index} {...item} />)

// ✅ 正确：使用唯一 ID
items.map(item => <Item key={item.id} {...item} />)

// ✅ 如果没有 ID，生成稳定的 key
items.map(item => <Item key={`${item.name}-${item.value}`} {...item} />)
```

#### 避免不必要的渲染
```javascript
// 使用 React DevTools Profiler 分析
import { Profiler } from 'react';

function onRenderCallback(
  id,
  phase,
  actualDuration,
  baseDuration,
  startTime,
  commitTime
) {
  console.log(`${id} (${phase}) took ${actualDuration}ms`);
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <Component />
    </Profiler>
  );
}
```

#### 代码分割
```javascript
// 路由级别分割
import { lazy, Suspense } from 'react';

const Dashboard = lazy(() => import('./Dashboard'));
const Profile = lazy(() => import('./Profile'));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <Routes>
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/profile" element={<Profile />} />
      </Routes>
    </Suspense>
  );
}
```

### 7.4 Vue 性能优化

#### 组件缓存
```vue
<!-- keep-alive 缓存组件 -->
<template>
  <keep-alive>
    <component :is="currentComponent" />
  </keep-alive>
</template>

<script>
export default {
  data() {
    return {
      currentComponent: 'ComponentA'
    }
  }
}
</script>
```

#### 计算属性和侦听器
```javascript
export default {
  data() {
    return {
      items: []
    }
  },
  computed: {
    // ✅ 使用计算属性缓存结果
    sortedItems() {
      return this.items.sort((a, b) => a.value - b.value);
    }
  },
  methods: {
    // ❌ 避免在方法中进行复杂计算
    getSortedItems() {
      return this.items.sort((a, b) => a.value - b.value);
    }
  }
}
```

#### v-show vs v-if
```vue
<!-- v-show: 频繁切换，初始渲染成本高 -->
<div v-show="isVisible">内容</div>

<!-- v-if: 条件很少改变，初始渲染成本低 -->
<div v-if="isVisible">内容</div>
```

---

## 八、缓存策略

### 8.1 HTTP 缓存

#### 强缓存
```nginx
# Nginx 配置
location ~* \.(jpg|jpeg|png|gif|ico|css|js|woff2)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
}

# HTML 文件不缓存
location ~* \.html$ {
    expires -1;
    add_header Cache-Control "no-cache, no-store, must-revalidate";
}
```

**Cache-Control 指令**:
- `max-age=<seconds>`: 缓存有效期
- `public`: 可被任何缓存存储
- `private`: 只能被浏览器缓存
- `no-cache`: 使用前必须验证
- `no-store`: 不缓存任何内容
- `immutable`: 内容永不改变
- `must-revalidate`: 过期后必须验证

#### 协商缓存
```nginx
# ETag 和 Last-Modified
location / {
    etag on;
    add_header Last-Modified $date_gmt;
}
```

**缓存流程**:
1. 首次请求：服务器返回 `ETag` 和 `Last-Modified`
2. 再次请求：浏览器发送 `If-None-Match` (ETag) 和 `If-Modified-Since`
3. 未修改：服务器返回 304 Not Modified
4. 已修改：服务器返回 200 和新内容

### 8.2 Service Worker 缓存

#### 基础 Service Worker
```javascript
// sw.js
const CACHE_NAME = 'v1';
const urlsToCache = [
  '/',
  '/css/main.css',
  '/js/main.js',
  '/images/logo.png',
];

// 安装
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

// 激活
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== CACHE_NAME) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// 拦截请求
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // 缓存命中
        if (response) {
          return response;
        }

        // 请求网络
        return fetch(event.request);
      })
  );
});
```

#### Workbox 缓存策略
```javascript
import { registerRoute } from 'workbox-routing';
import {
  CacheFirst,
  NetworkFirst,
  StaleWhileRevalidate,
  NetworkOnly
} from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

// 1. Cache First - 静态资源（图片、字体）
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 天
      }),
    ],
  })
);

// 2. Network First - API 请求
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 5 * 60, // 5 分钟
      }),
    ],
  })
);

// 3. Stale While Revalidate - JS/CSS
registerRoute(
  ({ request }) =>
    request.destination === 'script' ||
    request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  })
);

// 4. Network Only - 不缓存的请求
registerRoute(
  ({ url }) => url.pathname.startsWith('/admin/'),
  new NetworkOnly()
);
```

### 8.3 LocalStorage / SessionStorage

#### 数据缓存
```javascript
// 封装 Storage 工具
class Storage {
  // 设置缓存（带过期时间）
  static set(key, value, expire = null) {
    const data = {
      value,
      expire: expire ? Date.now() + expire : null,
    };
    localStorage.setItem(key, JSON.stringify(data));
  }

  // 获取缓存
  static get(key) {
    const data = localStorage.getItem(key);
    if (!data) return null;

    const { value, expire } = JSON.parse(data);

    // 检查是否过期
    if (expire && Date.now() > expire) {
      localStorage.removeItem(key);
      return null;
    }

    return value;
  }

  // 删除缓存
  static remove(key) {
    localStorage.removeItem(key);
  }

  // 清空缓存
  static clear() {
    localStorage.clear();
  }
}

// 使用
Storage.set('user', { name: 'John' }, 3600000); // 1 小时
const user = Storage.get('user');
```

#### IndexedDB 大数据缓存
```javascript
// 封装 IndexedDB
class IndexedDBHelper {
  constructor(dbName, version = 1) {
    this.dbName = dbName;
    this.version = version;
    this.db = null;
  }

  async open(storeName) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(storeName)) {
          db.createObjectStore(storeName, { keyPath: 'id', autoIncrement: true });
        }
      };
    });
  }

  async add(storeName, data) {
    const transaction = this.db.transaction([storeName], 'readwrite');
    const store = transaction.objectStore(storeName);
    return store.add(data);
  }

  async get(storeName, id) {
    const transaction = this.db.transaction([storeName], 'readonly');
    const store = transaction.objectStore(storeName);
    return new Promise((resolve, reject) => {
      const request = store.get(id);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async getAll(storeName) {
    const transaction = this.db.transaction([storeName], 'readonly');
    const store = transaction.objectStore(storeName);
    return new Promise((resolve, reject) => {
      const request = store.getAll();
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
}

// 使用
const db = new IndexedDBHelper('myDatabase');
await db.open('users');
await db.add('users', { name: 'John', age: 30 });
const users = await db.getAll('users');
```

### 8.4 Memory Cache

#### 应用级缓存
```javascript
// 简单缓存实现
class MemoryCache {
  constructor(maxSize = 100) {
    this.cache = new Map();
    this.maxSize = maxSize;
  }

  set(key, value, ttl = null) {
    // LRU: 超过最大容量时删除最旧的
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }

    const expire = ttl ? Date.now() + ttl : null;
    this.cache.set(key, { value, expire });
  }

  get(key) {
    const data = this.cache.get(key);
    if (!data) return null;

    const { value, expire } = data;

    // 检查过期
    if (expire && Date.now() > expire) {
      this.cache.delete(key);
      return null;
    }

    // LRU: 更新访问顺序
    this.cache.delete(key);
    this.cache.set(key, data);

    return value;
  }

  has(key) {
    return this.get(key) !== null;
  }

  delete(key) {
    this.cache.delete(key);
  }

  clear() {
    this.cache.clear();
  }
}

// 使用
const cache = new MemoryCache(50);
cache.set('user:1', { name: 'John' }, 60000); // 1 分钟
const user = cache.get('user:1');
```

#### React Query / SWR 缓存
```javascript
// React Query
import { useQuery } from '@tanstack/react-query';

function UserProfile({ userId }) {
  const { data, isLoading } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    staleTime: 5 * 60 * 1000, // 5 分钟内不重新请求
    cacheTime: 10 * 60 * 1000, // 10 分钟后清除缓存
  });

  if (isLoading) return <div>Loading...</div>;
  return <div>{data.name}</div>;
}

// SWR
import useSWR from 'swr';

function UserProfile({ userId }) {
  const { data, error } = useSWR(
    `/api/user/${userId}`,
    fetcher,
    {
      revalidateOnFocus: false,
      dedupingInterval: 60000, // 1 分钟内去重
    }
  );

  if (error) return <div>Error</div>;
  if (!data) return <div>Loading...</div>;
  return <div>{data.name}</div>;
}
```

---

## 九、构建优化

### 9.1 代码分割和懒加载

#### Webpack 配置
```javascript
module.exports = {
  entry: {
    main: './src/index.js',
  },
  output: {
    filename: '[name].[contenthash].js',
    chunkFilename: '[name].[contenthash].chunk.js',
    path: path.resolve(__dirname, 'dist'),
  },
  optimization: {
    moduleIds: 'deterministic',
    runtimeChunk: 'single',
    splitChunks: {
      chunks: 'all',
      maxInitialRequests: 25,
      minSize: 20000,
      cacheGroups: {
        // 提取 node_modules
        defaultVendors: {
          test: /[\\/]node_modules[\\/]/,
          priority: -10,
          reuseExistingChunk: true,
        },
        // 提取公共代码
        default: {
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true,
        },
        // React 全家桶
        react: {
          test: /[\\/]node_modules[\\/](react|react-dom|react-router-dom)[\\/]/,
          name: 'react-vendors',
          priority: 10,
        },
        // UI 库
        antd: {
          test: /[\\/]node_modules[\\/]antd[\\/]/,
          name: 'antd',
          priority: 10,
        },
        // 工具库
        utils: {
          test: /[\\/]node_modules[\\/](lodash|moment|dayjs)[\\/]/,
          name: 'utils',
          priority: 10,
        },
      },
    },
  },
};
```

#### Vite 配置
```javascript
// vite.config.js
export default {
  build: {
    rollupOptions: {
      output: {
        manualChunks(id) {
          // node_modules 分包
          if (id.includes('node_modules')) {
            // React 生态
            if (id.includes('react') || id.includes('react-dom')) {
              return 'react-vendor';
            }
            // UI 库
            if (id.includes('antd') || id.includes('@ant-design')) {
              return 'antd-vendor';
            }
            // 图表库
            if (id.includes('echarts') || id.includes('chart')) {
              return 'chart-vendor';
            }
            // 其他第三方库
            return 'vendor';
          }
        },
        // 文件命名
        chunkFileNames: 'js/[name]-[hash].js',
        entryFileNames: 'js/[name]-[hash].js',
        assetFileNames: '[ext]/[name]-[hash].[ext]',
      },
    },
    // 代码分割阈值
    chunkSizeWarningLimit: 500,
    // CSS 代码分割
    cssCodeSplit: true,
  },
};
```

### 9.2 Tree Shaking

#### 配置
```javascript
// Webpack
module.exports = {
  mode: 'production',
  optimization: {
    usedExports: true,
    minimize: true,
  },
};

// package.json
{
  "sideEffects": false,
  // 或指定有副作用的文件
  "sideEffects": [
    "*.css",
    "*.scss",
    "./src/polyfills.js"
  ]
}
```

#### 编写 Tree Shaking 友好的代码
```javascript
// ❌ 错误：不利于 Tree Shaking
export default {
  method1() {},
  method2() {},
  method3() {},
};

// ✅ 正确：命名导出
export function method1() {}
export function method2() {}
export function method3() {}

// ❌ 错误：导入整个库
import _ from 'lodash';

// ✅ 正确：按需导入
import debounce from 'lodash/debounce';
import { debounce } from 'lodash-es';
```

### 9.3 压缩优化

#### JavaScript 压缩
```javascript
// Terser 配置
const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true,
            drop_debugger: true,
            pure_funcs: ['console.log', 'console.info'],
            passes: 2,
          },
          mangle: {
            safari10: true,
          },
          format: {
            comments: false,
          },
        },
        extractComments: false,
      }),
    ],
  },
};
```

#### CSS 压缩
```javascript
// CSS Minimizer
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');

module.exports = {
  optimization: {
    minimizer: [
      new CssMinimizerPlugin({
        minimizerOptions: {
          preset: [
            'default',
            {
              discardComments: { removeAll: true },
            },
          ],
        },
      }),
    ],
  },
};
```

#### HTML 压缩
```javascript
// html-webpack-plugin
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html',
      minify: {
        removeComments: true,
        collapseWhitespace: true,
        removeRedundantAttributes: true,
        useShortDoctype: true,
        removeEmptyAttributes: true,
        removeStyleLinkTypeAttributes: true,
        keepClosingSlash: true,
        minifyJS: true,
        minifyCSS: true,
        minifyURLs: true,
      },
    }),
  ],
};
```

### 9.4 资源内联

#### HTML 内联
```javascript
// html-webpack-inline-source-plugin
const HtmlWebpackPlugin = require('html-webpack-plugin');
const HtmlWebpackInlineSourcePlugin = require('html-webpack-inline-source-plugin');

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      inlineSource: '.(js|css)$', // 内联所有 JS 和 CSS
    }),
    new HtmlWebpackInlineSourcePlugin(),
  ],
};
```

#### 关键 CSS 内联
```javascript
// critical-css-webpack-plugin
const CriticalCssPlugin = require('critical-css-webpack-plugin');

module.exports = {
  plugins: [
    new CriticalCssPlugin({
      base: 'dist/',
      src: 'index.html',
      dest: 'index.html',
      inline: true,
      minify: true,
      extract: true,
      width: 375,
      height: 812,
      penthouse: {
        blockJSRequests: false,
      },
    }),
  ],
};
```

### 9.5 构建分析

#### Bundle 分析
```javascript
// webpack-bundle-analyzer
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin({
      analyzerMode: 'static',
      openAnalyzer: true,
      reportFilename: 'bundle-report.html',
    }),
  ],
};

// Vite
import { visualizer } from 'rollup-plugin-visualizer';

export default {
  plugins: [
    visualizer({
      open: true,
      gzipSize: true,
      brotliSize: true,
    }),
  ],
};
```

#### 构建速度分析
```javascript
// speed-measure-webpack-plugin
const SpeedMeasurePlugin = require('speed-measure-webpack-plugin');
const smp = new SpeedMeasurePlugin();

module.exports = smp.wrap({
  // webpack 配置
});
```

---

## 十、监控与分析

### 10.1 性能监控指标

#### Performance API
```javascript
// 获取性能指标
window.addEventListener('load', () => {
  const perfData = window.performance.timing;
  const pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
  const connectTime = perfData.responseEnd - perfData.requestStart;
  const renderTime = perfData.domComplete - perfData.domLoading;
  const dnsTime = perfData.domainLookupEnd - perfData.domainLookupStart;
  const tcpTime = perfData.connectEnd - perfData.connectStart;

  console.log('页面加载时间:', pageLoadTime);
  console.log('请求响应时间:', connectTime);
  console.log('DOM 渲染时间:', renderTime);
  console.log('DNS 查询时间:', dnsTime);
  console.log('TCP 连接时间:', tcpTime);
});
```

#### PerformanceObserver
```javascript
// 监控 LCP
const lcpObserver = new PerformanceObserver((list) => {
  const entries = list.getEntries();
  const lastEntry = entries[entries.length - 1];
  console.log('LCP:', lastEntry.renderTime || lastEntry.loadTime);
});
lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });

// 监控 FID
const fidObserver = new PerformanceObserver((list) => {
  const entries = list.getEntries();
  entries.forEach((entry) => {
    console.log('FID:', entry.processingStart - entry.startTime);
  });
});
fidObserver.observe({ entryTypes: ['first-input'] });

// 监控 CLS
let clsValue = 0;
const clsObserver = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (!entry.hadRecentInput) {
      clsValue += entry.value;
      console.log('CLS:', clsValue);
    }
  }
});
clsObserver.observe({ entryTypes: ['layout-shift'] });

// 监控资源加载
const resourceObserver = new PerformanceObserver((list) => {
  const entries = list.getEntries();
  entries.forEach((entry) => {
    console.log('资源:', entry.name);
    console.log('加载时间:', entry.duration);
    console.log('大小:', entry.transferSize);
  });
});
resourceObserver.observe({ entryTypes: ['resource'] });

// 监控长任务
const longTaskObserver = new PerformanceObserver((list) => {
  const entries = list.getEntries();
  entries.forEach((entry) => {
    console.log('长任务:', entry.duration);
  });
});
longTaskObserver.observe({ entryTypes: ['longtask'] });
```

#### Web Vitals 库
```javascript
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

// 上报到分析服务
function sendToAnalytics(metric) {
  const body = JSON.stringify(metric);
  const url = 'https://analytics.example.com/performance';

  // 使用 sendBeacon 确保数据发送
  if (navigator.sendBeacon) {
    navigator.sendBeacon(url, body);
  } else {
    fetch(url, { body, method: 'POST', keepalive: true });
  }
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

### 10.2 错误监控

#### 全局错误捕获
```javascript
// JavaScript 错误
window.addEventListener('error', (event) => {
  console.error('错误:', {
    message: event.message,
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno,
    error: event.error,
  });

  // 上报错误
  reportError({
    type: 'javascript',
    message: event.message,
    stack: event.error?.stack,
    url: event.filename,
    line: event.lineno,
    column: event.colno,
  });
});

// Promise 错误
window.addEventListener('unhandledrejection', (event) => {
  console.error('Promise 错误:', event.reason);

  reportError({
    type: 'promise',
    message: event.reason?.message || event.reason,
    stack: event.reason?.stack,
  });
});

// 资源加载错误
window.addEventListener('error', (event) => {
  if (event.target !== window) {
    console.error('资源加载失败:', event.target);

    reportError({
      type: 'resource',
      url: event.target.src || event.target.href,
      tagName: event.target.tagName,
    });
  }
}, true);
```

#### React 错误边界
```javascript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('React 错误:', error, errorInfo);

    reportError({
      type: 'react',
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
    });
  }

  render() {
    if (this.state.hasError) {
      return <h1>出错了</h1>;
    }

    return this.props.children;
  }
}

// 使用
<ErrorBoundary>
  <App />
</ErrorBoundary>
```

### 10.3 用户行为追踪

#### 页面访问追踪
```javascript
// 页面浏览
function trackPageView() {
  const data = {
    url: window.location.href,
    title: document.title,
    referrer: document.referrer,
    timestamp: Date.now(),
    userAgent: navigator.userAgent,
  };

  sendAnalytics('pageview', data);
}

// 页面停留时间
let startTime = Date.now();

window.addEventListener('beforeunload', () => {
  const duration = Date.now() - startTime;
  sendAnalytics('page-duration', { duration });
});

// 页面可见性
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    sendAnalytics('page-hidden', { timestamp: Date.now() });
  } else {
    sendAnalytics('page-visible', { timestamp: Date.now() });
  }
});
```

#### 用户交互追踪
```javascript
// 点击事件
document.addEventListener('click', (event) => {
  const target = event.target;
  const data = {
    tagName: target.tagName,
    id: target.id,
    className: target.className,
    text: target.innerText?.substring(0, 50),
    x: event.clientX,
    y: event.clientY,
  };

  sendAnalytics('click', data);
}, true);

// 滚动深度
let maxScrollDepth = 0;

window.addEventListener('scroll', throttle(() => {
  const scrollDepth = Math.round(
    (window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100
  );

  if (scrollDepth > maxScrollDepth) {
    maxScrollDepth = scrollDepth;
    sendAnalytics('scroll-depth', { depth: scrollDepth });
  }
}, 1000));
```

### 10.4 性能优化工具

#### Lighthouse
```bash
# 命令行运行
npm install -g lighthouse
lighthouse https://example.com --output html --output-path ./report.html

# CI 集成
lighthouse https://example.com --output json --output-path ./report.json --chrome-flags="--headless"
```

#### WebPageTest
```javascript
// WebPageTest API
const WebPageTest = require('webpagetest');
const wpt = new WebPageTest('www.webpagetest.org', 'YOUR_API_KEY');

wpt.runTest('https://example.com', {
  location: 'Dulles:Chrome',
  connectivity: '4G',
  runs: 3,
  video: true,
}, (err, result) => {
  if (err) return console.error(err);

  console.log('Test ID:', result.data.testId);
  console.log('Results URL:', result.data.summaryUrl);
});
```

#### Chrome DevTools
```javascript
// Performance API 使用
performance.mark('start-task');

// 执行任务
doSomething();

performance.mark('end-task');
performance.measure('task-duration', 'start-task', 'end-task');

const measures = performance.getEntriesByType('measure');
console.log('任务耗时:', measures[0].duration);

// 清理
performance.clearMarks();
performance.clearMeasures();
```

---

## 附录：性能优化检查清单

### 网络层
- [ ] 启用 HTTP/2 或 HTTP/3
- [ ] 启用 Gzip/Brotli 压缩
- [ ] 使用 CDN 加速
- [ ] DNS 预解析和预连接
- [ ] 减少 HTTP 请求数量
- [ ] 合理设置缓存策略

### 资源加载
- [ ] 关键资源使用 preload
- [ ] 非关键资源使用 prefetch
- [ ] CSS 放在 head，JS 放在 body 底部或使用 defer/async
- [ ] 内联关键 CSS
- [ ] 代码分割和懒加载
- [ ] Tree Shaking 移除未使用代码

### 图片优化
- [ ] 使用现代图片格式（WebP/AVIF）
- [ ] 图片压缩
- [ ] 图片懒加载
- [ ] 响应式图片
- [ ] 设置图片宽高避免 CLS
- [ ] 使用 CDN 图片处理

### JavaScript
- [ ] 减少 JavaScript 执行时间
- [ ] 拆分长任务
- [ ] 使用 Web Worker 处理密集计算
- [ ] 防抖和节流
- [ ] 避免内存泄漏
- [ ] 压缩和混淆代码

### CSS
- [ ] 移除未使用的 CSS
- [ ] CSS 压缩
- [ ] 优化选择器
- [ ] 使用 transform 和 opacity 做动画
- [ ] 字体优化（font-display、预加载）

### 渲染性能
- [ ] 减少重排和重绘
- [ ] 虚拟滚动优化长列表
- [ ] React/Vue 组件优化
- [ ] 使用 requestAnimationFrame
- [ ] 使用 CSS containment

### 缓存策略
- [ ] HTTP 缓存配置
- [ ] Service Worker 缓存
- [ ] LocalStorage/IndexedDB 缓存
- [ ] 应用级内存缓存

### 构建优化
- [ ] 代码分割
- [ ] Tree Shaking
- [ ] 压缩优化
- [ ] 资源内联
- [ ] 构建分析

### 监控
- [ ] 性能指标监控（Core Web Vitals）
- [ ] 错误监控
- [ ] 用户行为追踪
- [ ] 定期性能审计

---

## 参考资源

### 官方文档
- [Web.dev Performance](https://web.dev/performance/)
- [MDN Web Performance](https://developer.mozilla.org/en-US/docs/Web/Performance)
- [Chrome DevTools Performance](https://developer.chrome.com/docs/devtools/performance/)

### 工具
- [Lighthouse](https://developers.google.com/web/tools/lighthouse)
- [WebPageTest](https://www.webpagetest.org/)
- [PageSpeed Insights](https://pagespeed.web.dev/)
- [GTmetrix](https://gtmetrix.com/)

### 最佳实践
- [雅虎军规（Yahoo Best Practices）](https://developer.yahoo.com/performance/rules.html)
- [Google Performance Best Practices](https://developers.google.com/web/fundamentals/performance)
- [Web Vitals](https://web.dev/vitals/)

---

**文档版本**: v1.0
**最后更新**: 2025-12-16
**维护者**: 前端性能优化团队

