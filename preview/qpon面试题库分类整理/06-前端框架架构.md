# 前端框架架构

## 1. 前端框架概念
**问题：** 前端框架的概念

### 解答

#### 什么是前端框架
前端框架是一套完整的解决方案，提供了项目的基础架构和开发规范，包括：
- 组件化开发模式
- 路由管理
- 状态管理
- 构建工具链
- 代码规范

#### 主流前端框架对比

| 特性 | React | Vue | Angular |
|-----|-------|-----|---------|
| 学习曲线 | 中等 | 较低 | 较高 |
| 性能 | 高 | 高 | 中等 |
| 生态系统 | 丰富 | 丰富 | 完善 |
| 灵活性 | 高 | 中等 | 低 |
| TypeScript | 支持 | 支持 | 原生支持 |
| 移动端 | React Native | Weex/Uni-app | Ionic |
| 适用场景 | 大型应用 | 中小型应用 | 企业级应用 |

#### React特点
```javascript
// 声明式编程
function Welcome({ name }) {
  return <h1>Hello, {name}</h1>;
}

// 组件化
function App() {
  return (
    <div>
      <Welcome name="Sara" />
      <Welcome name="Cahal" />
    </div>
  );
}

// 单向数据流
const [state, setState] = useState(initialState);
```

#### Vue特点
```vue
<!-- 模板语法 -->
<template>
  <div>
    <h1>{{ message }}</h1>
    <button @click="handleClick">Click</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      message: 'Hello Vue'
    };
  },
  methods: {
    handleClick() {
      this.message = 'Clicked!';
    }
  }
};
</script>

<style scoped>
h1 { color: red; }
</style>
```

#### Angular特点
```typescript
// 装饰器语法
@Component({
  selector: 'app-root',
  template: `
    <h1>{{ title }}</h1>
    <button (click)="handleClick()">Click</button>
  `
})
export class AppComponent {
  title = 'Hello Angular';

  handleClick() {
    this.title = 'Clicked!';
  }
}

// 依赖注入
constructor(private userService: UserService) {}
```

## 2. 前端工程化/架构设计
**问题：** 前端工程化/架构设计

**考察要点：** 工程化能力、架构设计思维、项目组织能力、工具链掌握

### 解答

#### 前端工程化体系

**1. 开发规范**
```javascript
// ESLint配置
module.exports = {
  extends: ['eslint:recommended', 'plugin:react/recommended'],
  rules: {
    'indent': ['error', 2],
    'quotes': ['error', 'single'],
    'semi': ['error', 'always']
  }
};

// Prettier配置
module.exports = {
  singleQuote: true,
  semi: true,
  trailingComma: 'es5'
};

// Git Hooks（Husky）
{
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  },
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": ["eslint --fix", "prettier --write"]
  }
}
```

**2. 模块化**
```javascript
// ES Modules
import { add } from './utils';
export default MyComponent;

// CommonJS
const add = require('./utils');
module.exports = MyComponent;

// AMD
define(['utils'], function(utils) {
  return MyComponent;
});

// UMD（通用模块定义）
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['exports'], factory);
  } else if (typeof exports === 'object') {
    factory(exports);
  } else {
    factory((root.MyModule = {}));
  }
}(this, function (exports) {
  exports.MyComponent = MyComponent;
}));
```

**3. 组件化**
```javascript
// 原子组件
const Button = ({ children, onClick }) => (
  <button onClick={onClick}>{children}</button>
);

// 分子组件
const SearchBar = () => (
  <div>
    <Input />
    <Button>Search</Button>
  </div>
);

// 有机组件
const Header = () => (
  <header>
    <Logo />
    <Nav />
    <SearchBar />
  </header>
);

// 模板
const Layout = ({ children }) => (
  <div>
    <Header />
    <main>{children}</main>
    <Footer />
  </div>
);
```

**4. 自动化构建**
```javascript
// Webpack配置
module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js'
  },
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        use: 'babel-loader',
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader', 'postcss-loader']
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin(),
    new MiniCssExtractPlugin()
  ],
  optimization: {
    splitChunks: {
      chunks: 'all'
    }
  }
};
```

**5. 自动化测试**
```javascript
// Jest单元测试
describe('Button', () => {
  it('renders correctly', () => {
    const { getByText } = render(<Button>Click me</Button>);
    expect(getByText('Click me')).toBeInTheDocument();
  });

  it('handles click', () => {
    const handleClick = jest.fn();
    const { getByText } = render(<Button onClick={handleClick}>Click me</Button>);
    fireEvent.click(getByText('Click me'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});

// E2E测试（Cypress）
describe('Login', () => {
  it('should login successfully', () => {
    cy.visit('/login');
    cy.get('[data-testid=username]').type('user@example.com');
    cy.get('[data-testid=password]').type('password');
    cy.get('[data-testid=submit]').click();
    cy.url().should('include', '/dashboard');
  });
});
```

**6. 持续集成/部署（CI/CD）**
```yaml
# .github/workflows/ci.yml
name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '14'
      - run: npm ci
      - run: npm test
      - run: npm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v2
      - run: npm ci
      - run: npm run build
      - uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./dist
```

#### 前端架构设计原则

**1. 分层架构**
```
├── presentation     # 表现层（UI组件）
├── business        # 业务层（业务逻辑）
├── data           # 数据层（API、状态管理）
└── infrastructure # 基础设施层（工具、配置）
```

**2. 目录结构**
```
src/
├── assets/          # 静态资源
├── components/      # 公共组件
│   ├── Button/
│   │   ├── index.tsx
│   │   ├── style.css
│   │   └── __tests__/
├── pages/           # 页面组件
├── layouts/         # 布局组件
├── routes/          # 路由配置
├── services/        # API服务
├── store/           # 状态管理
├── utils/           # 工具函数
├── hooks/           # 自定义Hooks
├── types/           # TypeScript类型
└── config/          # 配置文件
```

**3. 性能优化**
- 代码分割（Code Splitting）
- 懒加载（Lazy Loading）
- Tree Shaking
- 压缩混淆
- CDN加速
- 缓存策略
- SSR/SSG

**4. 安全性**
- XSS防护
- CSRF防护
- Content Security Policy
- HTTPS
- 输入验证
- 敏感信息加密

## 3. bind、call、apply的区别
**问题：** bind、call、apply的区别

### 解答

#### 基本概念
三者都用于改变函数的this指向。

#### call
```javascript
func.call(thisArg, arg1, arg2, ...)

// 示例
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: 'John' };
greet.call(person, 'Hello', '!'); // "Hello, John!"
```

#### apply
```javascript
func.apply(thisArg, [argsArray])

// 示例
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: 'John' };
greet.apply(person, ['Hello', '!']); // "Hello, John!"
```

#### bind
```javascript
const boundFunc = func.bind(thisArg, arg1, arg2, ...)

// 示例
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: 'John' };
const boundGreet = greet.bind(person, 'Hello');
boundGreet('!'); // "Hello, John!"
```

#### 区别总结

| 方法 | 参数传递 | 是否立即执行 | 返回值 |
|-----|---------|------------|--------|
| call | 逐个传递 | 是 | 函数执行结果 |
| apply | 数组传递 | 是 | 函数执行结果 |
| bind | 逐个传递 | 否 | 新函数 |

#### 应用场景

**1. call：参数较少**
```javascript
Math.max.call(null, 1, 2, 3, 4); // 4
Array.prototype.slice.call(arrayLike);
```

**2. apply：参数数组**
```javascript
Math.max.apply(null, [1, 2, 3, 4]); // 4
func.apply(null, args);
```

**3. bind：创建新函数**
```javascript
// 事件处理
button.addEventListener('click', this.handleClick.bind(this));

// 偏函数
const add5 = add.bind(null, 5);
add5(3); // 8

// React类组件
constructor() {
  this.handleClick = this.handleClick.bind(this);
}
```

#### 手写实现

**实现call**
```javascript
Function.prototype.myCall = function(context, ...args) {
  context = context || window;
  const fn = Symbol();
  context[fn] = this;
  const result = context[fn](...args);
  delete context[fn];
  return result;
};
```

**实现apply**
```javascript
Function.prototype.myApply = function(context, args) {
  context = context || window;
  const fn = Symbol();
  context[fn] = this;
  const result = context[fn](...(args || []));
  delete context[fn];
  return result;
};
```

**实现bind**
```javascript
Function.prototype.myBind = function(context, ...args1) {
  const fn = this;
  return function(...args2) {
    return fn.apply(context, [...args1, ...args2]);
  };
};

// 支持new操作的完整版本
Function.prototype.myBind = function(context, ...args1) {
  const fn = this;
  const bound = function(...args2) {
    return fn.apply(
      this instanceof bound ? this : context,
      [...args1, ...args2]
    );
  };
  bound.prototype = Object.create(fn.prototype);
  return bound;
};
```

## 4. === 和 == 的区别，什么时候可以用==
**问题：** === 和 == 的区别，什么时候可以用==

### 解答

#### == (相等运算符)
- 比较前会进行类型转换
- 转换后再比较值

```javascript
1 == '1'        // true
0 == false      // true
null == undefined  // true
[] == false     // true
'' == 0         // true
```

#### === (严格相等运算符)
- 不进行类型转换
- 类型和值都必须相同

```javascript
1 === '1'       // false
0 === false     // false
null === undefined  // false
[] === false    // false
'' === 0        // false
```

#### 类型转换规则（==）

**1. null和undefined**
```javascript
null == undefined  // true
null == 0         // false
undefined == 0    // false
```

**2. 数字和字符串**
```javascript
1 == '1'      // true，字符串转数字
'1' == true   // true，布尔转数字，字符串转数字
```

**3. 布尔值**
```javascript
true == 1     // true，布尔转数字
false == 0    // true，布尔转数字
true == '1'   // true
false == ''   // true
```

**4. 对象和原始值**
```javascript
[1] == 1      // true，对象转原始值
[1, 2] == '1,2'  // true
({}) == '[object Object]'  // true
```

#### 使用建议

**推荐使用===**
```javascript
// ✅ 使用===
if (value === null) {}
if (value === undefined) {}
if (value === 0) {}
```

**少数使用==的场景**
```javascript
// 检查null或undefined
if (value == null) {
  // value是null或undefined
}
// 等价于
if (value === null || value === undefined) {}

// ESLint配置允许这种情况
{
  "rules": {
    "eqeqeq": ["error", "always", { "null": "ignore" }]
  }
}
```

**避免使用==**
```javascript
// ❌ 容易出错
if (value == true) {}    // 使用 if (value)
if (value == false) {}   // 使用 if (!value)
if (value == 0) {}       // 使用 if (value === 0)
if (value == '') {}      // 使用 if (value === '')
```

#### 特殊情况

**NaN**
```javascript
NaN == NaN   // false
NaN === NaN  // false
Object.is(NaN, NaN)  // true
Number.isNaN(NaN)    // true
```

**+0和-0**
```javascript
+0 == -0    // true
+0 === -0   // true
Object.is(+0, -0)  // false
```

**Object.is()**
```javascript
// 更严格的相等比较
Object.is(NaN, NaN)   // true
Object.is(+0, -0)     // false
Object.is(null, undefined)  // false
```
