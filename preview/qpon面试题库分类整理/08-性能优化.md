# 性能优化

## 1. 性能优化
**问题：** 考察性能优化，不同宿主下各类型资源的性能优化，结合特定逻辑场景考察资源性能优化处理，设计系统的优化方案，关注有成熟的性能优化方法论

**考察要点：** 考察对性能优化的系统性理解，不同宿主下各类型资源的性能优化策略，结合特定逻辑场景考察资源性能优化处理，设计系统的优化方案，关注是否有成熟的性能优化方法论

### 深度解析

#### 实战案例：电商首页优化全流程

**初始状态（问题诊断）：**
```javascript
// Performance指标
初始状态：
- FCP (First Contentful Paint): 3.2s
- LCP (Largest Contentful Paint): 5.8s
- TTI (Time to Interactive): 6.5s
- FID (First Input Delay): 350ms
- CLS (Cumulative Layout Shift): 0.25
- Bundle大小：2.8MB (gzip后800KB)
- Lighthouse评分：45/100

问题分析：
1. 首屏bundle过大，包含所有路由代码
2. 图片未优化，首屏加载20张大图
3. 第三方库体积大（moment.js 200KB, lodash 70KB）
4. 未使用CDN
5. 没有缓存策略
6. 大量同步阻塞脚本
```

**第一步：Bundle分析和代码分割**
```javascript
// webpack-bundle-analyzer分析结果
主要问题：
- moment.js: 228KB (实际只用了format功能)
- lodash: 72KB (整体引入但只用3个方法)
- echarts: 890KB (所有图表类型都打包了)
- 所有路由组件都在主bundle中

// 优化方案
// 1. 替换moment.js为day.js
import dayjs from 'dayjs'; // 仅2KB
// 节省：226KB

// 2. lodash按需引入
// ❌ import _ from 'lodash';
// ✅ import { debounce, throttle, cloneDeep } from 'lodash-es';
// 节省：60KB

// 3. echarts按需加载
import * as echarts from 'echarts/core';
import { BarChart, LineChart } from 'echarts/charts';
import { CanvasRenderer } from 'echarts/renderers';
echarts.use([BarChart, LineChart, CanvasRenderer]);
// 节省：650KB

// 4. 路由懒加载
const routes = [
  {
    path: '/',
    component: () => import(/* webpackChunkName: "home" */ './views/Home.vue')
  },
  {
    path: '/product/:id',
    component: () => import(/* webpackChunkName: "product" */ './views/Product.vue')
  },
  {
    path: '/cart',
    component: () => import(/* webpackChunkName: "cart" */ './views/Cart.vue')
  }
];

// 5. 代码分割配置
// webpack.config.js
optimization: {
  splitChunks: {
    chunks: 'all',
    cacheGroups: {
      // 分离Vue全家桶
      vue: {
        test: /[\\/]node_modules[\\/](vue|vue-router|vuex)[\\/]/,
        name: 'vue-vendor',
        priority: 20
      },
      // 分离UI框架
      ui: {
        test: /[\\/]node_modules[\\/](element-plus|@element-plus)[\\/]/,
        name: 'ui-vendor',
        priority: 15
      },
      // 其他第三方库
      vendors: {
        test: /[\\/]node_modules[\\/]/,
        name: 'vendors',
        priority: 10
      },
      // 公共代码
      common: {
        minChunks: 2,
        priority: 5,
        reuseExistingChunk: true
      }
    }
  }
}

// 优化效果：
Bundle大小：2.8MB → 850KB（主bundle 180KB + 按需chunks）
首屏加载：180KB（gzip后 60KB）
节省：70%的体积
```

**第二步：图片优化**
```javascript
// 问题：首屏20张商品图，每张200-500KB，总计6MB
// 优化策略：

// 1. 图片压缩 + WebP格式
<picture>
  <source srcset="/images/product-1.webp" type="image/webp">
  <img src="/images/product-1.jpg" loading="lazy" alt="商品1">
</picture>
// WebP比JPEG小30-50%
// 效果：6MB → 2.5MB

// 2. 响应式图片
<img
  srcset="
    /images/product-small.jpg 400w,
    /images/product-medium.jpg 800w,
    /images/product-large.jpg 1200w
  "
  sizes="(max-width: 768px) 400px, 800px"
  src="/images/product-medium.jpg"
  loading="lazy"
>
// 移动端加载小图
// 效果：移动端从2.5MB → 800KB

// 3. 懒加载（Intersection Observer）
const imageObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      img.srcset = img.dataset.srcset;
      imageObserver.unobserve(img);
    }
  });
}, {
  rootMargin: '50px' // 提前50px加载
});

document.querySelectorAll('img[data-src]').forEach(img => {
  imageObserver.observe(img);
});

// 4. CDN加速
<img src="https://cdn.example.com/images/product-1.webp">
// CDN响应时间：从800ms → 150ms

// 最终效果：
首屏图片加载：
- 之前：20张图 × 300KB = 6MB，加载时间4.5s
- 之后：首屏可见5张 × 40KB（WebP+压缩）= 200KB，加载时间0.8s
- 节省：95%的加载时间
```

**第三步：关键渲染路径优化**
```html
<!-- 优化前：阻塞渲染 -->
<head>
  <link rel="stylesheet" href="main.css">
  <script src="vue.js"></script>
  <script src="app.js"></script>
</head>

<!-- 优化后：优先关键资源 -->
<head>
  <!-- 1. DNS预解析 -->
  <link rel="dns-prefetch" href="//cdn.example.com">

  <!-- 2. 预连接CDN -->
  <link rel="preconnect" href="//cdn.example.com">

  <!-- 3. 预加载关键字体 -->
  <link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>

  <!-- 4. 内联关键CSS（首屏样式） -->
  <style>
    /* 首屏关键CSS，约10KB */
    .header { ... }
    .banner { ... }
    .product-list { ... }
  </style>

  <!-- 5. 异步加载非关键CSS -->
  <link rel="preload" href="/css/main.css" as="style" onload="this.onload=null;this.rel='stylesheet'">

  <!-- 6. 脚本异步加载 -->
  <script defer src="https://cdn.example.com/vue@3.js"></script>
  <script defer src="/js/app.js"></script>
</head>

<!-- 效果：
- FCP: 3.2s → 1.2s（提升62%）
- 首屏渲染完整度：从空白到立即看到内容
-->
```

**第四步：缓存策略**
```javascript
// Nginx配置
location ~* \.(js|css|png|jpg|jpeg|gif|webp|svg|woff2)$ {
  # 静态资源强缓存1年
  expires 1y;
  add_header Cache-Control "public, immutable";
}

location ~* \.(html)$ {
  # HTML协商缓存
  add_header Cache-Control "no-cache";
  etag on;
}

// Webpack配置：contenthash
output: {
  filename: 'js/[name].[contenthash:8].js',
  chunkFilename: 'js/[name].[contenthash:8].chunk.js'
}

// Service Worker缓存
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('v1').then(cache => {
      return cache.addAll([
        '/',
        '/js/vue-vendor.js',
        '/css/main.css',
        '/images/logo.png'
      ]);
    })
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then(response => {
      // 缓存优先，失败才网络请求
      return response || fetch(event.request);
    })
  );
});

// 效果：
二次访问速度：
- 之前：3.2s
- 之后：0.4s（命中缓存）
- 提升：88%
```

**第五步：运行时性能优化**
```javascript
// 1. 长列表虚拟滚动
// 问题：商品列表1000个商品，页面卡顿

// 优化前
<div v-for="product in products" :key="product.id">
  <ProductCard :product="product" />
</div>
// 1000个DOM节点，滚动FPS: 15-20

// 优化后：react-window
import { FixedSizeList } from 'react-window';

<FixedSizeList
  height={600}
  itemCount={products.length}
  itemSize={200}
  width="100%"
>
  {({ index, style }) => (
    <div style={style}>
      <ProductCard product={products[index]} />
    </div>
  )}
</FixedSizeList>

// 效果：
- DOM节点：1000 → 20（只渲染可见区域）
- 内存占用：320MB → 45MB
- 滚动FPS：15-20 → 60
- 首次渲染：2800ms → 120ms

// 2. 防抖搜索
const handleSearch = debounce((keyword) => {
  fetch(`/api/search?q=${keyword}`);
}, 300);

// 3. 图片懒加载 + 占位图
<img
  src="data:image/svg+xml,..." // 10KB占位SVG
  data-src="/images/product.jpg"
  loading="lazy"
>

// 避免CLS（累积布局偏移）
<img
  src="placeholder.jpg"
  width="400"
  height="300"
  style="aspect-ratio: 4/3"
>
```

**最终优化效果对比：**
```javascript
性能指标：
┌─────────────┬────────┬────────┬─────────┐
│   指标      │ 优化前 │ 优化后 │  提升   │
├─────────────┼────────┼────────┼─────────┤
│ FCP         │ 3.2s   │ 1.1s   │  66%    │
│ LCP         │ 5.8s   │ 1.8s   │  69%    │
│ TTI         │ 6.5s   │ 2.2s   │  66%    │
│ FID         │ 350ms  │ 45ms   │  87%    │
│ CLS         │ 0.25   │ 0.02   │  92%    │
│ Bundle大小  │ 2.8MB  │ 180KB  │  94%    │
│ Lighthouse  │ 45     │ 96     │ +113%   │
└─────────────┴────────┴────────┴─────────┘

业务指标：
- 跳出率：从45% → 18%（降低60%）
- 转化率：从2.3% → 4.1%（提升78%）
- 用户平均停留时间：从1.2分钟 → 3.8分钟（提升217%）

成本节省：
- CDN流量费：从$2000/月 → $800/月（节省60%）
- 服务器带宽：减少70%
```

#### 性能优化方法论（RAIL模型）

**R - Response（响应）**
```javascript
// 用户输入100ms内响应
// 示例：搜索框输入
const handleInput = (e) => {
  // 立即反馈UI
  setSearching(true);

  // 防抖后请求
  debouncedSearch(e.target.value);
};

// ✅ 用户看到立即反馈
// ✅ 减少不必要的请求
```

**A - Animation（动画）**
```javascript
// 每帧16ms内完成（60fps）
// ❌ 使用left触发重排
.box {
  left: 0;
  transition: left 0.3s;
}

// ✅ 使用transform只触发合成
.box {
  transform: translateX(0);
  transition: transform 0.3s;
}

// 效果：FPS从30提升到60
```

**I - Idle（空闲）**
```javascript
// 利用空闲时间处理非关键任务
requestIdleCallback((deadline) => {
  while (deadline.timeRemaining() > 0 && tasks.length > 0) {
    const task = tasks.shift();
    processTask(task);
  }
});

// 示例：预加载下一页数据
if ('requestIdleCallback' in window) {
  requestIdleCallback(() => {
    fetch('/api/products?page=2');
  });
}
```

**L - Load（加载）**
```javascript
// 5秒内加载并可交互
// 策略：
// 1. 关键资源优先（首屏内容）
// 2. 非关键资源延迟（广告、统计）
// 3. 预加载下一步资源

<link rel="preload" href="critical.css" as="style">
<link rel="prefetch" href="next-page.js">
```

#### 性能优化体系

#### 1. 加载性能优化

**资源压缩**
```javascript
// Webpack配置
module.exports = {
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true,  // 删除console
            drop_debugger: true  // 删除debugger
          }
        }
      }),
      new CssMinimizerPlugin()
    ]
  }
};
```

**代码分割**
```javascript
// 路由懒加载
const Home = () => import(/* webpackChunkName: "home" */ './Home');
const About = () => import(/* webpackChunkName: "about" */ './About');

// React.lazy
const LazyComponent = React.lazy(() => import('./LazyComponent'));

// Vue动态导入
const AsyncComponent = () => import('./AsyncComponent.vue');

// Webpack splitChunks
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10
        },
        common: {
          minChunks: 2,
          priority: 5,
          reuseExistingChunk: true
        }
      }
    }
  }
};
```

**Tree Shaking**
```javascript
// package.json
{
  "sideEffects": false  // 标记无副作用
}

// 或指定有副作用的文件
{
  "sideEffects": ["*.css", "*.scss"]
}

// ES6模块语法（支持Tree Shaking）
import { add } from './utils';  // ✅

// CommonJS（不支持Tree Shaking）
const { add } = require('./utils');  // ❌
```

**资源预加载**
```html
<!-- DNS预解析 -->
<link rel="dns-prefetch" href="//example.com">

<!-- 预连接 -->
<link rel="preconnect" href="//example.com">

<!-- 预加载 -->
<link rel="preload" href="style.css" as="style">
<link rel="preload" href="main.js" as="script">

<!-- 预获取 -->
<link rel="prefetch" href="next-page.js">
```

**CDN加速**
```javascript
// 使用CDN
module.exports = {
  externals: {
    'react': 'React',
    'react-dom': 'ReactDOM',
    'vue': 'Vue'
  }
};
```

```html
<!-- HTML中引入CDN -->
<script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
```

**Gzip压缩**
```javascript
// Webpack配置
const CompressionPlugin = require('compression-webpack-plugin');

module.exports = {
  plugins: [
    new CompressionPlugin({
      algorithm: 'gzip',
      test: /\.(js|css|html|svg)$/,
      threshold: 10240,  // 大于10KB才压缩
      minRatio: 0.8
    })
  ]
};

// Nginx配置
gzip on;
gzip_types text/plain text/css application/json application/javascript;
gzip_min_length 1000;
```

**图片优化**
```javascript
// 1. 图片压缩
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpe?g|gif)$/,
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 8192,  // 小于8KB转base64
              name: '[name].[hash:8].[ext]',
              outputPath: 'images'
            }
          },
          {
            loader: 'image-webpack-loader',
            options: {
              mozjpeg: { quality: 80 },
              pngquant: { quality: [0.65, 0.90] }
            }
          }
        ]
      }
    ]
  }
};

// 2. WebP格式
<picture>
  <source srcset="image.webp" type="image/webp">
  <img src="image.jpg" alt="fallback">
</picture>

// 3. 响应式图片
<img
  srcset="small.jpg 300w, medium.jpg 600w, large.jpg 1200w"
  sizes="(max-width: 300px) 300px, (max-width: 600px) 600px, 1200px"
  src="medium.jpg"
>

// 4. 懒加载
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      observer.unobserve(img);
    }
  });
});

document.querySelectorAll('img[data-src]').forEach(img => {
  observer.observe(img);
});
```

#### 2. 渲染性能优化

**虚拟滚动**
```javascript
// React
import { FixedSizeList } from 'react-window';

function VirtualList({ items }) {
  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {({ index, style }) => (
        <div style={style}>
          {items[index]}
        </div>
      )}
    </FixedSizeList>
  );
}
```

**防抖和节流**
```javascript
// 防抖：延迟执行
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 使用
const handleSearch = debounce((value) => {
  fetch(`/api/search?q=${value}`);
}, 300);

// 节流：限制频率
function throttle(fn, delay) {
  let last = 0;
  return function(...args) {
    const now = Date.now();
    if (now - last >= delay) {
      fn.apply(this, args);
      last = now;
    }
  };
}

// 使用
const handleScroll = throttle(() => {
  console.log('scrolling...');
}, 200);

window.addEventListener('scroll', handleScroll);
```

**requestAnimationFrame优化**
```javascript
// 使用RAF代替setTimeout
function animate() {
  // 动画逻辑
  element.style.transform = `translateX(${x}px)`;

  if (shouldContinue) {
    requestAnimationFrame(animate);
  }
}

requestAnimationFrame(animate);

// RAF节流
function rafThrottle(fn) {
  let rafId = null;
  return function(...args) {
    if (rafId) return;
    rafId = requestAnimationFrame(() => {
      fn.apply(this, args);
      rafId = null;
    });
  };
}
```

**CSS优化**
```css
/* 1. 使用GPU加速 */
.element {
  transform: translateZ(0);
  will-change: transform;
}

/* 2. 避免强制同步布局 */
/* ❌ */
element.style.width = element.offsetWidth + 10 + 'px';

/* ✅ */
const width = element.offsetWidth;
element.style.width = width + 10 + 'px';

/* 3. 使用transform代替top/left */
/* ❌ */
.element {
  position: absolute;
  left: 100px;
  transition: left 0.3s;
}

/* ✅ */
.element {
  transform: translateX(100px);
  transition: transform 0.3s;
}

/* 4. 减少重排重绘 */
.element {
  /* 只触发重绘 */
  color: red;
  background: blue;

  /* 触发重排 */
  width: 100px;
  margin: 10px;
}
```

**Web Worker**
```javascript
// main.js
const worker = new Worker('worker.js');

worker.postMessage({ data: largeArray });

worker.onmessage = (e) => {
  console.log('结果:', e.data);
};

// worker.js
self.onmessage = (e) => {
  const result = heavyComputation(e.data);
  self.postMessage(result);
};

function heavyComputation(data) {
  // 复杂计算
  return processedData;
}
```

#### 3. 缓存优化

**HTTP缓存**
```javascript
// 强缓存
Cache-Control: max-age=31536000  // 1年

// 协商缓存
ETag: "abc123"
Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT

// Webpack配置contenthash
module.exports = {
  output: {
    filename: '[name].[contenthash:8].js',
    chunkFilename: '[name].[contenthash:8].chunk.js'
  }
};
```

**Service Worker缓存**
```javascript
// sw.js
const CACHE_NAME = 'v1';
const urlsToCache = [
  '/',
  '/styles/main.css',
  '/script/main.js'
];

// 安装
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

// 拦截请求
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // 缓存命中
        if (response) {
          return response;
        }
        // 网络请求
        return fetch(event.request);
      })
  );
});
```

**LocalStorage/IndexedDB**
```javascript
// LocalStorage（小数据）
localStorage.setItem('user', JSON.stringify(user));
const user = JSON.parse(localStorage.getItem('user'));

// IndexedDB（大数据）
const request = indexedDB.open('MyDatabase', 1);

request.onsuccess = (event) => {
  const db = event.target.result;
  const transaction = db.transaction(['users'], 'readwrite');
  const store = transaction.objectStore('users');
  store.add({ id: 1, name: 'John' });
};
```

#### 4. 网络优化

**HTTP/2**
- 多路复用
- 服务器推送
- 头部压缩

**资源优先级**
```html
<!-- 高优先级 -->
<link rel="preload" href="critical.css" as="style">

<!-- 低优先级 -->
<link rel="prefetch" href="future.js">
```

**接口优化**
```javascript
// 1. 接口合并
// ❌ 多次请求
Promise.all([
  fetch('/api/user'),
  fetch('/api/posts'),
  fetch('/api/comments')
]);

// ✅ 批量请求
fetch('/api/batch', {
  method: 'POST',
  body: JSON.stringify({
    requests: ['user', 'posts', 'comments']
  })
});

// 2. GraphQL
query {
  user {
    name
    posts {
      title
    }
  }
}

// 3. 接口缓存
const cache = new Map();

async function fetchWithCache(url) {
  if (cache.has(url)) {
    return cache.get(url);
  }

  const data = await fetch(url).then(res => res.json());
  cache.set(url, data);
  return data;
}
```

#### 5. 监控和分析

**Performance API**
```javascript
// 获取性能指标
const perfData = performance.getEntriesByType('navigation')[0];
console.log('DNS查询:', perfData.domainLookupEnd - perfData.domainLookupStart);
console.log('TCP连接:', perfData.connectEnd - perfData.connectStart);
console.log('DOM解析:', perfData.domComplete - perfData.domLoading);

// FCP (First Contentful Paint)
new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.name === 'first-contentful-paint') {
      console.log('FCP:', entry.startTime);
    }
  }
}).observe({ entryTypes: ['paint'] });

// LCP (Largest Contentful Paint)
new PerformanceObserver((list) => {
  const entries = list.getEntries();
  const lastEntry = entries[entries.length - 1];
  console.log('LCP:', lastEntry.renderTime || lastEntry.loadTime);
}).observe({ entryTypes: ['largest-contentful-paint'] });
```

**Lighthouse**
```bash
# 安装
npm install -g lighthouse

# 运行
lighthouse https://example.com --view

# CI集成
lighthouse https://example.com --output json --output-path ./report.json
```

**性能指标**
- **FCP (First Contentful Paint)**: 首次内容绘制
- **LCP (Largest Contentful Paint)**: 最大内容绘制
- **FID (First Input Delay)**: 首次输入延迟
- **TTI (Time to Interactive)**: 可交互时间
- **CLS (Cumulative Layout Shift)**: 累积布局偏移

## 2. 无限制动加载实现，这种加载不能产生太多没必要的加载
**问题：** 无限滚动加载实现，如何避免不必要的加载

### 解答

#### 方案1：Intersection Observer
```javascript
function InfiniteScroll({ loadMore, hasMore }) {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);
  const loaderRef = useRef(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        const target = entries[0];
        if (target.isIntersecting && hasMore && !loading) {
          setLoading(true);
          loadMore()
            .then(newItems => {
              setItems(prev => [...prev, ...newItems]);
            })
            .finally(() => {
              setLoading(false);
            });
        }
      },
      {
        root: null,
        rootMargin: '100px',  // 提前100px触发
        threshold: 0.1
      }
    );

    if (loaderRef.current) {
      observer.observe(loaderRef.current);
    }

    return () => {
      if (loaderRef.current) {
        observer.unobserve(loaderRef.current);
      }
    };
  }, [loadMore, hasMore, loading]);

  return (
    <div>
      {items.map((item, index) => (
        <div key={index}>{item}</div>
      ))}
      {hasMore && <div ref={loaderRef}>加载中...</div>}
    </div>
  );
}
```

#### 方案2：节流+scroll监听
```javascript
function InfiniteScroll() {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const containerRef = useRef(null);

  const handleScroll = useCallback(
    throttle(() => {
      if (loading || !hasMore) return;

      const container = containerRef.current;
      const scrollTop = container.scrollTop;
      const scrollHeight = container.scrollHeight;
      const clientHeight = container.clientHeight;

      // 距离底部100px时触发
      if (scrollHeight - scrollTop - clientHeight < 100) {
        setLoading(true);

        fetch(`/api/items?page=${Math.ceil(items.length / 20)}`)
          .then(res => res.json())
          .then(data => {
            if (data.length === 0) {
              setHasMore(false);
            } else {
              setItems(prev => [...prev, ...data]);
            }
          })
          .finally(() => {
            setLoading(false);
          });
      }
    }, 200),
    [items, loading, hasMore]
  );

  useEffect(() => {
    const container = containerRef.current;
    container.addEventListener('scroll', handleScroll);

    return () => {
      container.removeEventListener('scroll', handleScroll);
    };
  }, [handleScroll]);

  return (
    <div ref={containerRef} style={{ height: '100vh', overflow: 'auto' }}>
      {items.map((item, index) => (
        <div key={index}>{item}</div>
      ))}
      {loading && <div>加载中...</div>}
      {!hasMore && <div>没有更多了</div>}
    </div>
  );
}
```

#### 优化策略

**1. 请求去重**
```javascript
let currentRequest = null;

async function loadMore() {
  // 防止重复请求
  if (currentRequest) {
    return currentRequest;
  }

  currentRequest = fetch('/api/items')
    .then(res => res.json())
    .finally(() => {
      currentRequest = null;
    });

  return currentRequest;
}
```

**2. 虚拟滚动（避免DOM过多）**
```javascript
import { FixedSizeList } from 'react-window';
import InfiniteLoader from 'react-window-infinite-loader';

function InfiniteVirtualList({ loadMore }) {
  const [items, setItems] = useState([]);
  const [hasMore, setHasMore] = useState(true);

  const isItemLoaded = index => index < items.length;

  const loadMoreItems = () => {
    if (!hasMore) return;

    return loadMore().then(newItems => {
      if (newItems.length === 0) {
        setHasMore(false);
      } else {
        setItems(prev => [...prev, ...newItems]);
      }
    });
  };

  return (
    <InfiniteLoader
      isItemLoaded={isItemLoaded}
      itemCount={hasMore ? items.length + 1 : items.length}
      loadMoreItems={loadMoreItems}
    >
      {({ onItemsRendered, ref }) => (
        <FixedSizeList
          height={600}
          itemCount={items.length}
          itemSize={50}
          onItemsRendered={onItemsRendered}
          ref={ref}
        >
          {({ index, style }) => (
            <div style={style}>
              {items[index] || '加载中...'}
            </div>
          )}
        </FixedSizeList>
      )}
    </InfiniteLoader>
  );
}
```

**3. 分页缓存**
```javascript
const cache = new Map();

async function loadPage(page) {
  if (cache.has(page)) {
    return cache.get(page);
  }

  const data = await fetch(`/api/items?page=${page}`).then(res => res.json());
  cache.set(page, data);

  // 限制缓存大小
  if (cache.size > 10) {
    const firstKey = cache.keys().next().value;
    cache.delete(firstKey);
  }

  return data;
}
```

**4. 预加载**
```javascript
function InfiniteScroll() {
  const [currentPage, setCurrentPage] = useState(1);

  useEffect(() => {
    // 预加载下一页
    if (hasMore) {
      loadPage(currentPage + 1);
    }
  }, [currentPage, hasMore]);

  // ...
}
```
