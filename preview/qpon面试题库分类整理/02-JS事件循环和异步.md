# JS事件循环和异步（深度版）

## 1. JS的事件循环机制
**问题：** 详细解释JS的事件循环机制

### 深度解析

#### 为什么JavaScript需要事件循环？

JavaScript设计为单线程语言的根本原因：
1. **避免DOM操作冲突**：多线程同时操作DOM会导致竞态条件
2. **简化编程模型**：单线程模型更容易理解和调试
3. **历史原因**：最初JavaScript只是用于简单的网页交互

但单线程带来问题：**如何处理耗时操作而不阻塞主线程？**

答案是：**事件循环 + 异步回调**

#### 事件循环的底层机制

```
┌───────────────────────────┐
│           同步代码         │ <- 执行栈
└─────────────┬─────────────┘
              ↓
┌─────────────────────────────────────┐
│         执行栈清空？                 │
└──────────┬─────────────────────┬────┘
           ↓ Yes                 ↓ No
┌──────────────────────┐   继续执行
│    检查微任务队列      │
└──────────┬───────────┘
           ↓
┌──────────────────────┐
│    执行所有微任务      │ <- 递归执行，直到微任务队列为空
└──────────┬───────────┘
           ↓
┌──────────────────────┐
│    渲染更新(如需要)    │ <- requestAnimationFrame
└──────────┬───────────┘
           ↓
┌──────────────────────┐
│   从宏任务队列取一个   │ <- 注意：只取一个
└──────────┬───────────┘
           ↓
回到执行栈，重复循环
```

#### 源码级理解

**V8引擎中的事件循环实现（简化版）：**

```cpp
// V8引擎的事件循环核心逻辑
void EventLoop::Run() {
  while (!should_stop_) {
    // 1. 执行同步代码
    RunMicrotasks();  // 执行微任务

    // 2. 检查是否需要渲染
    if (ShouldRender()) {
      PerformRender();
    }

    // 3. 处理一个宏任务
    Task* task = task_queue_.Dequeue();
    if (task) {
      task->Run();
      delete task;
    }

    // 4. 再次执行微任务
    RunMicrotasks();
  }
}

void EventLoop::RunMicrotasks() {
  while (!microtask_queue_.IsEmpty()) {
    Microtask* microtask = microtask_queue_.Dequeue();
    microtask->Run();
    delete microtask;
  }
}
```

#### 深入理解微任务

**为什么微任务优先级更高？**

```javascript
// 微任务的设计目的：确保在下一个宏任务前完成状态更新
Promise.resolve().then(() => {
  console.log('微任务1');

  // 嵌套的微任务也会在当前循环执行
  Promise.resolve().then(() => {
    console.log('微任务2');
  });
});

setTimeout(() => {
  console.log('宏任务');
}, 0);

// 输出：微任务1 -> 微任务2 -> 宏任务
```

**微任务的实际应用场景：**

```javascript
// Vue的nextTick就是利用微任务实现的
Vue.prototype.$nextTick = function(callback) {
  // 优先使用Promise（微任务）
  if (typeof Promise !== 'undefined') {
    return Promise.resolve().then(callback);
  }
  // 降级到setTimeout（宏任务）
  return setTimeout(callback, 0);
};

// 为什么要用微任务？
// 因为微任务能在本次事件循环内完成，确保DOM更新后立即执行回调
this.message = 'new value';
this.$nextTick(() => {
  // 这里能获取到更新后的DOM
  console.log(this.$el.textContent); // 'new value'
});
```

#### 事件循环中的陷阱

**陷阱1：微任务递归导致饿死宏任务**

```javascript
// ❌ 错误示例：微任务无限递归
function recursiveMicrotask() {
  Promise.resolve().then(() => {
    console.log('微任务');
    recursiveMicrotask(); // 无限递归
  });
}

recursiveMicrotask();

// 后果：宏任务永远不会执行，页面卡死
setTimeout(() => {
  console.log('这句话永远不会执行');
}, 0);
```

**陷阱2：setTimeout(0)并不是0ms**

```javascript
// setTimeout最小延迟不是0ms
setTimeout(() => {
  console.log('setTimeout');
}, 0);

// 实际延迟：
// - 浏览器：4ms（HTML5规范）
// - Node.js：1ms

// 原因：防止CPU过度占用
```

#### 浏览器 vs Node.js 的事件循环差异

**浏览器事件循环：**
```
宏任务 -> 所有微任务 -> 渲染 -> 宏任务 -> ...
```

**Node.js事件循环（更复杂）：**
```
┌─────────────────────────┐
│        timers           │ <- setTimeout/setInterval
├─────────────────────────┤
│     pending callbacks   │ <- I/O回调
├─────────────────────────┤
│       idle, prepare     │ <- 内部使用
├─────────────────────────┤
│         poll            │ <- I/O轮询
├─────────────────────────┤
│         check           │ <- setImmediate
├─────────────────────────┤
│      close callbacks    │ <- close事件
└─────────────────────────┘

每个阶段都有自己的微任务队列！
```

**Node.js的特殊情况：**

```javascript
// Node.js中的特殊行为
setTimeout(() => console.log('timeout'), 0);
setImmediate(() => console.log('immediate'));

// 输出顺序不确定！
// 取决于进入事件循环的时机

// 但在I/O回调中，顺序是确定的：
const fs = require('fs');
fs.readFile('file.txt', () => {
  setTimeout(() => console.log('timeout'), 0);
  setImmediate(() => console.log('immediate'));
  // 输出顺序：immediate -> timeout
});
```

#### 实战案例分析

**案例1：复杂的执行顺序**

```javascript
console.log('1');

setTimeout(() => {
  console.log('2');
  Promise.resolve().then(() => {
    console.log('3');
  });
}, 0);

new Promise((resolve) => {
  console.log('4');
  resolve();
}).then(() => {
  console.log('5');
  setTimeout(() => {
    console.log('6');
  }, 0);
}).then(() => {
  console.log('7');
});

console.log('8');

// 执行过程分析：
// 1. 同步代码：1, 4, 8
// 2. 微任务队列：[then1, then2] -> 输出: 5, 7
// 3. 宏任务队列：[setTimeout1, setTimeout2]
// 4. 执行setTimeout1 -> 输出: 2
// 5. 微任务队列：[then3] -> 输出: 3
// 6. 执行setTimeout2 -> 输出: 6

// 最终输出：1, 4, 8, 5, 7, 2, 3, 6
```

**案例2：性能优化中的应用**

```javascript
// 问题：大量DOM操作导致性能问题
function updateList(items) {
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    list.appendChild(li); // 每次都触发重排
  });
}

// 优化1：批量更新（利用事件循环）
function updateListOptimized(items) {
  const fragment = document.createDocumentFragment();
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    fragment.appendChild(li); // 不触发重排
  });
  list.appendChild(fragment); // 只触发一次重排
}

// 优化2：使用requestAnimationFrame
function updateListWithRAF(items) {
  requestAnimationFrame(() => {
    // 在下一帧渲染前批量更新
    updateListOptimized(items);
  });
}
```

## 2. async/await 的实现原理
**问题：** async/await的实现原理

### 深度解析

#### async/await的本质

async/await是**Generator + 自动执行器**的语法糖。

**从Generator到async/await的演进：**

```javascript
// 1. 回调地狱
getData(function(a) {
  getMoreData(a, function(b) {
    getMoreData(b, function(c) {
      console.log(c);
    });
  });
});

// 2. Promise链
getData()
  .then(a => getMoreData(a))
  .then(b => getMoreData(b))
  .then(c => console.log(c));

// 3. Generator + co库
const co = require('co');
co(function* () {
  const a = yield getData();
  const b = yield getMoreData(a);
  const c = yield getMoreData(b);
  console.log(c);
});

// 4. async/await（最终形态）
async function fetchData() {
  const a = await getData();
  const b = await getMoreData(a);
  const c = await getMoreData(b);
  console.log(c);
}
```

#### 手写async/await

**完整实现：**

```javascript
// async函数本质上是返回Promise的函数
function async(generatorFunc) {
  return function(...args) {
    const generator = generatorFunc.apply(this, args);

    return new Promise((resolve, reject) => {
      function step(key, arg) {
        let result;

        try {
          result = generator[key](arg);
        } catch (error) {
          return reject(error);
        }

        const { value, done } = result;

        if (done) {
          // Generator执行完毕
          return resolve(value);
        }

        // 将value包装成Promise
        return Promise.resolve(value).then(
          val => step('next', val),      // 成功继续执行
          err => step('throw', err)      // 失败抛出错误
        );
      }

      step('next');
    });
  };
}

// 使用示例
const asyncFunc = async(function* () {
  try {
    const result1 = yield Promise.resolve(1);
    console.log(result1); // 1

    const result2 = yield Promise.resolve(2);
    console.log(result2); // 2

    return 'done';
  } catch (error) {
    console.error(error);
  }
});

asyncFunc().then(value => console.log(value)); // 'done'
```

#### Babel转译后的代码

**ES7代码：**
```javascript
async function foo() {
  const result = await bar();
  return result;
}
```

**Babel转译后：**
```javascript
function _asyncToGenerator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function foo() {
  return _foo.apply(this, arguments);
}

function _foo() {
  _foo = _asyncToGenerator(function* () {
    const result = yield bar();
    return result;
  });
  return _foo.apply(this, arguments);
}
```

#### async/await的错误处理

**方式1：try-catch**
```javascript
async function fetchData() {
  try {
    const data = await fetch('/api/data');
    return data.json();
  } catch (error) {
    console.error('请求失败:', error);
    // 返回默认值或抛出自定义错误
    return { error: '数据加载失败' };
  }
}
```

**方式2：Promise catch**
```javascript
async function fetchData() {
  const data = await fetch('/api/data').catch(err => {
    console.error('请求失败:', err);
    return null;
  });

  if (!data) return;

  return data.json();
}
```

**方式3：统一错误处理（推荐）**
```javascript
// 包装函数
function to(promise) {
  return promise
    .then(data => [null, data])
    .catch(err => [err, null]);
}

// 使用
async function fetchData() {
  const [err, data] = await to(fetch('/api/data'));

  if (err) {
    console.error('请求失败:', err);
    return;
  }

  const [parseErr, json] = await to(data.json());

  if (parseErr) {
    console.error('解析失败:', parseErr);
    return;
  }

  return json;
}
```

#### async/await的性能陷阱

**陷阱1：串行变并行**

```javascript
// ❌ 错误：串行执行，耗时6秒
async function fetchAllData() {
  const user = await fetchUser();      // 3秒
  const posts = await fetchPosts();    // 3秒
  return { user, posts };
}

// ✅ 正确：并行执行，耗时3秒
async function fetchAllData() {
  const [user, posts] = await Promise.all([
    fetchUser(),    // 同时执行
    fetchPosts()    // 同时执行
  ]);
  return { user, posts };
}
```

**陷阱2：循环中的await**

```javascript
// ❌ 错误：串行处理，耗时N*延迟
async function processItems(items) {
  const results = [];
  for (const item of items) {
    const result = await processItem(item); // 等待每一个
    results.push(result);
  }
  return results;
}

// ✅ 正确：并行处理
async function processItems(items) {
  return Promise.all(
    items.map(item => processItem(item))
  );
}

// ✅ 需要控制并发数时
async function processItemsWithLimit(items, limit = 3) {
  const results = [];
  const executing = [];

  for (const item of items) {
    const promise = processItem(item).then(result => {
      executing.splice(executing.indexOf(promise), 1);
      return result;
    });

    results.push(promise);
    executing.push(promise);

    if (executing.length >= limit) {
      await Promise.race(executing);
    }
  }

  return Promise.all(results);
}
```

#### async/await与Generator的对比

| 特性 | Generator | async/await |
|-----|-----------|-------------|
| 返回值 | Iterator对象 | Promise对象 |
| 自动执行 | 需要手动next()或co库 | 自动执行 |
| 语义化 | yield关键字 | await关键字，更清晰 |
| 错误处理 | try-catch | try-catch |
| 用途 | 状态机、迭代器 | 异步流程控制 |

**Generator的独特优势：**

```javascript
// Generator可以实现惰性求值
function* fibonacci() {
  let [a, b] = [0, 1];
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

const fib = fibonacci();
console.log(fib.next().value); // 0
console.log(fib.next().value); // 1
console.log(fib.next().value); // 1
console.log(fib.next().value); // 2

// async/await无法实现这种无限序列
```

## 3. Promise深入理解
**问题：** Promise的深入理解和实现

### 深度解析

#### Promise的状态机

```
pending（进行中）
    ↓
    ├──→ fulfilled（已成功） → 不可逆
    └──→ rejected（已失败）  → 不可逆
```

**核心特点：**
1. 状态只能从pending变为fulfilled或rejected
2. 状态一旦改变，就不会再变
3. 即使Promise已经resolve/reject，仍可添加then

#### 手写符合Promises/A+规范的Promise

```javascript
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

class MyPromise {
  constructor(executor) {
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;

    // 存储成功和失败的回调
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];

    const resolve = (value) => {
      // 处理Promise解决另一个Promise的情况
      if (value instanceof MyPromise) {
        return value.then(resolve, reject);
      }

      // 状态只能改变一次
      if (this.status === PENDING) {
        this.status = FULFILLED;
        this.value = value;

        // 执行所有成功回调
        this.onFulfilledCallbacks.forEach(fn => fn());
      }
    };

    const reject = (reason) => {
      if (this.status === PENDING) {
        this.status = REJECTED;
        this.reason = reason;

        // 执行所有失败回调
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    };

    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }

  then(onFulfilled, onRejected) {
    // 参数校验，确保是函数
    onFulfilled = typeof onFulfilled === 'function'
      ? onFulfilled
      : value => value;

    onRejected = typeof onRejected === 'function'
      ? onRejected
      : reason => { throw reason };

    // 返回新的Promise，实现链式调用
    const promise2 = new MyPromise((resolve, reject) => {

      if (this.status === FULFILLED) {
        // 使用setTimeout模拟微任务
        setTimeout(() => {
          try {
            const x = onFulfilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        }, 0);
      }

      if (this.status === REJECTED) {
        setTimeout(() => {
          try {
            const x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        }, 0);
      }

      if (this.status === PENDING) {
        this.onFulfilledCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onFulfilled(this.value);
              resolvePromise(promise2, x, resolve, reject);
            } catch (error) {
              reject(error);
            }
          }, 0);
        });

        this.onRejectedCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onRejected(this.reason);
              resolvePromise(promise2, x, resolve, reject);
            } catch (error) {
              reject(error);
            }
          }, 0);
        });
      }
    });

    return promise2;
  }

  catch(onRejected) {
    return this.then(null, onRejected);
  }

  finally(callback) {
    return this.then(
      value => MyPromise.resolve(callback()).then(() => value),
      reason => MyPromise.resolve(callback()).then(() => { throw reason })
    );
  }

  static resolve(value) {
    if (value instanceof MyPromise) {
      return value;
    }
    return new MyPromise(resolve => resolve(value));
  }

  static reject(reason) {
    return new MyPromise((_, reject) => reject(reason));
  }

  static all(promises) {
    return new MyPromise((resolve, reject) => {
      const results = [];
      let completed = 0;

      promises.forEach((promise, index) => {
        MyPromise.resolve(promise).then(
          value => {
            results[index] = value;
            completed++;

            if (completed === promises.length) {
              resolve(results);
            }
          },
          reason => reject(reason)
        );
      });
    });
  }

  static race(promises) {
    return new MyPromise((resolve, reject) => {
      promises.forEach(promise => {
        MyPromise.resolve(promise).then(resolve, reject);
      });
    });
  }

  static allSettled(promises) {
    return new MyPromise(resolve => {
      const results = [];
      let completed = 0;

      promises.forEach((promise, index) => {
        MyPromise.resolve(promise).then(
          value => {
            results[index] = { status: 'fulfilled', value };
            completed++;

            if (completed === promises.length) {
              resolve(results);
            }
          },
          reason => {
            results[index] = { status: 'rejected', reason };
            completed++;

            if (completed === promises.length) {
              resolve(results);
            }
          }
        );
      });
    });
  }

  static any(promises) {
    return new MyPromise((resolve, reject) => {
      const errors = [];
      let rejected = 0;

      promises.forEach((promise, index) => {
        MyPromise.resolve(promise).then(
          value => resolve(value),
          reason => {
            errors[index] = reason;
            rejected++;

            if (rejected === promises.length) {
              reject(new AggregateError(errors, 'All promises were rejected'));
            }
          }
        );
      });
    });
  }
}

// Promise解决过程
function resolvePromise(promise2, x, resolve, reject) {
  // 防止循环引用
  if (promise2 === x) {
    return reject(new TypeError('Chaining cycle detected'));
  }

  let called = false;

  if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
    try {
      const then = x.then;

      if (typeof then === 'function') {
        // x是thenable对象
        then.call(
          x,
          y => {
            if (called) return;
            called = true;
            resolvePromise(promise2, y, resolve, reject);
          },
          r => {
            if (called) return;
            called = true;
            reject(r);
          }
        );
      } else {
        resolve(x);
      }
    } catch (error) {
      if (called) return;
      called = true;
      reject(error);
    }
  } else {
    resolve(x);
  }
}
```

#### Promise的高级应用

**重试机制：**
```javascript
function retry(fn, times = 3, delay = 1000) {
  return new Promise((resolve, reject) => {
    function attempt(n) {
      fn()
        .then(resolve)
        .catch(err => {
          if (n === 0) {
            reject(err);
          } else {
            console.log(`重试剩余次数: ${n}`);
            setTimeout(() => attempt(n - 1), delay);
          }
        });
    }
    attempt(times);
  });
}

// 使用
retry(() => fetch('/api/data'), 3, 1000)
  .then(data => console.log(data))
  .catch(err => console.error('最终失败:', err));
```

**超时控制：**
```javascript
function timeout(promise, ms) {
  return Promise.race([
    promise,
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error('timeout')), ms)
    )
  ]);
}

// 使用
timeout(fetch('/api/data'), 5000)
  .then(data => console.log(data))
  .catch(err => console.error(err.message)); // 'timeout'
```

**并发控制：**
```javascript
class PromisePool {
  constructor(limit) {
    this.limit = limit;
    this.running = 0;
    this.queue = [];
  }

  async add(fn) {
    while (this.running >= this.limit) {
      await new Promise(resolve => this.queue.push(resolve));
    }

    this.running++;

    try {
      return await fn();
    } finally {
      this.running--;
      const resolve = this.queue.shift();
      if (resolve) resolve();
    }
  }
}

// 使用
const pool = new PromisePool(3);

const tasks = Array.from({ length: 10 }, (_, i) =>
  () => fetch(`/api/data/${i}`)
);

const results = await Promise.all(
  tasks.map(task => pool.add(task))
);
```
