# 开发语言

## 1. 基础HTML5/CSS3/JS常见语法、编码风格、代码性能优化
**问题：** 基础HTML5/CSS3/JS常见语法、编码风格、代码性能优化、基础各浏览器兼容性处理、跨域问题、进阶ES6/ES7、CSS3等

### HTML5新特性
- 语义化标签：`<header>`, `<nav>`, `<article>`, `<section>`, `<aside>`, `<footer>`
- 表单新类型：email, url, number, range, date, color等
- Canvas和SVG绘图
- Video和Audio多媒体
- 地理定位API：Geolocation
- Web Storage：localStorage、sessionStorage
- Web Workers
- WebSocket

### CSS3新特性
```css
/* 圆角 */
border-radius: 10px;

/* 阴影 */
box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
text-shadow: 1px 1px 2px #000;

/* 渐变 */
background: linear-gradient(to right, red, blue);

/* 过渡 */
transition: all 0.3s ease;

/* 动画 */
@keyframes slideIn {
  from { transform: translateX(-100%); }
  to { transform: translateX(0); }
}
animation: slideIn 0.5s;

/* 弹性布局 */
display: flex;
justify-content: center;
align-items: center;

/* 网格布局 */
display: grid;
grid-template-columns: repeat(3, 1fr);
```

### ES6/ES7新特性
```javascript
// let和const
let name = 'John';
const PI = 3.14;

// 箭头函数
const add = (a, b) => a + b;

// 解构赋值
const { name, age } = person;
const [first, second] = array;

// 模板字符串
const greeting = `Hello, ${name}!`;

// 默认参数
function greet(name = 'Guest') {
  console.log(`Hello, ${name}`);
}

// 展开运算符
const arr = [...arr1, ...arr2];
const obj = { ...obj1, ...obj2 };

// Promise
fetch('/api').then(res => res.json());

// async/await
async function getData() {
  const data = await fetch('/api');
  return data;
}

// Class类
class Person {
  constructor(name) {
    this.name = name;
  }
}

// 模块化
import { something } from './module';
export default MyComponent;

// ES7 Array.includes()
[1, 2, 3].includes(2); // true

// ES7 指数运算符
2 ** 3 === 8; // true

// ES8 async/await
// ES8 Object.values() / Object.entries()
Object.values({ a: 1, b: 2 }); // [1, 2]
Object.entries({ a: 1, b: 2 }); // [['a', 1], ['b', 2]]

// ES9 Rest/Spread属性
const { x, ...rest } = { x: 1, y: 2, z: 3 };

// ES10 Array.flat()
[1, [2, [3]]].flat(2); // [1, 2, 3]

// ES11 Optional Chaining
obj?.property?.subProperty;

// ES11 Nullish Coalescing
const value = nullValue ?? 'default';
```

### 跨域解决方案
```javascript
// 1. JSONP
function jsonp(url, callback) {
  const script = document.createElement('script');
  script.src = `${url}?callback=${callback}`;
  document.body.appendChild(script);
}

// 2. CORS（服务器设置）
// Access-Control-Allow-Origin: *
// Access-Control-Allow-Methods: GET, POST, PUT, DELETE
// Access-Control-Allow-Headers: Content-Type

// 3. 代理服务器
// 使用Node.js或Nginx作为代理

// 4. postMessage
window.postMessage(data, targetOrigin);
window.addEventListener('message', (e) => {
  console.log(e.data);
});

// 5. WebSocket
const socket = new WebSocket('ws://example.com');
```

### 性能优化
```javascript
// 1. 防抖
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

// 2. 节流
function throttle(fn, delay) {
  let last = 0;
  return function(...args) {
    const now = Date.now();
    if (now - last >= delay) {
      fn.apply(this, args);
      last = now;
    }
  };
}

// 3. 懒加载
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      observer.unobserve(img);
    }
  });
});

// 4. 虚拟滚动
// 只渲染可见区域的内容

// 5. 代码分割
import(/* webpackChunkName: "lodash" */ 'lodash');
```

## 2. 描述BFC及应用场景
**问题：** 描述BFC及应用场景

### 解答

#### BFC（Block Formatting Context）块级格式化上下文

**定义：** BFC是一个独立的渲染区域，内部元素的布局不会影响外部元素。

#### 触发BFC的条件
- 根元素（html）
- float不为none
- position为absolute或fixed
- display为inline-block、table-cell、table-caption、flex、inline-flex
- overflow不为visible

#### BFC的特性
1. 内部的Box会在垂直方向上一个接一个放置
2. 垂直方向的距离由margin决定，同一个BFC的相邻Box的margin会重叠
3. BFC区域不会与浮动元素重叠
4. BFC是一个独立容器，内外元素互不影响
5. 计算BFC高度时，浮动元素也参与计算

#### 应用场景

**1. 清除浮动**
```css
.parent {
  overflow: hidden; /* 触发BFC */
}
.child {
  float: left;
}
```

**2. 防止margin重叠**
```css
.wrapper {
  overflow: hidden; /* 触发BFC */
}
```

**3. 自适应两栏布局**
```css
.left {
  float: left;
  width: 200px;
}
.right {
  overflow: hidden; /* 触发BFC，不会与浮动元素重叠 */
}
```

**4. 防止元素被浮动元素覆盖**
```css
.float {
  float: left;
}
.content {
  overflow: hidden; /* 触发BFC */
}
```

## 3. for循环和forEach循环的性能差异
**问题：** for循环和forEach循环的性能差异

### 解答

#### 性能对比
```javascript
const arr = new Array(1000000).fill(1);

// for循环
console.time('for');
for (let i = 0; i < arr.length; i++) {
  const item = arr[i];
}
console.timeEnd('for'); // 约3ms

// forEach循环
console.time('forEach');
arr.forEach(item => {
  const val = item;
});
console.timeEnd('forEach'); // 约15ms
```

#### 差异分析

**1. 性能差异**
- for循环更快，约为forEach的5倍
- forEach需要创建函数上下文，有额外开销

**2. 灵活性**
- for循环可以使用break、continue
- forEach不能中断循环

**3. 作用域**
- for循环使用块级作用域
- forEach每次迭代都是函数作用域

**4. 适用场景**
- 性能要求高：使用for循环
- 代码可读性优先：使用forEach
- 需要中断循环：使用for循环
- 链式调用：使用forEach

#### 其他循环方式对比
```javascript
// for...of（ES6）
for (const item of arr) {
  console.log(item);
}

// for...in（不推荐用于数组）
for (const index in arr) {
  console.log(arr[index]);
}

// map（会返回新数组）
const newArr = arr.map(item => item * 2);

// some、every（可以中断）
arr.some(item => item > 5); // 找到就返回true并中断
arr.every(item => item > 0); // 全部满足返回true

// find、filter
arr.find(item => item > 5); // 返回第一个匹配项
arr.filter(item => item > 5); // 返回所有匹配项
```

## 4. import和require的区别
**问题：** import和require的区别

### 解答

#### require（CommonJS）
```javascript
// 导出
module.exports = { name: 'John' };
// 或
exports.name = 'John';

// 导入
const module = require('./module');
```

#### import（ES6 Modules）
```javascript
// 导出
export const name = 'John';
export default MyComponent;

// 导入
import MyComponent, { name } from './module';
```

#### 主要区别

| 特性 | require | import |
|-----|---------|--------|
| 规范 | CommonJS | ES6 Modules |
| 加载时机 | 运行时动态加载 | 编译时静态加载 |
| 加载方式 | 同步加载 | 异步加载 |
| 输出 | 值的拷贝 | 值的引用 |
| 缓存 | 会缓存 | 会缓存 |
| this指向 | 当前模块 | undefined |
| 使用环境 | Node.js | 浏览器、Node.js(需配置) |

#### 详细说明

**1. 加载时机**
```javascript
// require：运行时加载
if (condition) {
  const module = require('./module'); // 可以
}

// import：编译时加载
if (condition) {
  import module from './module'; // 错误！必须在顶层
}
```

**2. 输出差异**
```javascript
// require：值的拷贝
// module.js
let count = 1;
module.exports = { count };

// main.js
const { count } = require('./module');
console.log(count); // 1
// module中的count变化，不影响这里的count

// import：值的引用
// module.js
export let count = 1;
export function increment() {
  count++;
}

// main.js
import { count, increment } from './module';
console.log(count); // 1
increment();
console.log(count); // 2，实时反映变化
```

**3. 动态导入**
```javascript
// require：原生支持动态导入
const moduleName = './module';
const module = require(moduleName);

// import：需要使用动态import()
const moduleName = './module';
import(moduleName).then(module => {
  console.log(module);
});
```

**4. Tree Shaking**
- import支持Tree Shaking（删除未使用的代码）
- require不支持Tree Shaking
