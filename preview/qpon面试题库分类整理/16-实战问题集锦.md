# 实战问题集锦

## 1. 如何应用/应用场景/使用过的技术栈
**问题：** 介绍一下你使用过的技术栈，如何在实际项目中应用的？

**考察要点：** 项目经验、技术广度、实际应用能力

### 解答思路

#### 技术栈介绍框架

**前端框架层**
- Vue.js 2/3 或 React.js
- 状态管理：Vuex/Pinia 或 Redux/MobX
- 路由管理：Vue Router 或 React Router
- UI组件库：Element Plus、Ant Design、Vant等

**工程化工具**
- 构建工具：Webpack、Vite
- 包管理器：npm、yarn、pnpm
- 代码规范：ESLint、Prettier
- 版本管理：Git、GitFlow

**前端基础**
- HTML5、CSS3、JavaScript(ES6+)
- CSS预处理器：Sass、Less
- TypeScript

**性能优化**
- 代码分割、懒加载
- 图片优化、CDN加速
- 缓存策略

**项目示例回答：**
```
"我在上一个电商项目中使用Vue3 + TypeScript技术栈：

1. 技术选型：
   - 使用Vue3 Composition API提升代码复用性
   - Pinia进行状态管理，解决组件间通信
   - Vite作为构建工具，提升开发体验
   - Element Plus作为UI组件库

2. 性能优化：
   - 路由懒加载减少首屏加载时间
   - 虚拟滚动处理长列表，提升渲染性能
   - 使用CDN加速静态资源
   - 实现骨架屏提升用户体验

3. 工程化实践：
   - 统一代码规范（ESLint + Prettier）
   - 使用Git Hooks进行代码提交前检查
   - 配置CI/CD自动化部署

4. 具体成果：
   - 首屏加载时间从3s优化到1.2s
   - 列表滚动FPS从30提升到60
   - 代码质量显著提升，bug率降低40%"
```

## 2. 你在项目中遇到过什么难点？如何解决的？

**考察要点：** 问题解决能力、技术深度、思维方式

### 经典问题场景

#### 场景1：性能优化问题

**问题描述：**
```
"在开发一个数据可视化大屏项目时，页面需要实时渲染大量图表，
导致页面卡顿，帧率下降到10-15fps，用户体验很差。"
```

**解决方案：**
```
1. 问题分析：
   - 使用Chrome DevTools Performance分析
   - 发现主要问题：频繁的DOM更新和大量重排重绘

2. 优化措施：
   a) 数据层优化
      - 使用Web Worker处理数据计算
      - 实现数据节流，控制更新频率

   b) 渲染层优化
      - 使用Canvas代替DOM渲染密集图表
      - 实现虚拟滚动减少DOM节点
      - 使用requestAnimationFrame优化动画

   c) 内存优化
      - 及时销毁不用的图表实例
      - 使用对象池复用对象

3. 优化结果：
   - 帧率提升到55-60fps
   - 内存占用降低50%
   - CPU占用率从80%降到30%
```

#### 场景2：跨域问题

**问题描述：**
```
"前后端分离项目，开发环境本地调试时遇到跨域问题，
生产环境需要调用第三方API也存在跨域限制。"
```

**解决方案：**
```
1. 开发环境：
   // vue.config.js
   module.exports = {
     devServer: {
       proxy: {
         '/api': {
           target: 'http://backend-server.com',
           changeOrigin: true,
           pathRewrite: {
             '^/api': ''
           }
         }
       }
     }
   };

2. 生产环境：
   - 方案A：Nginx反向代理
     location /api/ {
       proxy_pass http://backend-server.com/;
       add_header Access-Control-Allow-Origin *;
     }

   - 方案B：后端配置CORS
     app.use(cors({
       origin: ['https://frontend.com'],
       credentials: true
     }));

3. 第三方API：
   - 通过自己的后端服务转发请求
   - 避免在前端直接调用
```

#### 场景3：内存泄漏

**问题描述：**
```
"单页应用长时间使用后，内存占用持续增长，
最终导致页面卡顿甚至崩溃。"
```

**解决方案：**
```
1. 定位问题：
   - 使用Chrome DevTools Memory分析
   - 拍摄多个时间点的堆快照对比
   - 发现大量定时器和事件监听器未清理

2. 解决措施：
   // Vue组件
   export default {
     data() {
       return {
         timer: null
       };
     },

     mounted() {
       // 添加事件监听
       this.timer = setInterval(() => {
         this.fetchData();
       }, 3000);

       window.addEventListener('resize', this.handleResize);
     },

     beforeUnmount() {
       // 清理定时器
       if (this.timer) {
         clearInterval(this.timer);
         this.timer = null;
       }

       // 移除事件监听
       window.removeEventListener('resize', this.handleResize);
     }
   };

3. 预防措施：
   - 使用WeakMap存储临时数据
   - 及时清理全局变量和缓存
   - 避免闭包中引用大对象
```

#### 场景4：首屏加载慢

**问题描述：**
```
"项目打包后bundle体积过大，首屏加载时间超过5秒，
白屏时间长，用户体验差。"
```

**解决方案：**
```
1. 分析问题：
   - webpack-bundle-analyzer分析包体积
   - 发现问题：
     * moment.js占用200KB
     * lodash整体引入占用70KB
     * 路由未做代码分割

2. 优化方案：
   a) 依赖优化
      // ❌ 引入整个库
      import moment from 'moment';
      import _ from 'lodash';

      // ✅ 按需引入
      import dayjs from 'dayjs'; // 只有2KB
      import { debounce } from 'lodash-es';

   b) 路由懒加载
      const routes = [
        {
          path: '/home',
          component: () => import('@/views/Home.vue')
        },
        {
          path: '/about',
          component: () => import('@/views/About.vue')
        }
      ];

   c) 代码分割
      // webpack配置
      optimization: {
        splitChunks: {
          chunks: 'all',
          cacheGroups: {
            vendor: {
              test: /[\\/]node_modules[\\/]/,
              priority: 10,
              name: 'vendors'
            }
          }
        }
      }

   d) CDN加速
      externals: {
        'vue': 'Vue',
        'vue-router': 'VueRouter',
        'element-plus': 'ElementPlus'
      }

3. 优化结果：
   - bundle从2.5MB减少到800KB
   - 首屏时间从5s降到1.5s
   - Lighthouse评分从60提升到95
```

## 3. 移动端适配方案

**考察要点：** 响应式设计、rem/vw方案、1px问题、移动端兼容

### 解答

#### 方案1：rem + flexible方案

```javascript
// flexible.js
(function(win, doc) {
  function setRemUnit() {
    const docEl = doc.documentElement;
    // 设计稿宽度
    const designWidth = 750;
    // 根元素字体大小 = 屏幕宽度 / 10
    const rem = docEl.clientWidth / 10;
    docEl.style.fontSize = rem + 'px';
  }

  setRemUnit();

  // 监听窗口变化
  window.addEventListener('resize', setRemUnit);
  window.addEventListener('pageshow', function(e) {
    if (e.persisted) {
      setRemUnit();
    }
  });
})(window, document);
```

```scss
// 使用Sass函数
@function px2rem($px) {
  @return ($px / 75) * 1rem;
}

.box {
  width: px2rem(750);  // 10rem
  height: px2rem(200); // 2.666rem
}
```

#### 方案2：vw方案

```scss
// postcss.config.js
module.exports = {
  plugins: {
    'postcss-px-to-viewport': {
      viewportWidth: 750,
      viewportUnit: 'vw',
      selectorBlackList: ['.ignore'],
      minPixelValue: 1,
      mediaQuery: false
    }
  }
};
```

```css
/* 源码 */
.box {
  width: 375px;
  height: 100px;
}

/* 编译后 */
.box {
  width: 50vw;
  height: 13.33333vw;
}
```

#### 1px边框解决方案

```scss
// 方案1：transform scale
.border-1px {
  position: relative;

  &::after {
    content: '';
    position: absolute;
    left: 0;
    bottom: 0;
    width: 100%;
    height: 1px;
    background: #e5e5e5;
    transform: scaleY(0.5);
    transform-origin: 0 0;
  }
}

// 方案2：使用图片
@mixin border-image($url) {
  border: 1px solid transparent;
  border-image: url($url) 2 stretch;
}

// 方案3：使用box-shadow
.border {
  box-shadow: 0 0 0 0.5px #e5e5e5;
}
```

#### 移动端适配完整方案

```vue
<template>
  <div class="page">
    <div class="header">Header</div>
    <div class="content">Content</div>
  </div>
</template>

<style lang="scss" scoped>
// 使用vw单位
.page {
  width: 100vw;
  min-height: 100vh;
}

.header {
  height: 44px; // 固定高度用px
  background: #fff;

  // 1px边框
  &::after {
    content: '';
    position: absolute;
    left: 0;
    bottom: 0;
    width: 100%;
    height: 1px;
    background: #e5e5e5;
    transform: scaleY(0.5);
  }
}

.content {
  padding: 16px;
  font-size: 14px;
}

// 响应式断点
@media screen and (min-width: 768px) {
  .content {
    max-width: 750px;
    margin: 0 auto;
  }
}
</style>
```

## 4. 大文件上传方案

**考察要点：** 文件分片、断点续传、并发控制

### 解答

```javascript
class FileUploader {
  constructor(file, options = {}) {
    this.file = file;
    this.chunkSize = options.chunkSize || 2 * 1024 * 1024; // 2MB
    this.concurrency = options.concurrency || 3;
    this.uploadedChunks = new Set();
  }

  // 计算文件hash
  async calculateHash() {
    return new Promise((resolve) => {
      const spark = new SparkMD5.ArrayBuffer();
      const fileReader = new FileReader();
      const chunks = Math.ceil(this.file.size / this.chunkSize);
      let currentChunk = 0;

      fileReader.onload = (e) => {
        spark.append(e.target.result);
        currentChunk++;

        if (currentChunk < chunks) {
          loadNext();
        } else {
          resolve(spark.end());
        }
      };

      function loadNext() {
        const start = currentChunk * this.chunkSize;
        const end = Math.min(start + this.chunkSize, this.file.size);
        fileReader.readAsArrayBuffer(this.file.slice(start, end));
      }

      loadNext.call(this);
    });
  }

  // 分片上传
  async upload() {
    const fileHash = await this.calculateHash();
    const chunks = Math.ceil(this.file.size / this.chunkSize);

    // 检查已上传的分片
    const uploadedChunks = await this.checkUploadedChunks(fileHash);
    this.uploadedChunks = new Set(uploadedChunks);

    // 创建上传任务
    const tasks = [];
    for (let i = 0; i < chunks; i++) {
      if (!this.uploadedChunks.has(i)) {
        tasks.push(this.uploadChunk(fileHash, i));
      }
    }

    // 并发上传
    await this.concurrentUpload(tasks);

    // 合并分片
    await this.mergeChunks(fileHash, chunks);
  }

  // 上传单个分片
  async uploadChunk(fileHash, index) {
    const start = index * this.chunkSize;
    const end = Math.min(start + this.chunkSize, this.file.size);
    const chunk = this.file.slice(start, end);

    const formData = new FormData();
    formData.append('file', chunk);
    formData.append('hash', fileHash);
    formData.append('index', index);

    const response = await fetch('/api/upload/chunk', {
      method: 'POST',
      body: formData
    });

    if (response.ok) {
      this.uploadedChunks.add(index);
      this.onProgress({
        uploaded: this.uploadedChunks.size,
        total: Math.ceil(this.file.size / this.chunkSize)
      });
    }

    return response;
  }

  // 并发控制
  async concurrentUpload(tasks) {
    const executing = [];

    for (const task of tasks) {
      const p = Promise.resolve().then(() => task);
      executing.push(p);

      if (executing.length >= this.concurrency) {
        await Promise.race(executing);
        executing.splice(executing.findIndex(p => p === p), 1);
      }
    }

    return Promise.all(executing);
  }

  // 合并分片
  async mergeChunks(fileHash, chunks) {
    return fetch('/api/upload/merge', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        hash: fileHash,
        chunks: chunks,
        filename: this.file.name
      })
    });
  }

  // 检查已上传分片
  async checkUploadedChunks(fileHash) {
    const response = await fetch(`/api/upload/check?hash=${fileHash}`);
    const data = await response.json();
    return data.uploadedChunks || [];
  }

  onProgress(progress) {
    console.log(`上传进度: ${(progress.uploaded / progress.total * 100).toFixed(2)}%`);
  }
}

// 使用
const uploader = new FileUploader(file, {
  chunkSize: 2 * 1024 * 1024,
  concurrency: 3
});

uploader.onProgress = (progress) => {
  console.log(`进度: ${progress.uploaded}/${progress.total}`);
};

await uploader.upload();
```

## 5. 前端权限控制方案

**考察要点：** 路由权限、按钮权限、接口权限

### 解答

#### 路由权限控制

```javascript
// router/index.js
import { createRouter } from 'vue-router';
import { useUserStore } from '@/stores/user';

const router = createRouter({
  routes: [
    {
      path: '/admin',
      component: AdminLayout,
      meta: { requiresAuth: true, roles: ['admin'] },
      children: [
        {
          path: 'users',
          component: () => import('@/views/admin/Users.vue'),
          meta: { permission: 'user:view' }
        }
      ]
    }
  ]
});

// 路由守卫
router.beforeEach((to, from, next) => {
  const userStore = useUserStore();
  const { isAuthenticated, userInfo } = userStore;

  // 需要登录
  if (to.meta.requiresAuth && !isAuthenticated) {
    return next({ path: '/login', query: { redirect: to.fullPath } });
  }

  // 角色权限
  if (to.meta.roles) {
    const hasRole = to.meta.roles.includes(userInfo.role);
    if (!hasRole) {
      return next({ path: '/403' });
    }
  }

  // 细粒度权限
  if (to.meta.permission) {
    const hasPermission = userInfo.permissions?.includes(to.meta.permission);
    if (!hasPermission) {
      return next({ path: '/403' });
    }
  }

  next();
});
```

#### 按钮权限指令

```javascript
// directives/permission.js
export default {
  mounted(el, binding) {
    const { value } = binding;
    const userStore = useUserStore();
    const permissions = userStore.userInfo.permissions || [];

    if (value && !permissions.includes(value)) {
      el.style.display = 'none';
      // 或者直接移除元素
      // el.parentNode?.removeChild(el);
    }
  }
};

// 使用
<template>
  <button v-permission="'user:delete'">删除</button>
  <button v-permission="'user:edit'">编辑</button>
</template>
```

#### 动态路由生成

```javascript
// utils/route.js
export function generateRoutes(permissions) {
  const asyncRoutes = [
    {
      path: '/admin',
      component: () => import('@/layouts/AdminLayout.vue'),
      children: [
        {
          path: 'users',
          component: () => import('@/views/admin/Users.vue'),
          permission: 'user:view'
        },
        {
          path: 'roles',
          component: () => import('@/views/admin/Roles.vue'),
          permission: 'role:view'
        }
      ]
    }
  ];

  function filterRoutes(routes) {
    return routes.filter(route => {
      if (route.permission) {
        if (!permissions.includes(route.permission)) {
          return false;
        }
      }

      if (route.children) {
        route.children = filterRoutes(route.children);
      }

      return true;
    });
  }

  return filterRoutes(asyncRoutes);
}

// 登录后动态添加路由
const routes = generateRoutes(userPermissions);
routes.forEach(route => {
  router.addRoute(route);
});
```

#### 接口权限

```javascript
// axios拦截器
axios.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

axios.interceptors.response.use(
  response => response.data,
  error => {
    if (error.response?.status === 401) {
      // token过期，跳转登录
      router.push('/login');
    } else if (error.response?.status === 403) {
      // 无权限
      Message.error('无权限访问');
    }
    return Promise.reject(error);
  }
);
```
