# 前端监控深度解析

## 1. 监控系统架构设计

### 完整的监控系统架构

```
前端应用
  ├── SDK采集层
  │   ├── 性能采集
  │   ├── 错误采集
  │   ├── 行为采集
  │   └── 自定义埋点
  │
  ├── 数据处理层
  │   ├── 数据格式化
  │   ├── 数据压缩
  │   ├── 采样策略
  │   └── 队列管理
  │
  ├── 上报层
  │   ├── Image上报
  │   ├── Beacon上报
  │   ├── Fetch上报
  │   └── 重试机制
  │
  └── 存储分析层
      ├── 日志存储
      ├── 数据聚合
      ├── 实时分析
      └── 可视化展示
```

### 监控SDK核心实现

```javascript
class Monitor {
  constructor(options) {
    this.options = {
      appId: options.appId,
      userId: options.userId || this.getDeviceId(),
      version: options.version,
      apiUrl: options.apiUrl || '/api/monitor',
      sampling: options.sampling || 1, // 采样率
      maxQueueSize: options.maxQueueSize || 10,
      sendInterval: options.sendInterval || 3000,
      debug: options.debug || false
    };

    this.queue = [];
    this.timer = null;
    this.initialized = false;
  }

  // 初始化监控
  init() {
    if (this.initialized) return;

    this.initPerformanceMonitor();
    this.initErrorMonitor();
    this.initBehaviorMonitor();
    this.initResourceMonitor();

    // 页面卸载时上报
    window.addEventListener('beforeunload', () => this.flush());
    window.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        this.flush();
      }
    });

    this.initialized = true;
  }

  // 性能监控
  initPerformanceMonitor() {
    // Web Vitals
    this.observeWebVitals();

    // Navigation Timing
    window.addEventListener('load', () => {
      setTimeout(() => {
        const perfData = this.getNavigationTiming();
        this.report({
          type: 'performance',
          subType: 'navigation',
          data: perfData
        });
      }, 0);
    });

    // 长任务监控
    this.observeLongTasks();

    // FPS监控
    this.observeFPS();
  }

  // Web Vitals监控
  observeWebVitals() {
    // LCP - 最大内容绘制
    const lcpObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const lastEntry = entries[entries.length - 1];

      this.report({
        type: 'performance',
        subType: 'lcp',
        data: {
          value: lastEntry.renderTime || lastEntry.loadTime,
          element: lastEntry.element?.tagName,
          url: lastEntry.url,
          size: lastEntry.size
        }
      });
    });

    try {
      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
    } catch (e) {
      console.warn('LCP not supported');
    }

    // FID - 首次输入延迟
    const fidObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry) => {
        this.report({
          type: 'performance',
          subType: 'fid',
          data: {
            value: entry.processingStart - entry.startTime,
            name: entry.name,
            duration: entry.duration
          }
        });
      });
    });

    try {
      fidObserver.observe({ entryTypes: ['first-input'] });
    } catch (e) {
      console.warn('FID not supported');
    }

    // CLS - 累积布局偏移
    let clsValue = 0;
    let clsEntries = [];

    const clsObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries();

      entries.forEach((entry) => {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
          clsEntries.push(entry);
        }
      });

      // 页面卸载时上报
      window.addEventListener('beforeunload', () => {
        this.report({
          type: 'performance',
          subType: 'cls',
          data: {
            value: clsValue,
            entries: clsEntries.slice(0, 5) // 只保留前5个
          }
        });
      }, { once: true });
    });

    try {
      clsObserver.observe({ entryTypes: ['layout-shift'] });
    } catch (e) {
      console.warn('CLS not supported');
    }

    // FCP - 首次内容绘制
    const fcpObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry) => {
        if (entry.name === 'first-contentful-paint') {
          this.report({
            type: 'performance',
            subType: 'fcp',
            data: {
              value: entry.startTime
            }
          });
        }
      });
    });

    try {
      fcpObserver.observe({ entryTypes: ['paint'] });
    } catch (e) {
      console.warn('FCP not supported');
    }

    // TTFB - 首字节时间
    window.addEventListener('load', () => {
      const navTiming = performance.getEntriesByType('navigation')[0];
      if (navTiming) {
        this.report({
          type: 'performance',
          subType: 'ttfb',
          data: {
            value: navTiming.responseStart - navTiming.requestStart
          }
        });
      }
    });
  }

  // Navigation Timing
  getNavigationTiming() {
    const navTiming = performance.getEntriesByType('navigation')[0];
    if (!navTiming) return {};

    return {
      // DNS查询时间
      dns: navTiming.domainLookupEnd - navTiming.domainLookupStart,
      // TCP连接时间
      tcp: navTiming.connectEnd - navTiming.connectStart,
      // SSL握手时间
      ssl: navTiming.secureConnectionStart > 0
        ? navTiming.connectEnd - navTiming.secureConnectionStart
        : 0,
      // 请求响应时间
      ttfb: navTiming.responseStart - navTiming.requestStart,
      // 响应下载时间
      download: navTiming.responseEnd - navTiming.responseStart,
      // DOM解析时间
      domParse: navTiming.domComplete - navTiming.domInteractive,
      // DOM Ready时间
      domReady: navTiming.domContentLoadedEventEnd - navTiming.fetchStart,
      // 页面加载完成时间
      load: navTiming.loadEventEnd - navTiming.fetchStart,
      // 重定向时间
      redirect: navTiming.redirectEnd - navTiming.redirectStart,
      // 卸载时间
      unload: navTiming.unloadEventEnd - navTiming.unloadEventStart,
      // 首次可交互时间
      tti: navTiming.domInteractive - navTiming.fetchStart
    };
  }

  // 长任务监控
  observeLongTasks() {
    const longTaskObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry) => {
        if (entry.duration > 50) { // 超过50ms的任务
          this.report({
            type: 'performance',
            subType: 'longTask',
            data: {
              duration: entry.duration,
              startTime: entry.startTime,
              name: entry.name,
              attribution: entry.attribution
            }
          });
        }
      });
    });

    try {
      longTaskObserver.observe({ entryTypes: ['longtask'] });
    } catch (e) {
      console.warn('Long Task not supported');
    }
  }

  // FPS监控
  observeFPS() {
    let lastTime = performance.now();
    let frame = 0;

    const checkFPS = () => {
      const currentTime = performance.now();
      frame++;

      if (currentTime >= lastTime + 1000) {
        const fps = Math.round((frame * 1000) / (currentTime - lastTime));

        // FPS低于30时上报
        if (fps < 30) {
          this.report({
            type: 'performance',
            subType: 'fps',
            data: {
              fps: fps,
              timestamp: Date.now()
            }
          });
        }

        frame = 0;
        lastTime = currentTime;
      }

      requestAnimationFrame(checkFPS);
    };

    requestAnimationFrame(checkFPS);
  }

  // 资源加载监控
  initResourceMonitor() {
    const resourceObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries();

      entries.forEach((entry) => {
        // 过滤慢资源和失败资源
        const isSlow = entry.duration > 3000;
        const isFailed = entry.transferSize === 0 && entry.encodedBodySize === 0;

        if (isSlow || isFailed) {
          this.report({
            type: 'resource',
            subType: isFailed ? 'error' : 'slow',
            data: {
              name: entry.name,
              type: entry.initiatorType,
              duration: entry.duration,
              size: entry.transferSize,
              protocol: entry.nextHopProtocol,
              cached: entry.transferSize === 0 && entry.decodedBodySize > 0
            }
          });
        }
      });
    });

    try {
      resourceObserver.observe({ entryTypes: ['resource'] });
    } catch (e) {
      console.warn('Resource Timing not supported');
    }
  }

  // 错误监控
  initErrorMonitor() {
    // JavaScript错误
    window.addEventListener('error', (event) => {
      if (event.target !== window) {
        // 资源加载错误
        this.report({
          type: 'error',
          subType: 'resource',
          data: {
            tagName: event.target.tagName,
            src: event.target.src || event.target.href,
            outerHTML: event.target.outerHTML?.slice(0, 500)
          }
        });
      } else {
        // JavaScript运行时错误
        this.report({
          type: 'error',
          subType: 'javascript',
          data: {
            message: event.message,
            filename: event.filename,
            line: event.lineno,
            column: event.colno,
            stack: event.error?.stack,
            type: event.error?.name
          }
        });
      }
    }, true);

    // Promise未捕获错误
    window.addEventListener('unhandledrejection', (event) => {
      this.report({
        type: 'error',
        subType: 'promise',
        data: {
          reason: event.reason?.message || event.reason,
          stack: event.reason?.stack,
          promise: String(event.promise)
        }
      });
    });

    // 接口错误监控
    this.interceptFetch();
    this.interceptXHR();
  }

  // 拦截fetch
  interceptFetch() {
    const originalFetch = window.fetch;
    const self = this;

    window.fetch = function(...args) {
      const startTime = Date.now();
      const url = args[0];
      const method = args[1]?.method || 'GET';

      return originalFetch.apply(this, args)
        .then(response => {
          const duration = Date.now() - startTime;

          // 记录接口性能
          self.report({
            type: 'api',
            subType: 'performance',
            data: {
              url: url,
              method: method,
              status: response.status,
              duration: duration,
              success: response.ok
            }
          });

          // 记录失败接口
          if (!response.ok) {
            self.report({
              type: 'api',
              subType: 'error',
              data: {
                url: url,
                method: method,
                status: response.status,
                statusText: response.statusText,
                duration: duration
              }
            });
          }

          return response;
        })
        .catch(error => {
          const duration = Date.now() - startTime;

          // 网络错误
          self.report({
            type: 'api',
            subType: 'error',
            data: {
              url: url,
              method: method,
              message: error.message,
              stack: error.stack,
              duration: duration,
              networkError: true
            }
          });

          throw error;
        });
    };
  }

  // 拦截XMLHttpRequest
  interceptXHR() {
    const originalOpen = XMLHttpRequest.prototype.open;
    const originalSend = XMLHttpRequest.prototype.send;
    const self = this;

    XMLHttpRequest.prototype.open = function(method, url) {
      this._monitorData = {
        method: method,
        url: url,
        startTime: Date.now()
      };
      return originalOpen.apply(this, arguments);
    };

    XMLHttpRequest.prototype.send = function() {
      const monitorData = this._monitorData;

      this.addEventListener('load', function() {
        const duration = Date.now() - monitorData.startTime;

        self.report({
          type: 'api',
          subType: 'performance',
          data: {
            url: monitorData.url,
            method: monitorData.method,
            status: this.status,
            duration: duration,
            success: this.status >= 200 && this.status < 400
          }
        });

        if (this.status >= 400) {
          self.report({
            type: 'api',
            subType: 'error',
            data: {
              url: monitorData.url,
              method: monitorData.method,
              status: this.status,
              statusText: this.statusText,
              response: this.responseText?.slice(0, 1000),
              duration: duration
            }
          });
        }
      });

      this.addEventListener('error', function() {
        const duration = Date.now() - monitorData.startTime;

        self.report({
          type: 'api',
          subType: 'error',
          data: {
            url: monitorData.url,
            method: monitorData.method,
            message: 'Network Error',
            duration: duration,
            networkError: true
          }
        });
      });

      this.addEventListener('timeout', function() {
        const duration = Date.now() - monitorData.startTime;

        self.report({
          type: 'api',
          subType: 'error',
          data: {
            url: monitorData.url,
            method: monitorData.method,
            message: 'Request Timeout',
            duration: duration,
            timeout: true
          }
        });
      });

      return originalSend.apply(this, arguments);
    };
  }

  // 用户行为监控
  initBehaviorMonitor() {
    // PV统计
    this.reportPV();

    // 用户点击
    this.observeClicks();

    // 页面停留时间
    this.observePageDuration();

    // 路由变化（SPA）
    this.observeRouteChange();
  }

  // PV统计
  reportPV() {
    this.report({
      type: 'behavior',
      subType: 'pv',
      data: {
        page: location.pathname,
        referrer: document.referrer,
        title: document.title
      }
    });
  }

  // 点击监控
  observeClicks() {
    document.addEventListener('click', (event) => {
      const target = event.target;

      // 只记录有意义的点击
      if (this.isTrackableElement(target)) {
        this.report({
          type: 'behavior',
          subType: 'click',
          data: {
            x: event.clientX,
            y: event.clientY,
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              text: target.textContent?.slice(0, 100),
              href: target.href,
              xpath: this.getXPath(target)
            },
            page: location.pathname
          }
        });
      }
    }, true);
  }

  // 判断是否是可追踪元素
  isTrackableElement(element) {
    const trackableTags = ['A', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA'];
    return trackableTags.includes(element.tagName) ||
           element.hasAttribute('data-track');
  }

  // 获取元素XPath
  getXPath(element) {
    if (element.id) {
      return `//*[@id="${element.id}"]`;
    }

    const parts = [];
    while (element && element.nodeType === Node.ELEMENT_NODE) {
      let index = 0;
      let sibling = element.previousSibling;

      while (sibling) {
        if (sibling.nodeType === Node.ELEMENT_NODE &&
            sibling.nodeName === element.nodeName) {
          index++;
        }
        sibling = sibling.previousSibling;
      }

      const tagName = element.nodeName.toLowerCase();
      const pathIndex = index > 0 ? `[${index + 1}]` : '';
      parts.unshift(tagName + pathIndex);

      element = element.parentNode;
    }

    return parts.length ? '/' + parts.join('/') : '';
  }

  // 页面停留时间
  observePageDuration() {
    let startTime = Date.now();
    let isVisible = !document.hidden;

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // 页面隐藏，记录停留时间
        const duration = Date.now() - startTime;

        this.report({
          type: 'behavior',
          subType: 'duration',
          data: {
            page: location.pathname,
            duration: duration
          }
        });

        isVisible = false;
      } else {
        // 页面显示，重新开始计时
        startTime = Date.now();
        isVisible = true;
      }
    });

    // 页面卸载
    window.addEventListener('beforeunload', () => {
      if (isVisible) {
        const duration = Date.now() - startTime;

        // 使用sendBeacon确保数据发送
        this.sendBeacon({
          type: 'behavior',
          subType: 'duration',
          data: {
            page: location.pathname,
            duration: duration
          }
        });
      }
    });
  }

  // 路由变化监控（SPA）
  observeRouteChange() {
    let lastRoute = location.pathname;

    // hash路由
    window.addEventListener('hashchange', () => {
      const newRoute = location.hash;
      this.report({
        type: 'behavior',
        subType: 'routeChange',
        data: {
          from: lastRoute,
          to: newRoute
        }
      });
      lastRoute = newRoute;
      this.reportPV();
    });

    // history路由
    const originalPushState = history.pushState;
    const originalReplaceState = history.replaceState;
    const self = this;

    history.pushState = function() {
      originalPushState.apply(this, arguments);

      const newRoute = location.pathname;
      self.report({
        type: 'behavior',
        subType: 'routeChange',
        data: {
          from: lastRoute,
          to: newRoute
        }
      });
      lastRoute = newRoute;
      self.reportPV();
    };

    history.replaceState = function() {
      originalReplaceState.apply(this, arguments);

      const newRoute = location.pathname;
      self.report({
        type: 'behavior',
        subType: 'routeChange',
        data: {
          from: lastRoute,
          to: newRoute
        }
      });
      lastRoute = newRoute;
    };

    window.addEventListener('popstate', () => {
      const newRoute = location.pathname;
      self.report({
        type: 'behavior',
        subType: 'routeChange',
        data: {
          from: lastRoute,
          to: newRoute
        }
      });
      lastRoute = newRoute;
      self.reportPV();
    });
  }

  // 上报数据
  report(data) {
    // 采样
    if (Math.random() > this.options.sampling) {
      return;
    }

    // 添加公共字段
    const reportData = {
      ...data,
      appId: this.options.appId,
      userId: this.options.userId,
      version: this.options.version,
      timestamp: Date.now(),
      page: location.pathname,
      userAgent: navigator.userAgent,
      viewportSize: {
        width: window.innerWidth,
        height: window.innerHeight
      },
      screenSize: {
        width: screen.width,
        height: screen.height
      }
    };

    // 添加到队列
    this.queue.push(reportData);

    if (this.options.debug) {
      console.log('[Monitor]', reportData);
    }

    // 队列满了立即上报
    if (this.queue.length >= this.options.maxQueueSize) {
      this.flush();
    } else {
      // 延迟上报
      this.scheduleFlush();
    }
  }

  // 延迟上报
  scheduleFlush() {
    if (this.timer) return;

    this.timer = setTimeout(() => {
      this.flush();
      this.timer = null;
    }, this.options.sendInterval);
  }

  // 立即上报
  flush() {
    if (this.queue.length === 0) return;

    const data = this.queue.splice(0, this.queue.length);

    // 压缩数据
    const compressedData = this.compressData(data);

    // 使用sendBeacon（页面卸载时也能发送）
    if (navigator.sendBeacon) {
      this.sendBeacon(compressedData);
    } else {
      // 降级到fetch
      this.sendFetch(compressedData);
    }
  }

  // 数据压缩
  compressData(data) {
    // 简单压缩：移除重复字段
    const commonFields = {
      appId: this.options.appId,
      userId: this.options.userId,
      version: this.options.version,
      userAgent: navigator.userAgent
    };

    return {
      common: commonFields,
      list: data.map(item => {
        const { appId, userId, version, userAgent, ...rest } = item;
        return rest;
      })
    };
  }

  // sendBeacon上报
  sendBeacon(data) {
    const blob = new Blob([JSON.stringify(data)], {
      type: 'application/json'
    });

    const result = navigator.sendBeacon(this.options.apiUrl, blob);

    if (!result && this.options.debug) {
      console.warn('[Monitor] sendBeacon failed');
    }

    return result;
  }

  // fetch上报
  sendFetch(data) {
    fetch(this.options.apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data),
      keepalive: true // 页面卸载时也能发送
    }).catch(error => {
      if (this.options.debug) {
        console.error('[Monitor] fetch failed:', error);
      }
    });
  }

  // 获取设备ID
  getDeviceId() {
    let deviceId = localStorage.getItem('monitor_device_id');

    if (!deviceId) {
      deviceId = `${Date.now()}_${Math.random().toString(36).slice(2)}`;
      localStorage.setItem('monitor_device_id', deviceId);
    }

    return deviceId;
  }

  // 自定义埋点
  track(eventName, data) {
    this.report({
      type: 'custom',
      subType: eventName,
      data: data
    });
  }
}

// 使用示例
const monitor = new Monitor({
  appId: 'my-app',
  version: '1.0.0',
  apiUrl: 'https://api.example.com/monitor',
  sampling: 0.1, // 10%采样率
  debug: true
});

monitor.init();

// 自定义埋点
monitor.track('buttonClick', {
  button: 'submit',
  form: 'login'
});
```

## 2. Vue/React框架错误监控

### Vue错误监控

```javascript
// Vue 2错误监控
class VueMonitor {
  install(Vue, options) {
    const monitor = options.monitor;

    // 全局错误处理
    Vue.config.errorHandler = (err, vm, info) => {
      monitor.report({
        type: 'error',
        subType: 'vue',
        data: {
          message: err.message,
          stack: err.stack,
          componentName: vm.$options.name || vm.$options._componentTag,
          propsData: vm.$options.propsData,
          lifecycle: info,
          route: vm.$route?.path
        }
      });

      // 继续抛出错误
      console.error(err);
    };

    // 警告处理
    Vue.config.warnHandler = (msg, vm, trace) => {
      monitor.report({
        type: 'warning',
        subType: 'vue',
        data: {
          message: msg,
          componentName: vm.$options.name,
          trace: trace
        }
      });
    };

    // 路由错误
    if (options.router) {
      options.router.onError(error => {
        monitor.report({
          type: 'error',
          subType: 'vue-router',
          data: {
            message: error.message,
            stack: error.stack
          }
        });
      });
    }

    // Vuex错误
    if (options.store) {
      options.store.subscribe((mutation, state) => {
        // 监控敏感mutation
        if (mutation.type.includes('ERROR')) {
          monitor.report({
            type: 'error',
            subType: 'vuex',
            data: {
              mutation: mutation.type,
              payload: mutation.payload
            }
          });
        }
      });
    }

    // 混入生命周期监控
    Vue.mixin({
      beforeCreate() {
        this._startTime = Date.now();
      },
      mounted() {
        const duration = Date.now() - this._startTime;

        // 组件渲染超过1秒上报
        if (duration > 1000) {
          monitor.report({
            type: 'performance',
            subType: 'component',
            data: {
              componentName: this.$options.name,
              duration: duration,
              route: this.$route?.path
            }
          });
        }
      }
    });
  }
}

// 使用
import Vue from 'vue';
import router from './router';
import store from './store';
import { monitor } from './monitor';

Vue.use(VueMonitor, {
  monitor,
  router,
  store
});
```

### Vue 3错误监控

```javascript
// Vue 3错误监控
const vueMonitorPlugin = {
  install(app, options) {
    const monitor = options.monitor;

    // 全局错误处理
    app.config.errorHandler = (err, instance, info) => {
      monitor.report({
        type: 'error',
        subType: 'vue',
        data: {
          message: err.message,
          stack: err.stack,
          componentName: instance?.$options?.name || instance?.$?.type?.name,
          props: instance?.$props,
          lifecycle: info,
          route: instance?.$route?.path
        }
      });

      console.error(err);
    };

    // 警告处理
    app.config.warnHandler = (msg, instance, trace) => {
      monitor.report({
        type: 'warning',
        subType: 'vue',
        data: {
          message: msg,
          componentName: instance?.$options?.name,
          trace: trace
        }
      });
    };

    // 性能监控
    app.mixin({
      beforeCreate() {
        this._startTime = performance.now();
      },
      mounted() {
        const duration = performance.now() - this._startTime;

        if (duration > 1000) {
          monitor.report({
            type: 'performance',
            subType: 'component',
            data: {
              componentName: this.$options?.name,
              duration: duration
            }
          });
        }
      }
    });
  }
};

// 使用
import { createApp } from 'vue';
import App from './App.vue';
import { monitor } from './monitor';

const app = createApp(App);
app.use(vueMonitorPlugin, { monitor });
app.mount('#app');
```

### React错误监控

```javascript
// React错误边界
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    const { monitor } = this.props;

    // 上报错误
    monitor.report({
      type: 'error',
      subType: 'react',
      data: {
        message: error.message,
        stack: error.stack,
        componentStack: errorInfo.componentStack,
        errorBoundary: this.constructor.name
      }
    });

    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}

// 使用
import { monitor } from './monitor';

function App() {
  return (
    <ErrorBoundary monitor={monitor}>
      <MyComponent />
    </ErrorBoundary>
  );
}
```

### React Hooks错误监控

```javascript
// 自定义Hook监控错误
function useErrorHandler(monitor) {
  const handleError = useCallback((error, errorInfo) => {
    monitor.report({
      type: 'error',
      subType: 'react',
      data: {
        message: error.message,
        stack: error.stack,
        ...errorInfo
      }
    });
  }, [monitor]);

  return handleError;
}

// 使用
function MyComponent() {
  const handleError = useErrorHandler(monitor);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const data = await api.getData();
        setData(data);
      } catch (error) {
        handleError(error, {
          component: 'MyComponent',
          action: 'fetchData'
        });
      }
    };

    fetchData();
  }, []);

  return <div>{/* ... */}</div>;
}
```

### 第三方库错误捕获

```javascript
// Axios拦截器
import axios from 'axios';
import { monitor } from './monitor';

// 请求拦截器
axios.interceptors.request.use(
  config => {
    config.metadata = { startTime: Date.now() };
    return config;
  },
  error => {
    monitor.report({
      type: 'error',
      subType: 'axios',
      data: {
        message: error.message,
        config: error.config,
        stage: 'request'
      }
    });
    return Promise.reject(error);
  }
);

// 响应拦截器
axios.interceptors.response.use(
  response => {
    const duration = Date.now() - response.config.metadata.startTime;

    // 慢接口上报
    if (duration > 3000) {
      monitor.report({
        type: 'performance',
        subType: 'api',
        data: {
          url: response.config.url,
          method: response.config.method,
          duration: duration,
          status: response.status
        }
      });
    }

    return response;
  },
  error => {
    const duration = Date.now() - error.config?.metadata?.startTime;

    monitor.report({
      type: 'error',
      subType: 'axios',
      data: {
        message: error.message,
        url: error.config?.url,
        method: error.config?.method,
        status: error.response?.status,
        statusText: error.response?.statusText,
        duration: duration,
        stage: 'response'
      }
    });

    return Promise.reject(error);
  }
);
```

## 3. 错误信息分析和SourceMap

### SourceMap解析

```javascript
// 服务端SourceMap解析
const sourceMap = require('source-map');
const fs = require('fs');

class SourceMapParser {
  constructor() {
    this.cache = new Map();
  }

  async parseError(error) {
    const { filename, line, column, stack } = error;

    // 读取SourceMap
    const mapFile = `${filename}.map`;
    const rawSourceMap = await this.loadSourceMap(mapFile);

    if (!rawSourceMap) {
      return error;
    }

    // 解析
    const consumer = await new sourceMap.SourceMapConsumer(rawSourceMap);

    // 获取原始位置
    const originalPosition = consumer.originalPositionFor({
      line: line,
      column: column
    });

    // 解析堆栈
    const originalStack = await this.parseStack(stack, consumer);

    consumer.destroy();

    return {
      ...error,
      original: {
        filename: originalPosition.source,
        line: originalPosition.line,
        column: originalPosition.column,
        name: originalPosition.name,
        stack: originalStack
      }
    };
  }

  async parseStack(stack, consumer) {
    if (!stack) return '';

    const lines = stack.split('\n');
    const parsedLines = [];

    for (const line of lines) {
      // 提取文件名和位置
      const match = line.match(/at\s+(.*?)\s+\((.*?):(\d+):(\d+)\)/);

      if (match) {
        const [, name, file, lineNum, colNum] = match;

        const original = consumer.originalPositionFor({
          line: parseInt(lineNum),
          column: parseInt(colNum)
        });

        if (original.source) {
          parsedLines.push(
            `    at ${original.name || name} (${original.source}:${original.line}:${original.column})`
          );
        } else {
          parsedLines.push(line);
        }
      } else {
        parsedLines.push(line);
      }
    }

    return parsedLines.join('\n');
  }

  async loadSourceMap(mapFile) {
    // 从缓存读取
    if (this.cache.has(mapFile)) {
      return this.cache.get(mapFile);
    }

    try {
      const content = fs.readFileSync(mapFile, 'utf-8');
      const map = JSON.parse(content);
      this.cache.set(mapFile, map);
      return map;
    } catch (error) {
      console.error('Failed to load source map:', error);
      return null;
    }
  }
}

// 使用
const parser = new SourceMapParser();

app.post('/api/error', async (req, res) => {
  const error = req.body;

  // 解析错误
  const parsedError = await parser.parseError(error);

  // 存储到数据库
  await db.errors.insert(parsedError);

  res.json({ success: true });
});
```

### 错误聚合和分类

```javascript
// 错误聚合
class ErrorAggregator {
  constructor() {
    this.errors = new Map();
  }

  aggregate(error) {
    // 生成错误指纹
    const fingerprint = this.getFingerprint(error);

    if (!this.errors.has(fingerprint)) {
      this.errors.set(fingerprint, {
        fingerprint: fingerprint,
        message: error.message,
        stack: error.stack,
        type: error.type,
        count: 0,
        firstSeen: Date.now(),
        lastSeen: Date.now(),
        users: new Set(),
        pages: new Set(),
        versions: new Set()
      });
    }

    const aggregated = this.errors.get(fingerprint);
    aggregated.count++;
    aggregated.lastSeen = Date.now();
    aggregated.users.add(error.userId);
    aggregated.pages.add(error.page);
    aggregated.versions.add(error.version);

    return aggregated;
  }

  getFingerprint(error) {
    // 根据错误消息和堆栈生成指纹
    const stack = this.normalizeStack(error.stack);
    const message = this.normalizeMessage(error.message);

    return this.hash(`${message}:${stack}`);
  }

  normalizeStack(stack) {
    if (!stack) return '';

    return stack
      // 移除行号和列号
      .replace(/:\d+:\d+/g, '')
      // 移除URL
      .replace(/https?:\/\/[^\s]+/g, '<URL>')
      // 移除动态内容
      .replace(/\d{13,}/g, '<TIMESTAMP>')
      .replace(/[a-f0-9]{32,}/g, '<HASH>')
      // 只保留前5行
      .split('\n')
      .slice(0, 5)
      .join('\n');
  }

  normalizeMessage(message) {
    if (!message) return '';

    return message
      // 移除数字
      .replace(/\d+/g, '<N>')
      // 移除URL
      .replace(/https?:\/\/[^\s]+/g, '<URL>')
      // 移除引号内容
      .replace(/"[^"]+"/g, '<STRING>');
  }

  hash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString(36);
  }

  getTopErrors(limit = 10) {
    return Array.from(this.errors.values())
      .sort((a, b) => b.count - a.count)
      .slice(0, limit);
  }
}

// 使用
const aggregator = new ErrorAggregator();

app.post('/api/error', (req, res) => {
  const error = req.body;
  const aggregated = aggregator.aggregate(error);

  // 告警：新错误或错误激增
  if (aggregated.count === 1) {
    alertNewError(aggregated);
  } else if (aggregated.count > 100) {
    alertHighFrequencyError(aggregated);
  }

  res.json({ success: true });
});
```

## 4. Node.js进程监控

### 进程健壮性保证

```javascript
// 进程管理器
class ProcessManager {
  constructor(options = {}) {
    this.maxRestarts = options.maxRestarts || 10;
    this.restartWindow = options.restartWindow || 60000; // 1分钟
    this.restarts = [];

    this.setupHandlers();
  }

  setupHandlers() {
    // 未捕获异常
    process.on('uncaughtException', (error) => {
      console.error('Uncaught Exception:', error);
      this.logError(error);
      this.gracefulShutdown('uncaughtException');
    });

    // 未处理的Promise拒绝
    process.on('unhandledRejection', (reason, promise) => {
      console.error('Unhandled Rejection:', reason);
      this.logError(reason);
    });

    // 进程警告
    process.on('warning', (warning) => {
      console.warn('Process Warning:', warning);
      this.logWarning(warning);
    });

    // 优雅退出
    process.on('SIGTERM', () => {
      console.log('Received SIGTERM');
      this.gracefulShutdown('SIGTERM');
    });

    process.on('SIGINT', () => {
      console.log('Received SIGINT');
      this.gracefulShutdown('SIGINT');
    });

    // 内存监控
    this.startMemoryMonitoring();

    // 健康检查
    this.startHealthCheck();
  }

  startMemoryMonitoring() {
    setInterval(() => {
      const usage = process.memoryUsage();
      const heapUsed = usage.heapUsed / 1024 / 1024;
      const heapTotal = usage.heapTotal / 1024 / 1024;
      const external = usage.external / 1024 / 1024;
      const rss = usage.rss / 1024 / 1024;

      console.log(`Memory Usage:
        Heap Used: ${heapUsed.toFixed(2)} MB
        Heap Total: ${heapTotal.toFixed(2)} MB
        External: ${external.toFixed(2)} MB
        RSS: ${rss.toFixed(2)} MB
      `);

      // 内存超限警告
      if (heapUsed / heapTotal > 0.9) {
        console.warn('High memory usage detected');
        this.alertHighMemory({ heapUsed, heapTotal });
      }

      // 内存超限重启
      if (heapUsed > 1024) { // 1GB
        console.error('Memory limit exceeded, restarting...');
        this.gracefulShutdown('memoryLimit');
      }
    }, 60000); // 每分钟检查一次
  }

  startHealthCheck() {
    // CPU使用率监控
    let lastCpuUsage = process.cpuUsage();
    let lastTime = Date.now();

    setInterval(() => {
      const currentCpuUsage = process.cpuUsage(lastCpuUsage);
      const currentTime = Date.now();
      const elapsedTime = currentTime - lastTime;

      const cpuPercent = (
        (currentCpuUsage.user + currentCpuUsage.system) / 1000 / elapsedTime
      ) * 100;

      console.log(`CPU Usage: ${cpuPercent.toFixed(2)}%`);

      // 高CPU警告
      if (cpuPercent > 80) {
        console.warn('High CPU usage detected');
        this.alertHighCPU(cpuPercent);
      }

      lastCpuUsage = process.cpuUsage();
      lastTime = currentTime;
    }, 10000); // 每10秒检查一次
  }

  gracefulShutdown(reason) {
    console.log(`Graceful shutdown initiated: ${reason}`);

    // 停止接收新请求
    if (global.server) {
      global.server.close(() => {
        console.log('Server closed');

        // 关闭数据库连接
        this.closeConnections()
          .then(() => {
            console.log('All connections closed');
            process.exit(0);
          })
          .catch(error => {
            console.error('Error closing connections:', error);
            process.exit(1);
          });
      });

      // 强制退出（30秒后）
      setTimeout(() => {
        console.error('Forced shutdown');
        process.exit(1);
      }, 30000);
    } else {
      process.exit(0);
    }
  }

  async closeConnections() {
    const promises = [];

    // 关闭数据库
    if (global.mongoose) {
      promises.push(
        global.mongoose.connection.close(false)
          .then(() => console.log('MongoDB closed'))
      );
    }

    if (global.redis) {
      promises.push(
        global.redis.quit()
          .then(() => console.log('Redis closed'))
      );
    }

    await Promise.all(promises);
  }

  logError(error) {
    // 记录到日志系统
    logger.error({
      message: error.message,
      stack: error.stack,
      pid: process.pid,
      uptime: process.uptime(),
      memoryUsage: process.memoryUsage()
    });
  }

  logWarning(warning) {
    logger.warn({
      message: warning.message,
      name: warning.name,
      pid: process.pid
    });
  }

  alertHighMemory(data) {
    // 发送告警
    alert.send({
      type: 'highMemory',
      data: data,
      pid: process.pid,
      timestamp: Date.now()
    });
  }

  alertHighCPU(percent) {
    alert.send({
      type: 'highCPU',
      data: { cpuPercent: percent },
      pid: process.pid,
      timestamp: Date.now()
    });
  }
}

// 启动进程管理
const processManager = new ProcessManager({
  maxRestarts: 10,
  restartWindow: 60000
});
```

### PM2集群管理

```javascript
// ecosystem.config.js
module.exports = {
  apps: [{
    name: 'app',
    script: './app.js',

    // 实例配置
    instances: 'max', // 或具体数字
    exec_mode: 'cluster',

    // 监控配置
    max_memory_restart: '1G',
    min_uptime: '10s',
    max_restarts: 10,
    autorestart: true,

    // 日志配置
    error_file: './logs/err.log',
    out_file: './logs/out.log',
    log_date_format: 'YYYY-MM-DD HH:mm:ss',
    merge_logs: true,

    // 环境变量
    env: {
      NODE_ENV: 'development',
      PORT: 3000
    },
    env_production: {
      NODE_ENV: 'production',
      PORT: 8080
    },

    // 定时重启
    cron_restart: '0 0 * * *', // 每天凌晨重启

    // 监听文件变化（开发环境）
    watch: false,
    ignore_watch: ['node_modules', 'logs'],

    // 启动延迟
    listen_timeout: 3000,
    kill_timeout: 5000
  }]
};
```

### 进程间通信

```javascript
// Master进程
const cluster = require('cluster');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  console.log(`Master ${process.pid} is running`);

  // 创建Worker
  for (let i = 0; i < numCPUs; i++) {
    const worker = cluster.fork();

    // 监听Worker消息
    worker.on('message', (msg) => {
      console.log(`Message from worker ${worker.id}:`, msg);

      if (msg.type === 'metric') {
        // 收集指标
        collectMetric(msg.data);
      }
    });
  }

  // Worker退出处理
  cluster.on('exit', (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died`);

    // 重启Worker
    console.log('Starting a new worker');
    cluster.fork();
  });

  // Master定时任务
  setInterval(() => {
    // 向所有Worker广播
    for (const id in cluster.workers) {
      cluster.workers[id].send({
        type: 'broadcast',
        data: 'Clear cache'
      });
    }
  }, 3600000); // 每小时

} else {
  // Worker进程
  console.log(`Worker ${process.pid} started`);

  // 启动服务器
  const server = require('./app');
  server.listen(3000);

  // 向Master发送消息
  setInterval(() => {
    process.send({
      type: 'metric',
      data: {
        memory: process.memoryUsage(),
        cpu: process.cpuUsage()
      }
    });
  }, 10000);

  // 监听Master消息
  process.on('message', (msg) => {
    console.log('Message from master:', msg);

    if (msg.type === 'broadcast' && msg.data === 'Clear cache') {
      clearCache();
    }
  });
}
```

## 5. 并发控制

### 请求并发限制

```javascript
// Express限流中间件
const rateLimit = require('express-rate-limit');

// 全局限流
const globalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100, // 最多100个请求
  message: 'Too many requests from this IP',
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req, res) => {
    res.status(429).json({
      error: 'Too many requests',
      retryAfter: req.rateLimit.resetTime
    });
  }
});

app.use(globalLimiter);

// API限流
const apiLimiter = rateLimit({
  windowMs: 60 * 1000, // 1分钟
  max: 10,
  skipSuccessfulRequests: false,
  skip: (req) => {
    // 跳过白名单IP
    return whitelist.includes(req.ip);
  }
});

app.use('/api/', apiLimiter);

// 用户级限流
const userLimiter = rateLimit({
  windowMs: 60 * 1000,
  max: 20,
  keyGenerator: (req) => {
    // 使用用户ID作为key
    return req.user?.id || req.ip;
  }
});

app.use('/api/user/', userLimiter);
```

### 并发队列

```javascript
// 并发控制队列
class ConcurrencyQueue {
  constructor(concurrency = 5) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }

  async add(task) {
    return new Promise((resolve, reject) => {
      this.queue.push({
        task,
        resolve,
        reject
      });

      this.run();
    });
  }

  async run() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }

    this.running++;
    const { task, resolve, reject } = this.queue.shift();

    try {
      const result = await task();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.run(); // 处理下一个任务
    }
  }

  get pending() {
    return this.queue.length;
  }

  get active() {
    return this.running;
  }
}

// 使用
const queue = new ConcurrencyQueue(5);

// 添加任务
const tasks = Array.from({ length: 20 }, (_, i) =>
  () => fetch(`/api/data/${i}`)
);

const results = await Promise.all(
  tasks.map(task => queue.add(task))
);

console.log(`Pending: ${queue.pending}, Active: ${queue.active}`);
```

### 请求去重

```javascript
// 请求去重
class RequestDeduplicator {
  constructor() {
    this.pending = new Map();
  }

  async request(key, requestFn) {
    // 如果请求正在进行中，返回同一个Promise
    if (this.pending.has(key)) {
      console.log(`Request ${key} is deduped`);
      return this.pending.get(key);
    }

    // 创建新请求
    const promise = requestFn()
      .then(result => {
        this.pending.delete(key);
        return result;
      })
      .catch(error => {
        this.pending.delete(key);
        throw error;
      });

    this.pending.set(key, promise);
    return promise;
  }

  clear() {
    this.pending.clear();
  }
}

// 使用
const deduplicator = new RequestDeduplicator();

// 多个地方同时请求同一个接口
Promise.all([
  deduplicator.request('/api/user/1', () => fetch('/api/user/1')),
  deduplicator.request('/api/user/1', () => fetch('/api/user/1')),
  deduplicator.request('/api/user/1', () => fetch('/api/user/1'))
]);
// 实际只会发送一次请求
```

## 6. 监控数据可视化

### 实时监控仪表盘

```javascript
// 使用Socket.IO推送实时数据
const io = require('socket.io')(server);

// 监控数据收集
class MonitorCollector {
  constructor() {
    this.metrics = {
      requests: 0,
      errors: 0,
      avgResponseTime: 0,
      activeUsers: new Set(),
      memoryUsage: 0,
      cpuUsage: 0
    };

    // 定时推送
    setInterval(() => {
      io.emit('metrics', this.getMetrics());
      this.reset();
    }, 1000);
  }

  recordRequest(duration) {
    this.metrics.requests++;
    this.metrics.avgResponseTime =
      (this.metrics.avgResponseTime + duration) / 2;
  }

  recordError() {
    this.metrics.errors++;
  }

  recordUser(userId) {
    this.metrics.activeUsers.add(userId);
  }

  updateSystemMetrics() {
    const usage = process.memoryUsage();
    this.metrics.memoryUsage = usage.heapUsed / 1024 / 1024;

    const cpuUsage = process.cpuUsage();
    this.metrics.cpuUsage =
      (cpuUsage.user + cpuUsage.system) / 1000000;
  }

  getMetrics() {
    return {
      ...this.metrics,
      activeUsers: this.metrics.activeUsers.size,
      timestamp: Date.now()
    };
  }

  reset() {
    this.metrics.requests = 0;
    this.metrics.errors = 0;
    this.metrics.avgResponseTime = 0;
  }
}

const collector = new MonitorCollector();

// 中间件
app.use((req, res, next) => {
  const start = Date.now();

  res.on('finish', () => {
    const duration = Date.now() - start;
    collector.recordRequest(duration);

    if (res.statusCode >= 400) {
      collector.recordError();
    }

    if (req.user) {
      collector.recordUser(req.user.id);
    }
  });

  next();
});

// 定时更新系统指标
setInterval(() => {
  collector.updateSystemMetrics();
}, 1000);
```

### 前端仪表盘

```vue
<template>
  <div class="dashboard">
    <div class="metric-card">
      <h3>请求数/秒</h3>
      <div class="value">{{ metrics.requests }}</div>
      <line-chart :data="requestsHistory" />
    </div>

    <div class="metric-card">
      <h3>错误率</h3>
      <div class="value">{{ errorRate }}%</div>
      <line-chart :data="errorsHistory" />
    </div>

    <div class="metric-card">
      <h3>平均响应时间</h3>
      <div class="value">{{ metrics.avgResponseTime }}ms</div>
      <line-chart :data="responseTimeHistory" />
    </div>

    <div class="metric-card">
      <h3>活跃用户</h3>
      <div class="value">{{ metrics.activeUsers }}</div>
    </div>

    <div class="metric-card">
      <h3>内存使用</h3>
      <div class="value">{{ metrics.memoryUsage }}MB</div>
      <line-chart :data="memoryHistory" />
    </div>

    <div class="metric-card">
      <h3>CPU使用率</h3>
      <div class="value">{{ metrics.cpuUsage }}%</div>
      <line-chart :data="cpuHistory" />
    </div>
  </div>
</template>

<script>
import { io } from 'socket.io-client';
import LineChart from './LineChart.vue';

export default {
  components: {
    LineChart
  },

  data() {
    return {
      socket: null,
      metrics: {
        requests: 0,
        errors: 0,
        avgResponseTime: 0,
        activeUsers: 0,
        memoryUsage: 0,
        cpuUsage: 0
      },
      requestsHistory: [],
      errorsHistory: [],
      responseTimeHistory: [],
      memoryHistory: [],
      cpuHistory: [],
      maxHistoryLength: 60
    };
  },

  computed: {
    errorRate() {
      if (this.metrics.requests === 0) return 0;
      return ((this.metrics.errors / this.metrics.requests) * 100).toFixed(2);
    }
  },

  mounted() {
    this.connectSocket();
  },

  beforeUnmount() {
    if (this.socket) {
      this.socket.disconnect();
    }
  },

  methods: {
    connectSocket() {
      this.socket = io('http://localhost:3000');

      this.socket.on('metrics', (data) => {
        this.updateMetrics(data);
      });

      this.socket.on('disconnect', () => {
        console.log('Disconnected from server');
      });
    },

    updateMetrics(data) {
      this.metrics = data;

      // 更新历史数据
      this.addToHistory(this.requestsHistory, data.requests);
      this.addToHistory(this.errorsHistory, data.errors);
      this.addToHistory(this.responseTimeHistory, data.avgResponseTime);
      this.addToHistory(this.memoryHistory, data.memoryUsage);
      this.addToHistory(this.cpuHistory, data.cpuUsage);
    },

    addToHistory(history, value) {
      history.push({
        timestamp: Date.now(),
        value: value
      });

      // 保持固定长度
      if (history.length > this.maxHistoryLength) {
        history.shift();
      }
    }
  }
};
</script>

<style scoped>
.dashboard {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
  padding: 20px;
}

.metric-card {
  background: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.metric-card h3 {
  margin: 0 0 10px 0;
  font-size: 14px;
  color: #666;
}

.metric-card .value {
  font-size: 32px;
  font-weight: bold;
  color: #333;
  margin-bottom: 10px;
}
</style>
```

## 7. 告警系统

### 告警规则引擎

```javascript
// 告警规则
class AlertRule {
  constructor(config) {
    this.name = config.name;
    this.condition = config.condition;
    this.threshold = config.threshold;
    this.duration = config.duration || 0;
    this.cooldown = config.cooldown || 300000; // 5分钟
    this.channels = config.channels || ['email'];

    this.triggered = false;
    this.lastAlert = 0;
    this.triggerCount = 0;
    this.triggerTime = 0;
  }

  check(metrics) {
    const value = this.condition(metrics);
    const isExceeded = value > this.threshold;

    if (isExceeded) {
      if (!this.triggered) {
        this.triggered = true;
        this.triggerTime = Date.now();
        this.triggerCount = 1;
      } else {
        this.triggerCount++;
      }

      // 持续时间达到阈值
      const duration = Date.now() - this.triggerTime;
      if (duration >= this.duration) {
        // 冷却期检查
        if (Date.now() - this.lastAlert >= this.cooldown) {
          this.lastAlert = Date.now();
          return {
            alert: true,
            rule: this.name,
            value: value,
            threshold: this.threshold,
            duration: duration,
            count: this.triggerCount
          };
        }
      }
    } else {
      // 重置
      this.triggered = false;
      this.triggerCount = 0;
    }

    return { alert: false };
  }
}

// 告警引擎
class AlertEngine {
  constructor() {
    this.rules = [];
    this.channels = new Map();
  }

  addRule(config) {
    const rule = new AlertRule(config);
    this.rules.push(rule);
    return rule;
  }

  addChannel(name, handler) {
    this.channels.set(name, handler);
  }

  check(metrics) {
    const alerts = [];

    for (const rule of this.rules) {
      const result = rule.check(metrics);

      if (result.alert) {
        alerts.push(result);
        this.sendAlert(rule, result);
      }
    }

    return alerts;
  }

  sendAlert(rule, alert) {
    for (const channelName of rule.channels) {
      const handler = this.channels.get(channelName);

      if (handler) {
        handler(alert);
      }
    }
  }
}

// 使用
const alertEngine = new AlertEngine();

// 添加告警渠道
alertEngine.addChannel('email', (alert) => {
  sendEmail({
    to: 'admin@example.com',
    subject: `告警: ${alert.rule}`,
    body: `
      规则: ${alert.rule}
      当前值: ${alert.value}
      阈值: ${alert.threshold}
      持续时间: ${alert.duration}ms
    `
  });
});

alertEngine.addChannel('sms', (alert) => {
  sendSMS({
    to: '+1234567890',
    message: `告警: ${alert.rule}, 当前值: ${alert.value}`
  });
});

alertEngine.addChannel('webhook', (alert) => {
  fetch('https://hooks.slack.com/xxx', {
    method: 'POST',
    body: JSON.stringify({
      text: `告警: ${alert.rule}\n当前值: ${alert.value}\n阈值: ${alert.threshold}`
    })
  });
});

// 添加规则
alertEngine.addRule({
  name: '错误率过高',
  condition: (metrics) => {
    return (metrics.errors / metrics.requests) * 100;
  },
  threshold: 5, // 5%
  duration: 60000, // 持续1分钟
  cooldown: 300000, // 5分钟内不重复告警
  channels: ['email', 'sms', 'webhook']
});

alertEngine.addRule({
  name: '响应时间过长',
  condition: (metrics) => metrics.avgResponseTime,
  threshold: 1000, // 1秒
  duration: 120000, // 持续2分钟
  channels: ['email']
});

alertEngine.addRule({
  name: '内存使用过高',
  condition: (metrics) => metrics.memoryUsage,
  threshold: 900, // 900MB
  duration: 60000,
  channels: ['email', 'webhook']
});

// 定时检查
setInterval(() => {
  const metrics = collector.getMetrics();
  alertEngine.check(metrics);
}, 10000); // 每10秒检查一次
```

## 总结

完整的前端监控系统包括：

1. **性能监控**
   - Web Vitals (LCP, FID, CLS, FCP, TTFB)
   - Navigation Timing
   - 资源加载监控
   - 长任务监控
   - FPS监控

2. **错误监控**
   - JavaScript错误
   - Promise错误
   - 资源加载错误
   - 接口错误
   - 框架错误（Vue/React）

3. **行为监控**
   - PV/UV统计
   - 用户点击
   - 页面停留时间
   - 路由变化

4. **数据上报**
   - 批量上报
   - 采样策略
   - 数据压缩
   - 去重策略

5. **错误分析**
   - SourceMap解析
   - 错误聚合
   - 错误分类

6. **Node.js监控**
   - 进程管理
   - 内存监控
   - CPU监控
   - 集群管理

7. **告警系统**
   - 规则引擎
   - 多渠道告警
   - 告警去重

这套监控系统能够全面覆盖前端应用的各个方面，帮助快速发现和定位问题。
