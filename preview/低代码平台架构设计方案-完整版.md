# 低代码平台架构设计方案 - 从简入深完整指南

## 目录

1. [低代码平台核心概念](#一低代码平台核心概念)
2. [阶段一:最简实现](#二阶段一最简实现---单体架构)
3. [阶段二:物料独立](#三阶段二物料独立---插件化架构)
4. [阶段三:企业级方案](#四阶段三企业级方案---微内核架构)
5. [运行时能力设计](#五运行时能力设计)
6. [构建工具链设计](#六构建工具链设计)
7. [物料生态体系](#七物料生态体系)
8. [性能与安全](#八性能与安全)
9. [实战案例](#九实战案例)

---

## 一、低代码平台核心概念

### 1.1 什么是低代码平台?

低代码平台的本质是:**将开发过程可视化,通过拖拽配置生成应用,而非手写代码**。

核心工作流:
```
┌─────────────┐      ┌──────────┐      ┌─────────────┐      ┌──────────┐
│  可视化编辑  │ ---> │  Schema  │ ---> │  渲染引擎   │ ---> │ 运行应用 │
│  (设计器)   │      │  (JSON)  │      │ (Runtime)  │      │          │
└─────────────┘      └──────────┘      └─────────────┘      └──────────┘
```

### 1.2 核心组成部分

```
┌─────────────────────────────────────────────────────────────┐
│                        低代码平台                             │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │   设计器      │  │   物料库      │  │   渲染引擎    │      │
│  │   Designer   │  │   Materials  │  │   Renderer   │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│         │                  │                  │              │
│         └──────────────────┼──────────────────┘              │
│                            ↓                                 │
│                     ┌──────────────┐                         │
│                     │    Schema    │                         │
│                     │    协议      │                         │
│                     └──────────────┘                         │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

**三大核心:**

1. **Schema协议**: 页面的JSON描述语言
2. **物料体系**: 可被拖拽使用的组件
3. **渲染引擎**: 将Schema转换为真实UI

### 1.3 Schema协议示例

```json
{
  "version": "1.0.0",
  "componentTree": {
    "componentName": "Page",
    "props": { "title": "用户列表" },
    "children": [
      {
        "componentName": "Button",
        "props": {
          "type": "primary",
          "children": "新增用户"
        },
        "events": {
          "onClick": {
            "type": "navigate",
            "payload": { "url": "/user/create" }
          }
        }
      }
    ]
  }
}
```

**Schema的关键特性:**
- **声明式**: 描述"是什么",而非"怎么做"
- **可序列化**: 纯JSON,可存储、传输、版本管理
- **可解析**: 渲染引擎可理解并执行

---

## 二、阶段一:最简实现 - 单体架构

> **适用场景**: MVP验证、小型团队、快速迭代
> **特点**: 所有代码在一个项目中,物料内置,架构简单

### 2.1 项目结构

```
lowcode-platform/
├── src/
│   ├── designer/              # 设计器
│   │   ├── Canvas.jsx         # 画布
│   │   ├── MaterialPanel.jsx  # 物料面板
│   │   ├── SettingPanel.jsx   # 属性配置
│   │   └── Toolbar.jsx        # 工具栏
│   │
│   ├── renderer/              # 渲染引擎
│   │   ├── Renderer.jsx       # 核心渲染器
│   │   ├── ExpressionParser.js # 表达式解析
│   │   └── EventHandler.js    # 事件处理
│   │
│   ├── materials/             # 物料(内置)
│   │   ├── Button/
│   │   ├── Input/
│   │   ├── Table/
│   │   └── index.js           # 物料注册
│   │
│   ├── schema/                # Schema相关
│   │   └── protocol.js        # Schema协议定义
│   │
│   └── App.jsx                # 入口
│
└── package.json
```

### 2.2 最简渲染引擎实现

```javascript
// renderer/Renderer.jsx
import React from 'react';
import * as Materials from '../materials';

class SimpleRenderer extends React.Component {
  constructor(props) {
    super(props);
    this.schema = props.schema;
  }

  // 递归渲染组件树
  renderNode(nodeSchema) {
    const { componentName, props, children, id } = nodeSchema;

    // 1. 从物料库获取组件
    const Component = Materials[componentName];
    if (!Component) {
      console.warn(`Component ${componentName} not found`);
      return null;
    }

    // 2. 递归渲染子节点
    const childNodes = children?.map((child, index) =>
      this.renderNode(child)
    );

    // 3. 返回React元素
    return React.createElement(
      Component,
      { key: id, ...props },
      childNodes
    );
  }

  render() {
    return this.renderNode(this.schema.componentTree);
  }
}

export default SimpleRenderer;
```

**使用示例:**
```javascript
// 定义Schema
const schema = {
  componentTree: {
    componentName: 'div',
    props: { className: 'container' },
    children: [
      {
        componentName: 'Button',
        props: { type: 'primary', children: '点击我' }
      }
    ]
  }
};

// 渲染
<SimpleRenderer schema={schema} />
```

### 2.3 物料定义(内置方式)

```javascript
// materials/Button/index.jsx
import React from 'react';
import './style.css';

function Button({ type, children, onClick }) {
  return (
    <button className={`btn btn-${type}`} onClick={onClick}>
      {children}
    </button>
  );
}

// 物料元信息(用于设计器)
Button.meta = {
  title: '按钮',
  category: 'basic',
  props: [
    {
      name: 'type',
      title: '类型',
      type: 'select',
      options: ['primary', 'default', 'danger']
    },
    {
      name: 'children',
      title: '文本',
      type: 'string'
    }
  ]
};

export default Button;
```

```javascript
// materials/index.js - 物料注册
export { default as Button } from './Button';
export { default as Input } from './Input';
export { default as Table } from './Table';
```

### 2.4 简单设计器实现

```javascript
// designer/Designer.jsx
import React, { useState } from 'react';
import MaterialPanel from './MaterialPanel';
import Canvas from './Canvas';
import SettingPanel from './SettingPanel';
import SimpleRenderer from '../renderer/Renderer';
import * as Materials from '../materials';

function Designer() {
  const [schema, setSchema] = useState({
    componentTree: {
      componentName: 'div',
      props: {},
      children: []
    }
  });

  const [selectedNode, setSelectedNode] = useState(null);

  // 添加组件
  const addComponent = (materialName) => {
    const material = Materials[materialName];
    const newNode = {
      id: `node_${Date.now()}`,
      componentName: materialName,
      props: { ...material.meta.defaultProps },
      children: []
    };

    // 简化:直接添加到根节点
    schema.componentTree.children.push(newNode);
    setSchema({ ...schema });
  };

  // 更新属性
  const updateProps = (nodeId, newProps) => {
    // 递归查找并更新节点
    const updateNode = (node) => {
      if (node.id === nodeId) {
        node.props = { ...node.props, ...newProps };
        return true;
      }
      return node.children?.some(updateNode);
    };

    updateNode(schema.componentTree);
    setSchema({ ...schema });
  };

  return (
    <div className="designer-layout">
      {/* 左侧:物料面板 */}
      <MaterialPanel
        materials={Object.keys(Materials)}
        onAdd={addComponent}
      />

      {/* 中间:画布 */}
      <Canvas>
        <SimpleRenderer schema={schema} />
      </Canvas>

      {/* 右侧:属性配置 */}
      <SettingPanel
        node={selectedNode}
        onPropsChange={updateProps}
      />
    </div>
  );
}
```

### 2.5 阶段一总结

**优点:**
- ✅ 结构简单,易于理解和上手
- ✅ 开发效率高,无需复杂的构建配置
- ✅ 适合快速验证想法

**缺点:**
- ❌ 物料内置,无法动态扩展
- ❌ 所有代码耦合在一起,难以维护
- ❌ 无法支持第三方物料
- ❌ 打包体积大(所有物料打包在一起)

**适用场景:**
- MVP阶段
- 团队少于5人
- 物料数量少于20个

---

## 三、阶段二:物料独立 - 插件化架构

> **核心改进**: 物料抽离为独立NPM包,支持按需加载
> **解决问题**: 物料复用、按需加载、第三方扩展

### 3.1 架构演进

```
阶段一(单体):
┌─────────────────────────────────┐
│   lowcode-platform              │
│   ├── designer/                 │
│   ├── renderer/                 │
│   └── materials/ (内置)         │
└─────────────────────────────────┘

                ↓ 演进

阶段二(物料独立):
┌────────────────────┐     ┌──────────────────┐
│ lowcode-platform   │     │  Material Packages│
│ ├── designer/      │     │  @lc/button      │
│ ├── renderer/      │ <-- │  @lc/table       │
│ └── material-      │     │  @lc/form        │
│     registry/      │     │  ...             │
└────────────────────┘     └──────────────────┘
```

### 3.2 物料包结构

```
@lowcode-materials/button/
├── src/
│   ├── Button.jsx           # 组件实现
│   └── index.js             # 导出
│
├── lowcode-meta.json        # 物料元信息
├── package.json
└── README.md

# lowcode-meta.json
{
  "name": "Button",
  "title": "按钮",
  "category": "basic",
  "version": "1.0.0",
  "main": "dist/index.js",
  "props": [
    {
      "name": "type",
      "title": "类型",
      "setter": "SelectSetter",
      "options": ["primary", "default", "danger"]
    }
  ],
  "snippets": {
    "componentName": "Button",
    "props": { "type": "primary", "children": "按钮" }
  }
}
```

### 3.3 物料注册表

```javascript
// material-registry/MaterialRegistry.js
class MaterialRegistry {
  constructor() {
    this.materials = new Map();    // 已加载的物料
    this.metadata = new Map();     // 物料元信息
  }

  // 注册物料
  register(packageName, config) {
    const { component, meta } = config;

    this.materials.set(meta.name, component);
    this.metadata.set(meta.name, {
      packageName,
      ...meta
    });

    console.log(`✅ Material registered: ${meta.name}`);
  }

  // 获取组件
  getComponent(componentName) {
    return this.materials.get(componentName);
  }

  // 获取元信息
  getMeta(componentName) {
    return this.metadata.get(componentName);
  }

  // 获取所有物料列表(用于设计器展示)
  getAllMaterials() {
    return Array.from(this.metadata.values());
  }

  // 动态加载物料包
  async loadMaterialPackage(packageName) {
    try {
      // 方式1: 从CDN加载
      const module = await this.loadFromCDN(packageName);

      // 方式2: 通过import动态导入
      // const module = await import(packageName);

      this.register(packageName, module.default);
      return true;
    } catch (error) {
      console.error(`Failed to load material: ${packageName}`, error);
      return false;
    }
  }

  // 从CDN加载物料
  async loadFromCDN(packageName, version = 'latest') {
    const url = `https://cdn.example.com/materials/${packageName}@${version}/index.js`;

    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = () => {
        // 假设物料包挂载到 window.LowCodeMaterials
        const module = window.LowCodeMaterials[packageName];
        resolve(module);
      };
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
}

export default new MaterialRegistry();
```

### 3.4 渲染引擎升级(支持动态物料)

```javascript
// renderer/Renderer.jsx (升级版)
import React from 'react';
import MaterialRegistry from '../material-registry/MaterialRegistry';

class Renderer extends React.Component {
  constructor(props) {
    super(props);
    this.schema = props.schema;
    this.state = {
      loading: true,
      error: null
    };
  }

  async componentDidMount() {
    // 预加载Schema中用到的所有物料
    await this.preloadMaterials();
  }

  // 预加载物料
  async preloadMaterials() {
    const materialsNeeded = this.collectMaterials(this.schema.componentTree);

    for (const componentName of materialsNeeded) {
      // 检查是否已加载
      if (!MaterialRegistry.getComponent(componentName)) {
        const meta = MaterialRegistry.getMeta(componentName);
        if (meta?.packageName) {
          await MaterialRegistry.loadMaterialPackage(meta.packageName);
        }
      }
    }

    this.setState({ loading: false });
  }

  // 收集Schema中使用的所有组件名
  collectMaterials(node, set = new Set()) {
    if (node.componentName) {
      set.add(node.componentName);
    }
    node.children?.forEach(child => this.collectMaterials(child, set));
    return set;
  }

  // 渲染节点
  renderNode(nodeSchema) {
    const { componentName, props, children, id } = nodeSchema;

    // 从注册表获取组件
    const Component = MaterialRegistry.getComponent(componentName);

    if (!Component) {
      return <div>Component {componentName} not found</div>;
    }

    const childNodes = children?.map(child => this.renderNode(child));

    return React.createElement(
      Component,
      { key: id, ...props },
      childNodes
    );
  }

  render() {
    if (this.state.loading) {
      return <div>Loading materials...</div>;
    }

    return this.renderNode(this.schema.componentTree);
  }
}
```

### 3.5 物料开发工具

为了让开发者方便地开发物料,提供脚手架工具:

```bash
# 创建物料项目
npx @lowcode/create-material my-button

# 项目结构
my-button/
├── src/
│   └── index.jsx
├── demo/                    # 本地预览
│   └── demo.jsx
├── lowcode-meta.json        # 物料元信息
├── package.json
└── README.md
```

```javascript
// 物料开发模板
// src/index.jsx
import React from 'react';

function MyButton({ type, children, onClick }) {
  return (
    <button
      className={`my-btn my-btn-${type}`}
      onClick={onClick}
    >
      {children}
    </button>
  );
}

// 导出配置
export default {
  component: MyButton,
  meta: {
    name: 'MyButton',
    title: '自定义按钮',
    category: 'custom',
    props: [
      {
        name: 'type',
        title: '类型',
        setter: 'SelectSetter',
        options: ['primary', 'secondary']
      }
    ],
    snippets: {
      componentName: 'MyButton',
      props: { type: 'primary', children: '点击' }
    }
  }
};
```

### 3.6 物料发布流程

```bash
# 1. 开发物料
cd my-button
npm run dev        # 本地预览

# 2. 构建
npm run build      # 输出到 dist/

# 3. 发布到NPM
npm publish

# 4. 在低代码平台中安装
npm install @lowcode-materials/my-button

# 5. 注册到平台
import MyButton from '@lowcode-materials/my-button';
MaterialRegistry.register('@lowcode-materials/my-button', MyButton);
```

### 3.7 物料市场

提供一个物料市场,让开发者可以浏览、安装物料:

```javascript
// 物料市场API
class MaterialMarket {
  // 搜索物料
  async search(keyword) {
    const response = await fetch(`/api/materials/search?q=${keyword}`);
    return response.json();
  }

  // 安装物料
  async install(packageName) {
    // 方式1: 后端NPM安装
    await fetch('/api/materials/install', {
      method: 'POST',
      body: JSON.stringify({ packageName })
    });

    // 方式2: 前端动态加载
    await MaterialRegistry.loadMaterialPackage(packageName);
  }

  // 获取物料详情
  async getDetail(packageName) {
    const response = await fetch(`/api/materials/${packageName}`);
    return response.json();
  }
}
```

### 3.8 阶段二总结

**优点:**
- ✅ 物料独立,可复用和发布
- ✅ 支持按需加载,减小打包体积
- ✅ 第三方可以开发和发布物料
- ✅ 物料可以单独版本管理

**缺点:**
- ❌ 物料版本管理复杂
- ❌ 缺少统一的构建规范
- ❌ 物料质量参差不齐
- ❌ 依赖管理困难

**适用场景:**
- 中型团队(5-20人)
- 需要物料复用
- 有第三方物料接入需求

---

## 四、阶段三:企业级方案 - 微内核架构

> **核心升级**: Monorepo管理、统一构建工具、完整的物料生态
> **解决问题**: 大规模团队协作、物料标准化、性能优化

### 4.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        Low-Code Platform                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │  Designer    │  │   Renderer   │  │  Publisher   │          │
│  │  (设计器)     │  │  (渲染引擎)   │  │  (发布系统)   │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
│         │                  │                  │                  │
│         └──────────────────┼──────────────────┘                  │
│                            ↓                                     │
│                   ┌─────────────────┐                            │
│                   │  Core Engine    │                            │
│                   │  (核心引擎)      │                            │
│                   └─────────────────┘                            │
│                            │                                     │
│         ┌──────────────────┼──────────────────┐                 │
│         ↓                  ↓                  ↓                  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │ Plugin      │  │  Material   │  │  Extension  │             │
│  │ System      │  │  System     │  │  API        │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 Monorepo项目结构

```
lowcode-platform/
├── packages/
│   ├── core/                    # 核心引擎
│   │   ├── schema/              # Schema协议
│   │   ├── renderer/            # 渲染引擎
│   │   ├── expression/          # 表达式解析
│   │   └── events/              # 事件系统
│   │
│   ├── designer/                # 设计器
│   │   ├── canvas/              # 画布
│   │   ├── panels/              # 各种面板
│   │   ├── setters/             # 属性配置器
│   │   └── plugins/             # 设计器插件
│   │
│   ├── material-registry/       # 物料注册表
│   │
│   ├── cli/                     # 命令行工具
│   │   ├── create-material/    # 创建物料
│   │   ├── build/               # 构建工具
│   │   └── dev/                 # 开发服务器
│   │
│   ├── materials/               # 官方物料库
│   │   ├── button/
│   │   ├── input/
│   │   ├── table/
│   │   └── ...
│   │
│   └── plugins/                 # 官方插件
│       ├── plugin-datasource/   # 数据源插件
│       ├── plugin-i18n/         # 国际化插件
│       └── ...
│
├── apps/
│   ├── designer-app/            # 设计器应用
│   ├── preview-app/             # 预览应用
│   └── material-market/         # 物料市场
│
├── scripts/                     # 构建脚本
├── lerna.json                   # Lerna配置
├── package.json
└── pnpm-workspace.yaml          # pnpm workspace配置
```

### 4.3 统一构建工具

```javascript
// packages/cli/build/index.js
const { build } = require('vite');
const react = require('@vitejs/plugin-react');

class MaterialBuilder {
  constructor(options) {
    this.options = options;
  }

  // 构建物料包
  async buildMaterial(materialPath) {
    // 读取物料元信息
    const meta = require(`${materialPath}/lowcode-meta.json`);

    // Vite配置
    const config = {
      plugins: [react()],
      build: {
        lib: {
          entry: `${materialPath}/src/index.jsx`,
          name: meta.name,
          formats: ['es', 'umd'],
          fileName: (format) => `index.${format}.js`
        },
        rollupOptions: {
          external: ['react', 'react-dom'],
          output: {
            globals: {
              react: 'React',
              'react-dom': 'ReactDOM'
            }
          }
        },
        outDir: `${materialPath}/dist`
      }
    };

    // 执行构建
    await build(config);

    // 生成物料描述文件
    await this.generateMetadata(materialPath, meta);

    console.log(`✅ Material built: ${meta.name}`);
  }

  // 生成元数据
  async generateMetadata(materialPath, meta) {
    const metadata = {
      ...meta,
      dist: {
        es: 'dist/index.es.js',
        umd: 'dist/index.umd.js'
      },
      buildTime: new Date().toISOString()
    };

    const fs = require('fs');
    fs.writeFileSync(
      `${materialPath}/dist/metadata.json`,
      JSON.stringify(metadata, null, 2)
    );
  }

  // 批量构建
  async buildAll(materialsDir) {
    const fs = require('fs');
    const materials = fs.readdirSync(materialsDir);

    for (const material of materials) {
      const materialPath = `${materialsDir}/${material}`;
      await this.buildMaterial(materialPath);
    }
  }
}

// CLI使用
// npx lowcode-build --material ./packages/materials/button
```

### 4.4 物料资源发布系统

```javascript
// 物料发布平台
class MaterialPublisher {
  constructor(registry) {
    this.registry = registry;  // NPM或私有registry
    this.cdn = 'https://cdn.example.com';
  }

  // 发布物料
  async publish(materialPath) {
    // 1. 构建
    await new MaterialBuilder().buildMaterial(materialPath);

    // 2. 发布到NPM
    await this.publishToNPM(materialPath);

    // 3. 上传到CDN
    await this.uploadToCDN(materialPath);

    // 4. 更新物料索引
    await this.updateIndex(materialPath);
  }

  // 发布到NPM
  async publishToNPM(materialPath) {
    const { exec } = require('child_process');
    const meta = require(`${materialPath}/package.json`);

    return new Promise((resolve, reject) => {
      exec(`cd ${materialPath} && npm publish`, (error, stdout) => {
        if (error) reject(error);
        else resolve(stdout);
      });
    });
  }

  // 上传到CDN
  async uploadToCDN(materialPath) {
    const meta = require(`${materialPath}/lowcode-meta.json`);
    const version = require(`${materialPath}/package.json`).version;

    // 上传构建产物
    const distFiles = ['index.es.js', 'index.umd.js', 'metadata.json'];

    for (const file of distFiles) {
      const localPath = `${materialPath}/dist/${file}`;
      const remotePath = `${this.cdn}/materials/${meta.name}@${version}/${file}`;

      await this.uploadFile(localPath, remotePath);
    }
  }

  // 更新物料索引
  async updateIndex(materialPath) {
    const meta = require(`${materialPath}/dist/metadata.json`);

    // 发送到物料市场后端
    await fetch('/api/materials/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(meta)
    });
  }
}
```

### 4.5 物料版本管理

```javascript
// 物料版本管理器
class MaterialVersionManager {
  constructor() {
    this.registry = new Map(); // 物料名 -> 版本列表
  }

  // 注册物料版本
  register(name, version, url) {
    if (!this.registry.has(name)) {
      this.registry.set(name, []);
    }

    this.registry.get(name).push({
      version,
      url,
      loadedAt: null,
      instance: null
    });
  }

  // 获取特定版本
  async load(name, version = 'latest') {
    const versions = this.registry.get(name);
    if (!versions) {
      throw new Error(`Material ${name} not found`);
    }

    // 解析版本
    const targetVersion = version === 'latest'
      ? this.getLatestVersion(versions)
      : versions.find(v => v.version === version);

    if (!targetVersion) {
      throw new Error(`Version ${version} of ${name} not found`);
    }

    // 已加载则直接返回
    if (targetVersion.instance) {
      return targetVersion.instance;
    }

    // 动态加载
    const module = await this.loadModule(targetVersion.url);
    targetVersion.instance = module;
    targetVersion.loadedAt = Date.now();

    return module;
  }

  // 获取最新版本
  getLatestVersion(versions) {
    return versions.sort((a, b) =>
      this.compareVersion(b.version, a.version)
    )[0];
  }

  // 版本比较
  compareVersion(v1, v2) {
    const parts1 = v1.split('.').map(Number);
    const parts2 = v2.split('.').map(Number);

    for (let i = 0; i < 3; i++) {
      if (parts1[i] > parts2[i]) return 1;
      if (parts1[i] < parts2[i]) return -1;
    }
    return 0;
  }
}
```

### 4.6 Schema版本升级

```javascript
// Schema迁移工具
class SchemaMigration {
  constructor() {
    this.migrations = new Map();
  }

  // 注册迁移规则
  register(fromVersion, toVersion, migrateFn) {
    const key = `${fromVersion}->${toVersion}`;
    this.migrations.set(key, migrateFn);
  }

  // 执行迁移
  migrate(schema, targetVersion) {
    const currentVersion = schema.version;

    if (currentVersion === targetVersion) {
      return schema;
    }

    // 找到迁移路径
    const path = this.findMigrationPath(currentVersion, targetVersion);

    // 依次执行迁移
    let migratedSchema = { ...schema };
    for (let i = 0; i < path.length - 1; i++) {
      const from = path[i];
      const to = path[i + 1];
      const key = `${from}->${to}`;
      const migrateFn = this.migrations.get(key);

      if (migrateFn) {
        migratedSchema = migrateFn(migratedSchema);
        migratedSchema.version = to;
      }
    }

    return migratedSchema;
  }

  // 查找迁移路径
  findMigrationPath(from, to) {
    // 简化实现:假设版本是递增的
    const versions = ['1.0.0', '1.1.0', '2.0.0', '2.1.0'];
    const fromIndex = versions.indexOf(from);
    const toIndex = versions.indexOf(to);

    return versions.slice(fromIndex, toIndex + 1);
  }
}

// 使用示例
const migration = new SchemaMigration();

// 注册v1.0 -> v1.1迁移
migration.register('1.0.0', '1.1.0', (schema) => {
  // 示例:将旧的events格式转换为新格式
  const transform = (node) => {
    if (node.events) {
      node.handlers = node.events; // 重命名
      delete node.events;
    }
    node.children?.forEach(transform);
  };

  transform(schema.componentTree);
  return schema;
});

// 执行迁移
const oldSchema = { version: '1.0.0', /* ... */ };
const newSchema = migration.migrate(oldSchema, '1.1.0');
```

### 4.7 插件系统

```javascript
// 核心插件系统
class PluginSystem {
  constructor() {
    this.plugins = [];
    this.hooks = {
      beforeRender: [],
      afterRender: [],
      onSchemaChange: [],
      onComponentAdd: []
    };
  }

  // 注册插件
  use(plugin) {
    if (typeof plugin.install === 'function') {
      plugin.install(this);
      this.plugins.push(plugin);
    }
  }

  // 注册钩子
  registerHook(hookName, callback) {
    if (this.hooks[hookName]) {
      this.hooks[hookName].push(callback);
    }
  }

  // 触发钩子
  async triggerHook(hookName, ...args) {
    const hooks = this.hooks[hookName] || [];

    for (const hook of hooks) {
      await hook(...args);
    }
  }
}

// 插件示例:数据源插件
class DataSourcePlugin {
  install(platform) {
    // 扩展Schema协议
    platform.registerHook('beforeRender', (schema) => {
      // 初始化数据源
      this.initDataSources(schema.dataSources);
    });

    // 注册动作
    platform.actionRegistry.register('fetchDataSource', (payload) => {
      this.fetchDataSource(payload.id);
    });
  }

  initDataSources(dataSources) {
    // 数据源初始化逻辑
  }

  fetchDataSource(id) {
    // 数据源请求逻辑
  }
}

// 使用插件
const platform = new LowCodePlatform();
platform.use(new DataSourcePlugin());
```

### 4.8 性能优化

```javascript
// 按需加载物料
class LazyMaterialLoader {
  constructor() {
    this.cache = new Map();
    this.loading = new Map();
  }

  // 懒加载物料
  async load(componentName) {
    // 1. 检查缓存
    if (this.cache.has(componentName)) {
      return this.cache.get(componentName);
    }

    // 2. 防止重复加载
    if (this.loading.has(componentName)) {
      return this.loading.get(componentName);
    }

    // 3. 开始加载
    const promise = this.doLoad(componentName);
    this.loading.set(componentName, promise);

    try {
      const component = await promise;
      this.cache.set(componentName, component);
      return component;
    } finally {
      this.loading.delete(componentName);
    }
  }

  async doLoad(componentName) {
    // 从CDN加载
    const url = `/materials/${componentName}/index.js`;
    const module = await import(url);
    return module.default;
  }
}

// 虚拟滚动优化
class VirtualScroll extends React.Component {
  render() {
    const { items, itemHeight, containerHeight } = this.props;
    const [scrollTop, setScrollTop] = useState(0);

    // 计算可视区域
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.ceil((scrollTop + containerHeight) / itemHeight);
    const visibleItems = items.slice(startIndex, endIndex);

    return (
      <div
        style={{ height: containerHeight, overflow: 'auto' }}
        onScroll={(e) => setScrollTop(e.target.scrollTop)}
      >
        <div style={{ height: items.length * itemHeight, position: 'relative' }}>
          {visibleItems.map((item, index) => (
            <div
              key={startIndex + index}
              style={{
                position: 'absolute',
                top: (startIndex + index) * itemHeight,
                height: itemHeight
              }}
            >
              {this.props.renderItem(item)}
            </div>
          ))}
        </div>
      </div>
    );
  }
}
```

### 4.9 阶段三总结

**优点:**
- ✅ 完善的工程化体系
- ✅ 统一的构建和发布流程
- ✅ 支持大规模团队协作
- ✅ 完善的物料生态
- ✅ 高性能、可扩展

**缺点:**
- ❌ 架构复杂,学习成本高
- ❌ 需要专业的运维团队
- ❌ 初期投入大

**适用场景:**
- 大型企业(>50人)
- 多团队协作
- 需要完整的物料生态

---

## 五、运行时能力设计

> **核心能力**: 事件处理、状态管理、数据流、组件通信
> **解决问题**: 复杂页面逻辑、数据交互、业务流程编排

### 5.1 运行时核心模块

```
┌─────────────────────────────────────────────────────────────┐
│                     Low-Code Runtime                          │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  Event       │  │   State      │  │  DataSource  │      │
│  │  System      │  │   Manager    │  │  Manager     │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│         │                  │                  │              │
│         └──────────────────┼──────────────────┘              │
│                            ↓                                 │
│                   ┌─────────────────┐                        │
│                   │  Expression     │                        │
│                   │  Engine         │                        │
│                   └─────────────────┘                        │
│                            │                                 │
│                            ↓                                 │
│                   ┌─────────────────┐                        │
│                   │  Action         │                        │
│                   │  Executor       │                        │
│                   └─────────────────┘                        │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 Schema扩展协议

在基础Schema基础上,扩展运行时能力:

```json
{
  "version": "1.0.0",
  "componentTree": { /* 组件树 */ },

  // 新增:全局状态定义
  "state": {
    "userInfo": null,
    "loading": false,
    "tableData": []
  },

  // 新增:数据源定义
  "dataSources": [
    {
      "id": "userApi",
      "type": "http",
      "config": {
        "url": "/api/users",
        "method": "GET"
      }
    }
  ],

  // 新增:生命周期
  "lifeCycles": {
    "onMount": [
      { "type": "setState", "payload": { "loading": true } },
      { "type": "fetchDataSource", "payload": { "id": "userApi" } }
    ]
  },

  // 新增:全局方法
  "methods": {
    "handleDelete": {
      "params": ["id"],
      "actions": [
        { "type": "confirm", "payload": { "message": "确认删除?" } },
        { "type": "request", "payload": { "url": "/api/users/${id}", "method": "DELETE" } }
      ]
    }
  }
}
```

### 5.3 事件系统

**事件绑定方式:**

```json
{
  "componentName": "Button",
  "events": {
    // 方式1: 简单动作
    "onClick": {
      "type": "setState",
      "payload": { "loading": true }
    },

    // 方式2: 动作序列
    "onClick": [
      { "type": "validateForm", "payload": { "formId": "userForm" } },
      { "type": "request", "payload": { "url": "/api/submit" } },
      { "type": "navigate", "payload": { "url": "/success" } }
    ],

    // 方式3: 调用全局方法
    "onClick": {
      "type": "callMethod",
      "payload": { "method": "handleSubmit" }
    }
  }
}
```

**事件系统实现:**

```javascript
// runtime/EventSystem.js
class EventSystem {
  constructor(runtime) {
    this.runtime = runtime;
  }

  // 创建事件处理器
  createEventHandler(nodeId, eventName, eventConfig) {
    return async (event, ...args) => {
      try {
        // 执行事件处理
        const result = await this.executeEvent(eventConfig, {
          event,
          args,
          nodeId
        });
        return result;
      } catch (error) {
        console.error(`Event execution failed:`, error);
      }
    };
  }

  // 执行事件(支持单个动作或动作序列)
  async executeEvent(eventConfig, context) {
    if (eventConfig.type) {
      return await this.executeAction(eventConfig, context);
    }

    if (Array.isArray(eventConfig)) {
      return await this.executeActionSequence(eventConfig, context);
    }
  }

  // 执行单个动作
  async executeAction(action, context) {
    const executor = this.runtime.actionRegistry.get(action.type);
    const payload = this.resolvePayload(action.payload, context);
    return await executor.execute(payload, context);
  }

  // 执行动作序列
  async executeActionSequence(actions, context) {
    const results = [];
    for (const action of actions) {
      // 支持条件执行
      if (action.condition) {
        const shouldExecute = this.runtime.expression.evaluate(
          action.condition,
          context
        );
        if (!shouldExecute) continue;
      }

      const result = await this.executeAction(action, context);
      results.push(result);

      // 支持错误中断
      if (result.error && action.stopOnError) {
        break;
      }
    }
    return results;
  }
}
```

### 5.4 状态管理

使用Zustand实现响应式状态管理:

```javascript
// runtime/StateManager.js
import { createStore } from 'zustand';
import { immer } from 'zustand/middleware/immer';

class StateManager {
  constructor(initialState = {}) {
    this.store = createStore(
      immer((set, get) => ({
        ...initialState,

        setState: (updater) => {
          set((state) => {
            if (typeof updater === 'function') {
              updater(state);
            } else {
              Object.assign(state, updater);
            }
          });
        },

        getState: () => get()
      }))
    );
  }

  // 获取状态(支持路径访问)
  getState(path) {
    const state = this.store.getState();
    if (!path) return state;

    // 支持 "user.name" 路径访问
    return path.split('.').reduce((obj, key) => obj?.[key], state);
  }

  // 设置状态
  setState(updates) {
    this.store.getState().setState(updates);
  }

  // 订阅状态变化
  subscribe(listener) {
    return this.store.subscribe(listener);
  }
}
```

### 5.5 数据源管理

支持HTTP/GraphQL等多种数据源:

```javascript
// runtime/DataSourceManager.js
class DataSourceManager {
  constructor(runtime) {
    this.runtime = runtime;
    this.dataSources = new Map();
  }

  // 注册数据源
  register(dataSourceConfig) {
    const { id, type, config } = dataSourceConfig;
    this.dataSources.set(id, {
      id,
      type,
      config,
      loading: false,
      data: null,
      error: null
    });

    // 自动加载
    if (config.autoLoad) {
      this.load(id);
    }
  }

  // 加载数据
  async load(id, params = {}) {
    const dataSource = this.dataSources.get(id);
    if (!dataSource) throw new Error(`DataSource "${id}" not found`);

    dataSource.loading = true;
    this.updateState(id, { loading: true, error: null });

    try {
      const data = await this.executeLoad(dataSource, params);

      dataSource.data = data;
      dataSource.loading = false;

      this.updateState(id, { data, loading: false });
      return data;
    } catch (error) {
      dataSource.error = error;
      this.updateState(id, { loading: false, error: error.message });
      throw error;
    }
  }

  // 执行加载
  async executeLoad(dataSource, params) {
    const { type, config } = dataSource;

    switch (type) {
      case 'http':
        const { url, method = 'GET', headers = {} } = config;
        const response = await fetch(this.resolveUrl(url, params), {
          method,
          headers: { 'Content-Type': 'application/json', ...headers },
          body: method !== 'GET' ? JSON.stringify(params.data) : undefined
        });
        return await response.json();

      case 'graphql':
        // GraphQL实现
        break;

      case 'static':
        return config.data;
    }
  }

  // 解析URL变量: /api/users/${id}
  resolveUrl(url, params) {
    return url.replace(/\${(\w+)}/g, (match, key) => {
      return params[key] ?? this.runtime.state.getState(key) ?? match;
    });
  }

  // 更新到全局状态
  updateState(id, updates) {
    this.runtime.state.setState({
      [`dataSource_${id}`]: updates
    });
  }
}
```

### 5.6 组件通信

**1. 父子组件通信(Props)**

```json
{
  "componentName": "UserList",
  "props": {
    "users": "${state.users}",
    "onDelete": {
      "type": "callMethod",
      "payload": { "method": "handleDelete" }
    }
  }
}
```

**2. 兄弟组件通信(EventBus)**

```javascript
// runtime/EventBus.js
class EventBus {
  constructor() {
    this.events = new Map();
  }

  // 订阅事件
  on(eventName, callback) {
    if (!this.events.has(eventName)) {
      this.events.set(eventName, []);
    }
    this.events.get(eventName).push(callback);

    return () => this.off(eventName, callback);
  }

  // 触发事件
  async emit(eventName, data) {
    const listeners = this.events.get(eventName) || [];
    const results = [];

    for (const listener of listeners) {
      const result = await listener(data);
      results.push(result);
    }

    return results;
  }
}
```

**Schema中的通信配置:**

```json
{
  "componentTree": {
    "children": [
      // 组件A: 发送消息
      {
        "componentName": "Button",
        "events": {
          "onClick": {
            "type": "emitEvent",
            "payload": {
              "eventName": "refreshList",
              "data": { "timestamp": "${Date.now()}" }
            }
          }
        }
      },

      // 组件B: 接收消息
      {
        "componentName": "Table",
        "listeners": {
          "refreshList": [
            { "type": "fetchDataSource", "payload": { "id": "tableData" } }
          ]
        }
      }
    ]
  }
}
```

### 5.7 动作系统

**内置15+常用动作:**

```javascript
class ActionRegistry {
  registerBuiltinActions() {
    // 1. 状态管理
    this.register('setState', {
      execute: async (payload) => {
        this.runtime.state.setState(payload);
      }
    });

    // 2. 数据请求
    this.register('request', {
      execute: async ({ url, method = 'GET', data }) => {
        const response = await fetch(url, {
          method,
          headers: { 'Content-Type': 'application/json' },
          body: data ? JSON.stringify(data) : undefined
        });
        return await response.json();
      }
    });

    // 3. 数据源加载
    this.register('fetchDataSource', {
      execute: async ({ id, params }) => {
        return await this.runtime.dataSource.load(id, params);
      }
    });

    // 4. 页面导航
    this.register('navigate', {
      execute: async ({ url, replace = false }) => {
        replace ? window.location.replace(url) : window.location.href = url;
      }
    });

    // 5. 消息提示
    this.register('message', {
      execute: async ({ type = 'info', content }) => {
        window.antdMessage?.[type](content);
      }
    });

    // 6. 确认对话框
    this.register('confirm', {
      execute: async ({ message }) => {
        return window.confirm(message);
      }
    });

    // 7-8. 弹窗管理
    this.register('openModal', { /* ... */ });
    this.register('closeModal', { /* ... */ });

    // 9-10. 表单操作
    this.register('validateForm', { /* ... */ });
    this.register('resetForm', { /* ... */ });

    // 11. 触发事件
    this.register('emitEvent', { /* ... */ });

    // 12. 调用方法
    this.register('callMethod', { /* ... */ });

    // 13. 延迟执行
    this.register('delay', { /* ... */ });

    // 14. 条件执行
    this.register('condition', { /* ... */ });

    // 15. 循环执行
    this.register('loop', { /* ... */ });
  }
}
```

**自定义动作:**

```javascript
// 注册自定义动作
runtime.actionRegistry.register('customUpload', {
  execute: async ({ file, onProgress, onSuccess }) => {
    const formData = new FormData();
    formData.append('file', file);

    const xhr = new XMLHttpRequest();
    xhr.upload.onprogress = (e) => {
      const percent = (e.loaded / e.total) * 100;
      runtime.eventSystem.executeEvent(onProgress, { percent });
    };

    xhr.open('POST', '/api/upload');
    xhr.send(formData);
  }
});
```

### 5.8 表达式引擎

**支持的表达式类型:**

```javascript
// 1. 状态访问
"${state.userName}"
"${state.user.profile.email}"

// 2. 数据源访问
"${dataSource.userList.data}"

// 3. 计算表达式
"${state.price * state.quantity}"
"${state.users.length > 0}"

// 4. 函数调用
"${state.users.filter(u => u.age > 18)}"
"${state.name.toUpperCase()}"

// 5. 三元表达式
"${state.isVip ? 'VIP用户' : '普通用户'}"

// 6. 模板字符串
"`用户: ${state.userName}, 年龄: ${state.age}`"
```

**表达式引擎实现:**

```javascript
// runtime/ExpressionEngine.js
class ExpressionEngine {
  constructor(runtime) {
    this.runtime = runtime;
    this.cache = new Map(); // 表达式缓存
  }

  // 评估表达式
  evaluate(expression, extraContext = {}) {
    if (typeof expression !== 'string' || !expression.includes('${')) {
      return expression;
    }

    // 检查缓存
    let compiledFn = this.cache.get(expression);
    if (!compiledFn) {
      compiledFn = this.compile(expression);
      this.cache.set(expression, compiledFn);
    }

    // 构建上下文
    const context = {
      state: this.runtime.state.getState(),
      dataSource: this.getDataSourceContext(),
      ...extraContext
    };

    try {
      return compiledFn(context);
    } catch (error) {
      console.error('Expression error:', error);
      return undefined;
    }
  }

  // 编译表达式
  compile(expression) {
    const code = expression.slice(2, -1); // 去除 ${ }

    return new Function('context', `
      with(context) {
        return ${code};
      }
    `);
  }

  // 获取数据源上下文
  getDataSourceContext() {
    const context = {};
    this.runtime.dataSource.dataSources.forEach((ds, id) => {
      context[id] = {
        data: ds.data,
        loading: ds.loading,
        error: ds.error
      };
    });
    return context;
  }
}
```

### 5.9 完整运行时实现

```javascript
// runtime/LowCodeRuntime.js
class LowCodeRuntime {
  constructor(schema) {
    this.schema = schema;

    // 初始化各个管理器
    this.state = new StateManager(schema.state || {});
    this.eventBus = new EventBus();
    this.expression = new ExpressionEngine(this);
    this.actionRegistry = new ActionRegistry(this);
    this.eventSystem = new EventSystem(this);
    this.dataSource = new DataSourceManager(this);

    this.init();
  }

  async init() {
    // 注册数据源
    if (this.schema.dataSources) {
      this.schema.dataSources.forEach(ds => {
        this.dataSource.register(ds);
      });
    }

    // 执行生命周期
    if (this.schema.lifeCycles?.onMount) {
      await this.eventSystem.executeActionSequence(
        this.schema.lifeCycles.onMount,
        {}
      );
    }
  }

  destroy() {
    if (this.schema.lifeCycles?.onUnmount) {
      this.eventSystem.executeActionSequence(
        this.schema.lifeCycles.onUnmount,
        {}
      );
    }
    this.eventBus.clear();
  }
}
```

### 5.10 在渲染器中集成

```javascript
// renderer/Renderer.jsx
function Renderer({ schema }) {
  const [runtime] = React.useState(() => new LowCodeRuntime(schema));

  useEffect(() => {
    return () => runtime.destroy();
  }, []);

  const renderNode = (nodeSchema) => {
    const { id, componentName, props, children, events } = nodeSchema;

    const Component = MaterialRegistry.getComponent(componentName);
    if (!Component) return null;

    // 解析props中的表达式
    const resolvedProps = runtime.expression.evaluateObject(props);

    // 创建事件处理器
    const eventHandlers = {};
    if (events) {
      for (const [eventName, eventConfig] of Object.entries(events)) {
        eventHandlers[eventName] = runtime.eventSystem.createEventHandler(
          id,
          eventName,
          eventConfig
        );
      }
    }

    const childNodes = children?.map(child => renderNode(child));

    return React.createElement(
      Component,
      { key: id, ...resolvedProps, ...eventHandlers },
      childNodes
    );
  };

  return renderNode(schema.componentTree);
}
```

### 5.11 完整案例:用户管理页面

```json
{
  "state": {
    "users": [],
    "modalVisible": false,
    "selectedUser": null
  },

  "dataSources": [
    {
      "id": "userList",
      "type": "http",
      "config": { "url": "/api/users", "autoLoad": true }
    }
  ],

  "methods": {
    "handleDelete": {
      "params": ["userId"],
      "actions": [
        { "type": "confirm", "payload": { "message": "确认删除?" } },
        { "type": "request", "payload": { "url": "/api/users/${params[0]}", "method": "DELETE" } },
        { "type": "message", "payload": { "type": "success", "content": "删除成功" } },
        { "type": "fetchDataSource", "payload": { "id": "userList" } }
      ]
    },

    "handleEdit": {
      "params": ["user"],
      "actions": [
        { "type": "setState", "payload": { "selectedUser": "${params[0]}", "modalVisible": true } }
      ]
    }
  },

  "componentTree": {
    "componentName": "Page",
    "children": [
      {
        "componentName": "Button",
        "props": { "children": "新增用户" },
        "events": {
          "onClick": {
            "type": "setState",
            "payload": { "selectedUser": null, "modalVisible": true }
          }
        }
      },
      {
        "componentName": "Table",
        "props": {
          "dataSource": "${dataSource.userList.data}",
          "loading": "${dataSource.userList.loading}",
          "columns": [
            { "title": "用户名", "dataIndex": "username" },
            { "title": "邮箱", "dataIndex": "email" },
            {
              "title": "操作",
              "render": {
                "componentName": "Space",
                "children": [
                  {
                    "componentName": "Button",
                    "props": { "children": "编辑" },
                    "events": {
                      "onClick": {
                        "type": "callMethod",
                        "payload": { "method": "handleEdit", "params": ["${record}"] }
                      }
                    }
                  },
                  {
                    "componentName": "Button",
                    "props": { "children": "删除", "danger": true },
                    "events": {
                      "onClick": {
                        "type": "callMethod",
                        "payload": { "method": "handleDelete", "params": ["${record.id}"] }
                      }
                    }
                  }
                ]
              }
            }
          ]
        }
      }
    ]
  }
}
```

### 5.12 运行时能力总结

**核心能力:**
1. ✅ **事件系统** - 4种事件绑定方式,支持动作序列
2. ✅ **状态管理** - 基于Zustand的响应式状态
3. ✅ **数据源** - HTTP/GraphQL,支持缓存和自动加载
4. ✅ **组件通信** - Props、EventBus、Context多种方式
5. ✅ **动作系统** - 15+内置动作,可扩展自定义
6. ✅ **表达式引擎** - 支持复杂表达式和模板字符串

**技术亮点:**
- 完全Schema驱动,配置化管理复杂逻辑
- 响应式数据流,自动更新UI
- 沙箱化表达式执行,保证安全
- 插件化架构,易于扩展

**适用场景:**
- 中后台管理系统(CRUD操作)
- 数据大屏(数据展示和实时更新)
- 表单应用(复杂表单和校验)
- 工作流系统(流程编排)

---

## 六、构建工具链设计

### 6.1 CLI工具

```javascript
// packages/cli/index.js
const { Command } = require('commander');
const program = new Command();

program
  .name('lowcode-cli')
  .description('Low-Code Platform CLI')
  .version('1.0.0');

// 创建物料
program
  .command('create <name>')
  .description('Create a new material')
  .option('-t, --template <type>', 'Material template', 'basic')
  .action(async (name, options) => {
    const creator = require('./commands/create');
    await creator.create(name, options);
  });

// 开发模式
program
  .command('dev')
  .description('Start development server')
  .option('-p, --port <port>', 'Port number', '3000')
  .action(async (options) => {
    const devServer = require('./commands/dev');
    await devServer.start(options);
  });

// 构建
program
  .command('build')
  .description('Build material')
  .option('-o, --outDir <dir>', 'Output directory', 'dist')
  .action(async (options) => {
    const builder = require('./commands/build');
    await builder.build(options);
  });

// 发布
program
  .command('publish')
  .description('Publish material to registry')
  .option('--registry <url>', 'NPM registry URL')
  .option('--cdn', 'Upload to CDN')
  .action(async (options) => {
    const publisher = require('./commands/publish');
    await publisher.publish(options);
  });

program.parse();
```

### 5.2 开发服务器

```javascript
// packages/cli/commands/dev.js
const express = require('express');
const { createServer } = require('vite');

async function startDevServer(options) {
  const app = express();

  // Vite开发服务器
  const vite = await createServer({
    server: { middlewareMode: true },
    appType: 'custom'
  });

  app.use(vite.middlewares);

  // 物料预览页面
  app.get('/preview', async (req, res) => {
    const template = `
      <!DOCTYPE html>
      <html>
        <head>
          <title>Material Preview</title>
        </head>
        <body>
          <div id="root"></div>
          <script type="module" src="/src/demo/index.jsx"></script>
        </body>
      </html>
    `;
    res.send(await vite.transformIndexHtml('/preview', template));
  });

  const port = options.port || 3000;
  app.listen(port, () => {
    console.log(`🚀 Dev server running at http://localhost:${port}`);
  });
}

module.exports = { start: startDevServer };
```

### 5.3 物料模板

```javascript
// packages/cli/templates/basic/template.js
module.exports = {
  name: '{{name}}',
  files: {
    'src/index.jsx': `
import React from 'react';
import './style.css';

function {{Name}}(props) {
  return (
    <div className="{{name}}">
      {{Name}} Component
    </div>
  );
}

export default {{Name}};
    `,

    'src/style.css': `
.{{name}} {
  padding: 10px;
  border: 1px solid #ccc;
}
    `,

    'lowcode-meta.json': `
{
  "name": "{{Name}}",
  "title": "{{title}}",
  "category": "custom",
  "props": [
    {
      "name": "className",
      "title": "样式类名",
      "type": "string"
    }
  ],
  "snippets": {
    "componentName": "{{Name}}",
    "props": {}
  }
}
    `,

    'package.json': `
{
  "name": "@lowcode-materials/{{name}}",
  "version": "1.0.0",
  "main": "dist/index.js",
  "scripts": {
    "dev": "lowcode-cli dev",
    "build": "lowcode-cli build"
  }
}
    `
  }
};
```

---

## 七、物料生态体系

### 7.1 物料分层

```
┌────────────────────────────────────────┐
│         页面模板 (Page Templates)        │  完整页面
├────────────────────────────────────────┤
│          区块 (Blocks)                  │  组合型组件
├────────────────────────────────────────┤
│       业务组件 (Business Components)    │  业务封装
├────────────────────────────────────────┤
│       基础组件 (Base Components)        │  原子组件
└────────────────────────────────────────┘
```

**示例:**

```javascript
// 1. 基础组件
@lowcode-materials/button
@lowcode-materials/input
@lowcode-materials/table

// 2. 业务组件
@mycompany/user-selector     // 用户选择器
@mycompany/dept-tree         // 部门树

// 3. 区块
@mycompany/login-form-block  // 登录表单区块
@mycompany/user-list-block   // 用户列表区块

// 4. 页面模板
@mycompany/dashboard-template // 仪表盘模板
@mycompany/form-page-template // 表单页模板
```

### 7.2 物料标准规范

```javascript
// 物料包结构规范
{
  "name": "@scope/material-name",
  "version": "1.0.0",
  "description": "物料描述",

  // 入口文件
  "main": "dist/index.js",
  "module": "dist/index.es.js",

  // 依赖
  "peerDependencies": {
    "react": ">=16.8.0",
    "react-dom": ">=16.8.0"
  },

  // 低代码元信息
  "lowcode": {
    "meta": "dist/metadata.json",
    "preview": "dist/preview.png"
  },

  // 其他标准字段
  "keywords": ["lowcode", "material", "component"],
  "license": "MIT"
}
```

### 7.3 物料市场

```javascript
// 物料市场后端API
class MaterialMarketAPI {
  // 获取物料列表
  async list(params) {
    // GET /api/materials?category=basic&keyword=button
    return {
      total: 100,
      items: [
        {
          id: 'mat_001',
          name: '@lc/button',
          title: '按钮',
          description: '基础按钮组件',
          category: 'basic',
          version: '1.0.0',
          downloads: 1000,
          rating: 4.5,
          author: 'lowcode-team',
          preview: 'https://cdn.../preview.png'
        }
      ]
    };
  }

  // 获取物料详情
  async detail(materialId) {
    // GET /api/materials/:id
    return {
      id: 'mat_001',
      name: '@lc/button',
      versions: ['1.0.0', '1.1.0', '2.0.0'],
      readme: '# Button Component\n...',
      metadata: { /* lowcode-meta.json */ },
      dependencies: ['react'],
      demos: [
        { title: '基础用法', code: '...' }
      ]
    };
  }

  // 安装物料
  async install(materialName, version) {
    // POST /api/materials/install
    // 后端执行: npm install @lc/button@1.0.0
    return { success: true };
  }
}
```

---

## 八、性能与安全

### 8.1 渲染性能优化

```javascript
// 1. 组件缓存
const MaterialCache = new Map();

function getCachedComponent(componentName) {
  if (!MaterialCache.has(componentName)) {
    const Component = loadComponent(componentName);
    MaterialCache.set(componentName, React.memo(Component));
  }
  return MaterialCache.get(componentName);
}

// 2. 表达式缓存
class ExpressionCache {
  constructor(maxSize = 1000) {
    this.cache = new Map();
    this.maxSize = maxSize;
  }

  get(key) {
    return this.cache.get(key);
  }

  set(key, value) {
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
}

// 3. 虚拟列表
import { FixedSizeList } from 'react-window';

function LargeList({ items }) {
  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {({ index, style }) => (
        <div style={style}>{items[index]}</div>
      )}
    </FixedSizeList>
  );
}
```

### 8.2 安全防护

```javascript
// 1. 表达式沙箱
class SafeExpressionEvaluator {
  constructor() {
    this.allowedGlobals = ['Math', 'Date', 'JSON', 'Object', 'Array'];
    this.blockedGlobals = ['window', 'document', 'eval', 'Function'];
  }

  evaluate(expression, context) {
    // 检查是否包含危险代码
    if (this.containsDangerousCode(expression)) {
      throw new Error('Expression contains dangerous code');
    }

    // 创建安全上下文
    const safeContext = this.createSafeContext(context);

    // 使用Function构造器(限制作用域)
    try {
      const fn = new Function(
        ...Object.keys(safeContext),
        `return (${expression});`
      );
      return fn(...Object.values(safeContext));
    } catch (error) {
      console.error('Expression evaluation error:', error);
      return null;
    }
  }

  containsDangerousCode(expression) {
    const dangerousPatterns = [
      /eval\s*\(/,
      /Function\s*\(/,
      /\bwindow\b/,
      /\bdocument\b/,
      /__proto__/,
      /constructor/
    ];

    return dangerousPatterns.some(pattern => pattern.test(expression));
  }

  createSafeContext(context) {
    // 只暴露安全的API
    return {
      ...context,
      Math,
      Date,
      JSON: JSON,
      console: {
        log: console.log.bind(console),
        warn: console.warn.bind(console)
      }
    };
  }
}

// 2. XSS防护
import DOMPurify from 'dompurify';

function sanitizeProps(props) {
  const sanitized = {};

  for (const [key, value] of Object.entries(props)) {
    if (typeof value === 'string') {
      // 对字符串内容进行清洗
      sanitized[key] = DOMPurify.sanitize(value);
    } else if (key === 'dangerouslySetInnerHTML') {
      // 禁止使用dangerouslySetInnerHTML
      console.warn('dangerouslySetInnerHTML is not allowed');
      continue;
    } else {
      sanitized[key] = value;
    }
  }

  return sanitized;
}

// 3. 权限控制
class PermissionManager {
  checkPermission(user, action, resource) {
    // 检查用户是否有权限执行某个操作
    const userRoles = user.roles || [];
    const requiredRoles = this.getRequiredRoles(action, resource);

    return requiredRoles.some(role => userRoles.includes(role));
  }

  getRequiredRoles(action, resource) {
    const permissionMap = {
      'schema.edit': ['admin', 'editor'],
      'schema.publish': ['admin'],
      'material.install': ['admin', 'developer']
    };

    const key = `${resource}.${action}`;
    return permissionMap[key] || [];
  }
}
```

---

## 九、实战案例

### 9.1 案例一:表单生成器

```javascript
// 1. 定义表单Schema
const formSchema = {
  componentTree: {
    componentName: 'Form',
    props: {
      layout: 'horizontal',
      onSubmit: { type: 'submitForm', payload: { api: '/api/users' } }
    },
    children: [
      {
        componentName: 'FormItem',
        props: { label: '用户名', name: 'username', rules: [{ required: true }] },
        children: [
          { componentName: 'Input', props: { placeholder: '请输入用户名' } }
        ]
      },
      {
        componentName: 'FormItem',
        props: { label: '邮箱', name: 'email' },
        children: [
          { componentName: 'Input', props: { type: 'email' } }
        ]
      },
      {
        componentName: 'FormItem',
        children: [
          { componentName: 'Button', props: { type: 'primary', htmlType: 'submit', children: '提交' } }
        ]
      }
    ]
  }
};

// 2. 渲染
<Renderer schema={formSchema} />
```

### 9.2 案例二:数据大屏

```javascript
const dashboardSchema = {
  componentTree: {
    componentName: 'DashboardLayout',
    props: { columns: 24, rows: 12 },
    children: [
      {
        componentName: 'ChartCard',
        props: {
          gridArea: { x: 0, y: 0, w: 12, h: 6 },
          title: '销售趋势'
        },
        children: [
          {
            componentName: 'LineChart',
            props: {
              dataSource: '${dataSources.sales.data}',
              xField: 'date',
              yField: 'amount'
            }
          }
        ]
      },
      {
        componentName: 'StatCard',
        props: {
          gridArea: { x: 12, y: 0, w: 6, h: 3 },
          title: '今日订单',
          value: '${dataSources.stats.data.orders}'
        }
      }
    ]
  },
  dataSources: [
    {
      id: 'sales',
      type: 'http',
      config: { url: '/api/sales/trend', method: 'GET' }
    },
    {
      id: 'stats',
      type: 'http',
      config: { url: '/api/stats/today', method: 'GET' }
    }
  ]
};
```

### 9.3 案例三:移动端页面

```javascript
const mobileSchema = {
  platform: 'mobile',
  componentTree: {
    componentName: 'MobilePage',
    props: { title: '商品详情' },
    children: [
      {
        componentName: 'ImageSwiper',
        props: {
          images: '${state.product.images}',
          autoplay: true
        }
      },
      {
        componentName: 'ProductInfo',
        props: {
          title: '${state.product.title}',
          price: '${state.product.price}'
        }
      },
      {
        componentName: 'BottomBar',
        children: [
          {
            componentName: 'Button',
            props: {
              type: 'primary',
              children: '立即购买',
              onClick: { type: 'navigate', payload: { url: '/order' } }
            }
          }
        ]
      }
    ]
  },
  state: {
    product: null
  },
  lifeCycles: {
    onMount: [
      { type: 'fetchDataSource', payload: { id: 'product' } }
    ]
  }
};
```

---

## 十、总结与展望

### 10.1 三阶段对比

| 特性 | 阶段一:最简实现 | 阶段二:物料独立 | 阶段三:企业级 |
|------|----------------|----------------|--------------|
| 物料管理 | 内置 | NPM包 | Monorepo + 物料市场 |
| 构建工具 | 无 | 简单脚本 | 统一CLI工具 |
| 版本管理 | 无 | 基础 | 完善的版本系统 |
| 团队规模 | <5人 | 5-20人 | >50人 |
| 扩展性 | 低 | 中 | 高 |
| 学习成本 | 低 | 中 | 高 |

### 10.2 核心要点回顾

1. **Schema协议是核心** - 它决定了平台的能力边界
2. **物料体系是生态** - 丰富的物料才能支撑复杂应用
3. **渲染引擎是性能关键** - 直接影响用户体验
4. **工程化是规模化基础** - 没有好的工具链,难以支撑大团队

### 10.3 未来展望

- **AI辅助设计** - 通过AI自动生成Schema
- **多端融合** - 一份Schema,多端运行
- **云端协同** - 实时多人协作编辑
- **智能优化** - 自动性能优化和代码生成

---

## 附录

### A. 常见问题

**Q: 低代码平台适合哪些场景?**
A: 中后台管理系统、数据大屏、移动端H5页面、简单官网等配置类页面

**Q: 低代码能完全替代手写代码吗?**
A: 不能。低代码适合标准化场景,复杂业务逻辑仍需手写代码

**Q: 如何保证物料质量?**
A: 通过物料审核机制、单元测试要求、文档规范等方式

**Q: Schema如何做版本兼容?**
A: 通过Schema迁移工具,自动升级旧版本Schema

### B. 参考资源

- [阿里低代码引擎](https://lowcode-engine.com/)
- [百度amis](https://aisuda.bce.baidu.com/amis/)
- [腾讯tmagic-editor](https://tmagic-editor.com/)
- [飞书多维表格](https://www.feishu.cn/product/base)

### C. 技术栈推荐

| 类别 | 推荐方案 |
|------|---------|
| UI框架 | React 18+ |
| 状态管理 | Zustand / Jotai |
| 拖拽 | dnd-kit |
| 构建工具 | Vite |
| Monorepo | pnpm + Turborepo |
| 表达式解析 | @babel/parser |
| 样式方案 | TailwindCSS |

---

**文档版本**: v2.0
**更新时间**: 2025-12-20
**维护者**: 低代码平台团队
