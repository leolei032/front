# 低代码平台架构设计方案 - 从简入深完整指南

## 目录

### 一、[低代码平台核心概念](#一低代码平台核心概念)
- 1.1 什么是低代码平台?
- 1.2 核心组成部分
- 1.3 Schema协议示例

### 二、[阶段一:最简实现 - 单体架构](#二阶段一最简实现---单体架构)
- 2.1 项目结构
- 2.2 最简渲染引擎实现
- 2.3 物料定义(内置方式)
- 2.4 简单设计器实现
- 2.5 阶段一总结

### 三、[阶段二:物料独立 - 插件化架构](#三阶段二物料独立---插件化架构)
- 3.1 架构演进
- 3.2 物料包结构
- 3.3 物料注册表
- 3.4 渲染引擎升级(支持动态物料)
- 3.5 物料开发工具
- 3.6 物料发布流程
- 3.7 物料市场
- 3.8 阶段二总结

### 四、[阶段三:企业级方案 - 微内核架构](#四阶段三企业级方案---微内核架构)
- 4.1 整体架构
- 4.2 Monorepo项目结构
- 4.3 统一构建工具
- 4.4 物料资源发布系统
- 4.5 物料版本管理
- 4.6 Schema版本升级
- 4.7 插件系统
- 4.8 性能优化
- 4.9 阶段三总结

### 五、[运行时能力设计](#五运行时能力设计)
- 5.1 运行时核心模块
- 5.2 Schema扩展协议
- 5.3 事件系统
- 5.4 全局状态管理 (Global Store)
- 5.5 数据源管理
- 5.6 组件与全局Store的交互
- 5.7 动作系统 (Action System)
  - 5.7.1 全局方法 (Global Methods) 的实现原理
- 5.8 表达式引擎
- 5.9 完整运行时实现
- 5.10 渲染器集成：状态注入与事件收集
- 5.11 完整案例:用户管理页面
- 5.12 发布流程与产物管理
  - 5.12.1 产物是什么？
  - 5.12.2 发布流程
  - 5.12.3 数据库表结构设计
  - 5.12.4 两种运行方案
  - 5.12.5 版本管理与回滚
  - 5.12.6 完整的发布架构图
  - 5.12.7 发布优化
  - 5.12.8 性能问题深度分析与解决方案
  - 5.12.9 Schema 编译器深度实现（方案B详解）
- 5.13 运行时能力总结

### 六、[构建工具链设计](#六构建工具链设计)
- 6.1 CLI工具
- 6.2 开发服务器
- 6.3 物料模板

### 七、[物料生态体系](#七物料生态体系)
- 7.1 物料分层
- 7.2 物料标准规范
- 7.3 物料市场

### 八、[性能与安全](#八性能与安全)
- 8.1 渲染性能优化
- 8.2 安全防护

### 九、[实战案例](#九实战案例)
- 9.1 案例一:表单生成器
- 9.2 案例二:数据大屏
- 9.3 案例三:移动端页面

### 十、[总结与展望](#十总结与展望)
- 10.1 三阶段对比
- 10.2 核心要点回顾
- 10.3 未来展望

### [附录](#附录)
- A. 常见问题
- B. 参考资源
- C. 技术栈推荐

---

## 一、低代码平台核心概念

### 1.1 什么是低代码平台?

低代码平台的本质是:**将开发过程可视化,通过拖拽配置生成应用,而非手写代码**。

核心工作流:
```
┌─────────────┐      ┌──────────┐      ┌─────────────┐      ┌──────────┐
│  可视化编辑  │ ---> │  Schema  │ ---> │  渲染引擎   │ ---> │ 运行应用 │
│  (设计器)   │      │  (JSON)  │      │ (Runtime)  │      │          │
└─────────────┘      └──────────┘      └─────────────┘      └──────────┘
```

### 1.2 核心组成部分

```
┌─────────────────────────────────────────────────────────────┐
│                        低代码平台                             │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │   设计器      │  │   物料库      │  │   渲染引擎    │      │
│  │   Designer   │  │   Materials  │  │   Renderer   │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│         │                  │                  │              │
│         └──────────────────┼──────────────────┘              │
│                            ↓                                 │
│                     ┌──────────────┐                         │
│                     │    Schema    │                         │
│                     │    协议      │                         │
│                     └──────────────┘                         │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

**三大核心:**

1. **Schema协议**: 页面的JSON描述语言
2. **物料体系**: 可被拖拽使用的组件
3. **渲染引擎**: 将Schema转换为真实UI

### 1.3 Schema协议示例

```json
{
  "version": "1.0.0",
  "componentTree": {
    "componentName": "Page",
    "props": { "title": "用户列表" },
    "children": [
      {
        "componentName": "Button",
        "props": {
          "type": "primary",
          "children": "新增用户"
        },
        "events": {
          "onClick": {
            "type": "navigate",
            "payload": { "url": "/user/create" }
          }
        }
      }
    ]
  }
}
```

**Schema的关键特性:**
- **声明式**: 描述"是什么",而非"怎么做"
- **可序列化**: 纯JSON,可存储、传输、版本管理
- **可解析**: 渲染引擎可理解并执行

---

## 二、阶段一:最简实现 - 单体架构

> **适用场景**: MVP验证、小型团队、快速迭代
> **特点**: 所有代码在一个项目中,物料内置,架构简单

### 2.1 项目结构

```
lowcode-platform/
├── src/
│   ├── designer/              # 设计器
│   │   ├── Canvas.jsx         # 画布
│   │   ├── MaterialPanel.jsx  # 物料面板
│   │   ├── SettingPanel.jsx   # 属性配置
│   │   └── Toolbar.jsx        # 工具栏
│   │
│   ├── renderer/              # 渲染引擎
│   │   ├── Renderer.jsx       # 核心渲染器
│   │   ├── ExpressionParser.js # 表达式解析
│   │   └── EventHandler.js    # 事件处理
│   │
│   ├── materials/             # 物料(内置)
│   │   ├── Button/
│   │   ├── Input/
│   │   ├── Table/
│   │   └── index.js           # 物料注册
│   │
│   ├── schema/                # Schema相关
│   │   └── protocol.js        # Schema协议定义
│   │
│   └── App.jsx                # 入口
│
└── package.json
```

### 2.2 最简渲染引擎实现

```javascript
// renderer/Renderer.jsx
import React from 'react';
import * as Materials from '../materials';

class SimpleRenderer extends React.Component {
  constructor(props) {
    super(props);
    this.schema = props.schema;
  }

  // 递归渲染组件树
  renderNode(nodeSchema) {
    const { componentName, props, children, id } = nodeSchema;

    // 1. 从物料库获取组件
    const Component = Materials[componentName];
    if (!Component) {
      console.warn(`Component ${componentName} not found`);
      return null;
    }

    // 2. 递归渲染子节点
    const childNodes = children?.map((child, index) =>
      this.renderNode(child)
    );

    // 3. 返回React元素
    return React.createElement(
      Component,
      { key: id, ...props },
      childNodes
    );
  }

  render() {
    return this.renderNode(this.schema.componentTree);
  }
}

export default SimpleRenderer;
```

**使用示例:**
```javascript
// 定义Schema
const schema = {
  componentTree: {
    componentName: 'div',
    props: { className: 'container' },
    children: [
      {
        componentName: 'Button',
        props: { type: 'primary', children: '点击我' }
      }
    ]
  }
};

// 渲染
<SimpleRenderer schema={schema} />
```

### 2.3 物料定义(内置方式)

```javascript
// materials/Button/index.jsx
import React from 'react';
import './style.css';

function Button({ type, children, onClick }) {
  return (
    <button className={`btn btn-${type}`} onClick={onClick}>
      {children}
    </button>
  );
}

// 物料元信息(用于设计器)
Button.meta = {
  title: '按钮',
  category: 'basic',
  props: [
    {
      name: 'type',
      title: '类型',
      type: 'select',
      options: ['primary', 'default', 'danger']
    },
    {
      name: 'children',
      title: '文本',
      type: 'string'
    }
  ]
};

export default Button;
```

```javascript
// materials/index.js - 物料注册
export { default as Button } from './Button';
export { default as Input } from './Input';
export { default as Table } from './Table';
```

### 2.4 简单设计器实现

```javascript
// designer/Designer.jsx
import React, { useState } from 'react';
import MaterialPanel from './MaterialPanel';
import Canvas from './Canvas';
import SettingPanel from './SettingPanel';
import SimpleRenderer from '../renderer/Renderer';
import * as Materials from '../materials';

function Designer() {
  const [schema, setSchema] = useState({
    componentTree: {
      componentName: 'div',
      props: {},
      children: []
    }
  });

  const [selectedNode, setSelectedNode] = useState(null);

  // 添加组件
  const addComponent = (materialName) => {
    const material = Materials[materialName];
    const newNode = {
      id: `node_${Date.now()}`,
      componentName: materialName,
      props: { ...material.meta.defaultProps },
      children: []
    };

    // 简化:直接添加到根节点
    schema.componentTree.children.push(newNode);
    setSchema({ ...schema });
  };

  // 更新属性
  const updateProps = (nodeId, newProps) => {
    // 递归查找并更新节点
    const updateNode = (node) => {
      if (node.id === nodeId) {
        node.props = { ...node.props, ...newProps };
        return true;
      }
      return node.children?.some(updateNode);
    };

    updateNode(schema.componentTree);
    setSchema({ ...schema });
  };

  return (
    <div className="designer-layout">
      {/* 左侧:物料面板 */}
      <MaterialPanel
        materials={Object.keys(Materials)}
        onAdd={addComponent}
      />

      {/* 中间:画布 */}
      <Canvas>
        <SimpleRenderer schema={schema} />
      </Canvas>

      {/* 右侧:属性配置 */}
      <SettingPanel
        node={selectedNode}
        onPropsChange={updateProps}
      />
    </div>
  );
}
```

### 2.5 阶段一总结

**优点:**
- ✅ 结构简单,易于理解和上手
- ✅ 开发效率高,无需复杂的构建配置
- ✅ 适合快速验证想法

**缺点:**
- ❌ 物料内置,无法动态扩展
- ❌ 所有代码耦合在一起,难以维护
- ❌ 无法支持第三方物料
- ❌ 打包体积大(所有物料打包在一起)

**适用场景:**
- MVP阶段
- 团队少于5人
- 物料数量少于20个

---

## 三、阶段二:物料独立 - 插件化架构

> **核心改进**: 物料抽离为独立NPM包,支持按需加载
> **解决问题**: 物料复用、按需加载、第三方扩展

### 3.1 架构演进

```
阶段一(单体):
┌─────────────────────────────────┐
│   lowcode-platform              │
│   ├── designer/                 │
│   ├── renderer/                 │
│   └── materials/ (内置)         │
└─────────────────────────────────┘

                ↓ 演进

阶段二(物料独立):
┌────────────────────┐     ┌──────────────────┐
│ lowcode-platform   │     │  Material Packages│
│ ├── designer/      │     │  @lc/button      │
│ ├── renderer/      │ <-- │  @lc/table       │
│ └── material-      │     │  @lc/form        │
│     registry/      │     │  ...             │
└────────────────────┘     └──────────────────┘
```

### 3.2 物料包结构

```
@lowcode-materials/button/
├── src/
│   ├── Button.jsx           # 组件实现
│   └── index.js             # 导出
│
├── lowcode-meta.json        # 物料元信息
├── package.json
└── README.md

# lowcode-meta.json
{
  "name": "Button",
  "title": "按钮",
  "category": "basic",
  "version": "1.0.0",
  "main": "dist/index.js",
  "props": [
    {
      "name": "type",
      "title": "类型",
      "setter": "SelectSetter",
      "options": ["primary", "default", "danger"]
    }
  ],
  "snippets": {
    "componentName": "Button",
    "props": { "type": "primary", "children": "按钮" }
  }
}
```

### 3.3 物料注册表

```javascript
// material-registry/MaterialRegistry.js
class MaterialRegistry {
  constructor() {
    this.materials = new Map();    // 已加载的物料
    this.metadata = new Map();     // 物料元信息
  }

  // 注册物料
  register(packageName, config) {
    const { component, meta } = config;

    this.materials.set(meta.name, component);
    this.metadata.set(meta.name, {
      packageName,
      ...meta
    });

    console.log(`✅ Material registered: ${meta.name}`);
  }

  // 获取组件
  getComponent(componentName) {
    return this.materials.get(componentName);
  }

  // 获取元信息
  getMeta(componentName) {
    return this.metadata.get(componentName);
  }

  // 获取所有物料列表(用于设计器展示)
  getAllMaterials() {
    return Array.from(this.metadata.values());
  }

  // 动态加载物料包
  async loadMaterialPackage(packageName) {
    try {
      // 方式1: 从CDN加载
      const module = await this.loadFromCDN(packageName);

      // 方式2: 通过import动态导入
      // const module = await import(packageName);

      this.register(packageName, module.default);
      return true;
    } catch (error) {
      console.error(`Failed to load material: ${packageName}`, error);
      return false;
    }
  }

  // 从CDN加载物料
  async loadFromCDN(packageName, version = 'latest') {
    const url = `https://cdn.example.com/materials/${packageName}@${version}/index.js`;

    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = () => {
        // 假设物料包挂载到 window.LowCodeMaterials
        const module = window.LowCodeMaterials[packageName];
        resolve(module);
      };
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
}

export default new MaterialRegistry();
```

### 3.4 渲染引擎升级(支持动态物料)

```javascript
// renderer/Renderer.jsx (升级版)
import React from 'react';
import MaterialRegistry from '../material-registry/MaterialRegistry';

class Renderer extends React.Component {
  constructor(props) {
    super(props);
    this.schema = props.schema;
    this.state = {
      loading: true,
      error: null
    };
  }

  async componentDidMount() {
    // 预加载Schema中用到的所有物料
    await this.preloadMaterials();
  }

  // 预加载物料
  async preloadMaterials() {
    const materialsNeeded = this.collectMaterials(this.schema.componentTree);

    for (const componentName of materialsNeeded) {
      // 检查是否已加载
      if (!MaterialRegistry.getComponent(componentName)) {
        const meta = MaterialRegistry.getMeta(componentName);
        if (meta?.packageName) {
          await MaterialRegistry.loadMaterialPackage(meta.packageName);
        }
      }
    }

    this.setState({ loading: false });
  }

  // 收集Schema中使用的所有组件名
  collectMaterials(node, set = new Set()) {
    if (node.componentName) {
      set.add(node.componentName);
    }
    node.children?.forEach(child => this.collectMaterials(child, set));
    return set;
  }

  // 渲染节点
  renderNode(nodeSchema) {
    const { componentName, props, children, id } = nodeSchema;

    // 从注册表获取组件
    const Component = MaterialRegistry.getComponent(componentName);

    if (!Component) {
      return <div>Component {componentName} not found</div>;
    }

    const childNodes = children?.map(child => this.renderNode(child));

    return React.createElement(
      Component,
      { key: id, ...props },
      childNodes
    );
  }

  render() {
    if (this.state.loading) {
      return <div>Loading materials...</div>;
    }

    return this.renderNode(this.schema.componentTree);
  }
}
```

### 3.5 物料开发工具

为了让开发者方便地开发物料,提供脚手架工具:

```bash
# 创建物料项目
npx @lowcode/create-material my-button

# 项目结构
my-button/
├── src/
│   └── index.jsx
├── demo/                    # 本地预览
│   └── demo.jsx
├── lowcode-meta.json        # 物料元信息
├── package.json
└── README.md
```

```javascript
// 物料开发模板
// src/index.jsx
import React from 'react';

function MyButton({ type, children, onClick }) {
  return (
    <button
      className={`my-btn my-btn-${type}`}
      onClick={onClick}
    >
      {children}
    </button>
  );
}

// 导出配置
export default {
  component: MyButton,
  meta: {
    name: 'MyButton',
    title: '自定义按钮',
    category: 'custom',
    props: [
      {
        name: 'type',
        title: '类型',
        setter: 'SelectSetter',
        options: ['primary', 'secondary']
      }
    ],
    snippets: {
      componentName: 'MyButton',
      props: { type: 'primary', children: '点击' }
    }
  }
};
```

### 3.6 物料发布流程

```bash
# 1. 开发物料
cd my-button
npm run dev        # 本地预览

# 2. 构建
npm run build      # 输出到 dist/

# 3. 发布到NPM
npm publish

# 4. 在低代码平台中安装
npm install @lowcode-materials/my-button

# 5. 注册到平台
import MyButton from '@lowcode-materials/my-button';
MaterialRegistry.register('@lowcode-materials/my-button', MyButton);
```

### 3.7 物料市场

提供一个物料市场,让开发者可以浏览、安装物料:

```javascript
// 物料市场API
class MaterialMarket {
  // 搜索物料
  async search(keyword) {
    const response = await fetch(`/api/materials/search?q=${keyword}`);
    return response.json();
  }

  // 安装物料
  async install(packageName) {
    // 方式1: 后端NPM安装
    await fetch('/api/materials/install', {
      method: 'POST',
      body: JSON.stringify({ packageName })
    });

    // 方式2: 前端动态加载
    await MaterialRegistry.loadMaterialPackage(packageName);
  }

  // 获取物料详情
  async getDetail(packageName) {
    const response = await fetch(`/api/materials/${packageName}`);
    return response.json();
  }
}
```

### 3.8 阶段二总结

**优点:**
- ✅ 物料独立,可复用和发布
- ✅ 支持按需加载,减小打包体积
- ✅ 第三方可以开发和发布物料
- ✅ 物料可以单独版本管理

**缺点:**
- ❌ 物料版本管理复杂
- ❌ 缺少统一的构建规范
- ❌ 物料质量参差不齐
- ❌ 依赖管理困难

**适用场景:**
- 中型团队(5-20人)
- 需要物料复用
- 有第三方物料接入需求

---

## 四、阶段三:企业级方案 - 微内核架构

> **核心升级**: Monorepo管理、统一构建工具、完整的物料生态
> **解决问题**: 大规模团队协作、物料标准化、性能优化

### 4.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        Low-Code Platform                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │  Designer    │  │   Renderer   │  │  Publisher   │          │
│  │  (设计器)     │  │  (渲染引擎)   │  │  (发布系统)   │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
│         │                  │                  │                  │
│         └──────────────────┼──────────────────┘                  │
│                            ↓                                     │
│                   ┌─────────────────┐                            │
│                   │  Core Engine    │                            │
│                   │  (核心引擎)      │                            │
│                   └─────────────────┘                            │
│                            │                                     │
│         ┌──────────────────┼──────────────────┐                 │
│         ↓                  ↓                  ↓                  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │ Plugin      │  │  Material   │  │  Extension  │             │
│  │ System      │  │  System     │  │  API        │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 Monorepo项目结构

```
lowcode-platform/
├── packages/
│   ├── core/                    # 核心引擎
│   │   ├── schema/              # Schema协议
│   │   ├── renderer/            # 渲染引擎
│   │   ├── expression/          # 表达式解析
│   │   └── events/              # 事件系统
│   │
│   ├── designer/                # 设计器
│   │   ├── canvas/              # 画布
│   │   ├── panels/              # 各种面板
│   │   ├── setters/             # 属性配置器
│   │   └── plugins/             # 设计器插件
│   │
│   ├── material-registry/       # 物料注册表
│   │
│   ├── cli/                     # 命令行工具
│   │   ├── create-material/    # 创建物料
│   │   ├── build/               # 构建工具
│   │   └── dev/                 # 开发服务器
│   │
│   ├── materials/               # 官方物料库
│   │   ├── button/
│   │   ├── input/
│   │   ├── table/
│   │   └── ...
│   │
│   └── plugins/                 # 官方插件
│       ├── plugin-datasource/   # 数据源插件
│       ├── plugin-i18n/         # 国际化插件
│       └── ...
│
├── apps/
│   ├── designer-app/            # 设计器应用
│   ├── preview-app/             # 预览应用
│   └── material-market/         # 物料市场
│
├── scripts/                     # 构建脚本
├── lerna.json                   # Lerna配置
├── package.json
└── pnpm-workspace.yaml          # pnpm workspace配置
```

### 4.3 统一构建工具

```javascript
// packages/cli/build/index.js
const { build } = require('vite');
const react = require('@vitejs/plugin-react');

class MaterialBuilder {
  constructor(options) {
    this.options = options;
  }

  // 构建物料包
  async buildMaterial(materialPath) {
    // 读取物料元信息
    const meta = require(`${materialPath}/lowcode-meta.json`);

    // Vite配置
    const config = {
      plugins: [react()],
      build: {
        lib: {
          entry: `${materialPath}/src/index.jsx`,
          name: meta.name,
          formats: ['es', 'umd'],
          fileName: (format) => `index.${format}.js`
        },
        rollupOptions: {
          external: ['react', 'react-dom'],
          output: {
            globals: {
              react: 'React',
              'react-dom': 'ReactDOM'
            }
          }
        },
        outDir: `${materialPath}/dist`
      }
    };

    // 执行构建
    await build(config);

    // 生成物料描述文件
    await this.generateMetadata(materialPath, meta);

    console.log(`✅ Material built: ${meta.name}`);
  }

  // 生成元数据
  async generateMetadata(materialPath, meta) {
    const metadata = {
      ...meta,
      dist: {
        es: 'dist/index.es.js',
        umd: 'dist/index.umd.js'
      },
      buildTime: new Date().toISOString()
    };

    const fs = require('fs');
    fs.writeFileSync(
      `${materialPath}/dist/metadata.json`,
      JSON.stringify(metadata, null, 2)
    );
  }

  // 批量构建
  async buildAll(materialsDir) {
    const fs = require('fs');
    const materials = fs.readdirSync(materialsDir);

    for (const material of materials) {
      const materialPath = `${materialsDir}/${material}`;
      await this.buildMaterial(materialPath);
    }
  }
}

// CLI使用
// npx lowcode-build --material ./packages/materials/button
```

### 4.4 物料资源发布系统

```javascript
// 物料发布平台
class MaterialPublisher {
  constructor(registry) {
    this.registry = registry;  // NPM或私有registry
    this.cdn = 'https://cdn.example.com';
  }

  // 发布物料
  async publish(materialPath) {
    // 1. 构建
    await new MaterialBuilder().buildMaterial(materialPath);

    // 2. 发布到NPM
    await this.publishToNPM(materialPath);

    // 3. 上传到CDN
    await this.uploadToCDN(materialPath);

    // 4. 更新物料索引
    await this.updateIndex(materialPath);
  }

  // 发布到NPM
  async publishToNPM(materialPath) {
    const { exec } = require('child_process');
    const meta = require(`${materialPath}/package.json`);

    return new Promise((resolve, reject) => {
      exec(`cd ${materialPath} && npm publish`, (error, stdout) => {
        if (error) reject(error);
        else resolve(stdout);
      });
    });
  }

  // 上传到CDN
  async uploadToCDN(materialPath) {
    const meta = require(`${materialPath}/lowcode-meta.json`);
    const version = require(`${materialPath}/package.json`).version;

    // 上传构建产物
    const distFiles = ['index.es.js', 'index.umd.js', 'metadata.json'];

    for (const file of distFiles) {
      const localPath = `${materialPath}/dist/${file}`;
      const remotePath = `${this.cdn}/materials/${meta.name}@${version}/${file}`;

      await this.uploadFile(localPath, remotePath);
    }
  }

  // 更新物料索引
  async updateIndex(materialPath) {
    const meta = require(`${materialPath}/dist/metadata.json`);

    // 发送到物料市场后端
    await fetch('/api/materials/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(meta)
    });
  }
}
```

### 4.5 物料版本管理

```javascript
// 物料版本管理器
class MaterialVersionManager {
  constructor() {
    this.registry = new Map(); // 物料名 -> 版本列表
  }

  // 注册物料版本
  register(name, version, url) {
    if (!this.registry.has(name)) {
      this.registry.set(name, []);
    }

    this.registry.get(name).push({
      version,
      url,
      loadedAt: null,
      instance: null
    });
  }

  // 获取特定版本
  async load(name, version = 'latest') {
    const versions = this.registry.get(name);
    if (!versions) {
      throw new Error(`Material ${name} not found`);
    }

    // 解析版本
    const targetVersion = version === 'latest'
      ? this.getLatestVersion(versions)
      : versions.find(v => v.version === version);

    if (!targetVersion) {
      throw new Error(`Version ${version} of ${name} not found`);
    }

    // 已加载则直接返回
    if (targetVersion.instance) {
      return targetVersion.instance;
    }

    // 动态加载
    const module = await this.loadModule(targetVersion.url);
    targetVersion.instance = module;
    targetVersion.loadedAt = Date.now();

    return module;
  }

  // 获取最新版本
  getLatestVersion(versions) {
    return versions.sort((a, b) =>
      this.compareVersion(b.version, a.version)
    )[0];
  }

  // 版本比较
  compareVersion(v1, v2) {
    const parts1 = v1.split('.').map(Number);
    const parts2 = v2.split('.').map(Number);

    for (let i = 0; i < 3; i++) {
      if (parts1[i] > parts2[i]) return 1;
      if (parts1[i] < parts2[i]) return -1;
    }
    return 0;
  }
}
```

### 4.6 Schema版本升级

```javascript
// Schema迁移工具
class SchemaMigration {
  constructor() {
    this.migrations = new Map();
  }

  // 注册迁移规则
  register(fromVersion, toVersion, migrateFn) {
    const key = `${fromVersion}->${toVersion}`;
    this.migrations.set(key, migrateFn);
  }

  // 执行迁移
  migrate(schema, targetVersion) {
    const currentVersion = schema.version;

    if (currentVersion === targetVersion) {
      return schema;
    }

    // 找到迁移路径
    const path = this.findMigrationPath(currentVersion, targetVersion);

    // 依次执行迁移
    let migratedSchema = { ...schema };
    for (let i = 0; i < path.length - 1; i++) {
      const from = path[i];
      const to = path[i + 1];
      const key = `${from}->${to}`;
      const migrateFn = this.migrations.get(key);

      if (migrateFn) {
        migratedSchema = migrateFn(migratedSchema);
        migratedSchema.version = to;
      }
    }

    return migratedSchema;
  }

  // 查找迁移路径
  findMigrationPath(from, to) {
    // 简化实现:假设版本是递增的
    const versions = ['1.0.0', '1.1.0', '2.0.0', '2.1.0'];
    const fromIndex = versions.indexOf(from);
    const toIndex = versions.indexOf(to);

    return versions.slice(fromIndex, toIndex + 1);
  }
}

// 使用示例
const migration = new SchemaMigration();

// 注册v1.0 -> v1.1迁移
migration.register('1.0.0', '1.1.0', (schema) => {
  // 示例:将旧的events格式转换为新格式
  const transform = (node) => {
    if (node.events) {
      node.handlers = node.events; // 重命名
      delete node.events;
    }
    node.children?.forEach(transform);
  };

  transform(schema.componentTree);
  return schema;
});

// 执行迁移
const oldSchema = { version: '1.0.0', /* ... */ };
const newSchema = migration.migrate(oldSchema, '1.1.0');
```

### 4.7 插件系统

```javascript
// 核心插件系统
class PluginSystem {
  constructor() {
    this.plugins = [];
    this.hooks = {
      beforeRender: [],
      afterRender: [],
      onSchemaChange: [],
      onComponentAdd: []
    };
  }

  // 注册插件
  use(plugin) {
    if (typeof plugin.install === 'function') {
      plugin.install(this);
      this.plugins.push(plugin);
    }
  }

  // 注册钩子
  registerHook(hookName, callback) {
    if (this.hooks[hookName]) {
      this.hooks[hookName].push(callback);
    }
  }

  // 触发钩子
  async triggerHook(hookName, ...args) {
    const hooks = this.hooks[hookName] || [];

    for (const hook of hooks) {
      await hook(...args);
    }
  }
}

// 插件示例:数据源插件
class DataSourcePlugin {
  install(platform) {
    // 扩展Schema协议
    platform.registerHook('beforeRender', (schema) => {
      // 初始化数据源
      this.initDataSources(schema.dataSources);
    });

    // 注册动作
    platform.actionRegistry.register('fetchDataSource', (payload) => {
      this.fetchDataSource(payload.id);
    });
  }

  initDataSources(dataSources) {
    // 数据源初始化逻辑
  }

  fetchDataSource(id) {
    // 数据源请求逻辑
  }
}

// 使用插件
const platform = new LowCodePlatform();
platform.use(new DataSourcePlugin());
```

### 4.8 性能优化

```javascript
// 按需加载物料
class LazyMaterialLoader {
  constructor() {
    this.cache = new Map();
    this.loading = new Map();
  }

  // 懒加载物料
  async load(componentName) {
    // 1. 检查缓存
    if (this.cache.has(componentName)) {
      return this.cache.get(componentName);
    }

    // 2. 防止重复加载
    if (this.loading.has(componentName)) {
      return this.loading.get(componentName);
    }

    // 3. 开始加载
    const promise = this.doLoad(componentName);
    this.loading.set(componentName, promise);

    try {
      const component = await promise;
      this.cache.set(componentName, component);
      return component;
    } finally {
      this.loading.delete(componentName);
    }
  }

  async doLoad(componentName) {
    // 从CDN加载
    const url = `/materials/${componentName}/index.js`;
    const module = await import(url);
    return module.default;
  }
}

// 虚拟滚动优化
class VirtualScroll extends React.Component {
  render() {
    const { items, itemHeight, containerHeight } = this.props;
    const [scrollTop, setScrollTop] = useState(0);

    // 计算可视区域
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.ceil((scrollTop + containerHeight) / itemHeight);
    const visibleItems = items.slice(startIndex, endIndex);

    return (
      <div
        style={{ height: containerHeight, overflow: 'auto' }}
        onScroll={(e) => setScrollTop(e.target.scrollTop)}
      >
        <div style={{ height: items.length * itemHeight, position: 'relative' }}>
          {visibleItems.map((item, index) => (
            <div
              key={startIndex + index}
              style={{
                position: 'absolute',
                top: (startIndex + index) * itemHeight,
                height: itemHeight
              }}
            >
              {this.props.renderItem(item)}
            </div>
          ))}
        </div>
      </div>
    );
  }
}
```

### 4.9 阶段三总结

**优点:**
- ✅ 完善的工程化体系
- ✅ 统一的构建和发布流程
- ✅ 支持大规模团队协作
- ✅ 完善的物料生态
- ✅ 高性能、可扩展

**缺点:**
- ❌ 架构复杂,学习成本高
- ❌ 需要专业的运维团队
- ❌ 初期投入大

**适用场景:**
- 大型企业(>50人)
- 多团队协作
- 需要完整的物料生态

---

## 五、运行时能力设计

> **核心能力**: 事件处理、状态管理、数据流、组件通信
> **解决问题**: 复杂页面逻辑、数据交互、业务流程编排

### 5.1 运行时核心模块

```
┌─────────────────────────────────────────────────────────────┐
│                     Low-Code Runtime                          │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  Event       │  │   State      │  │  DataSource  │      │
│  │  System      │  │   Manager    │  │  Manager     │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│         │                  │                  │              │
│         └──────────────────┼──────────────────┘              │
│                            ↓                                 │
│                   ┌─────────────────┐                        │
│                   │  Expression     │                        │
│                   │  Engine         │                        │
│                   └─────────────────┘                        │
│                            │                                 │
│                            ↓                                 │
│                   ┌─────────────────┐                        │
│                   │  Action         │                        │
│                   │  Executor       │                        │
│                   └─────────────────┘                        │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 Schema扩展协议

在基础Schema基础上,扩展运行时能力:

```json
{
  "version": "1.0.0",
  "componentTree": { /* 组件树 */ },

  // 新增:全局状态Store (基于Zustand实现)
  // ⚠️ 注意: 这是全局状态,不是某个组件的useState
  // 所有组件都可以通过表达式 ${store.xxx} 访问
  "store": {
    "userInfo": null,
    "loading": false,
    "tableData": []
  },

  // 新增:数据源定义
  "dataSources": [
    {
      "id": "userApi",
      "type": "http",
      "config": {
        "url": "/api/users",
        "method": "GET"
      }
    }
  ],

  // 新增:生命周期钩子
  "lifeCycles": {
    "onMount": [
      { "type": "setStore", "payload": { "loading": true } },
      { "type": "fetchDataSource", "payload": { "id": "userApi" } }
    ]
  },

  // 新增:全局方法定义
  // 所有组件的事件都可以通过 callMethod 调用这些方法
  "methods": {
    "handleDelete": {
      "params": ["id"],
      "actions": [
        { "type": "confirm", "payload": { "message": "确认删除?" } },
        { "type": "request", "payload": { "url": "/api/users/${id}", "method": "DELETE" } }
      ]
    }
  }
}
```

**架构说明:**

```
┌─────────────────────────────────────────────────────────┐
│  LowCodeRuntime (页面级单例)                              │
│  ┌───────────────────────────────────────────────────┐  │
│  │  GlobalStore (Zustand)                            │  │
│  │  - 所有状态集中管理                                 │  │
│  │  - 任意组件可通过表达式访问                          │  │
│  │  - 类似 Redux Store,不是组件useState                │  │
│  └───────────────────────────────────────────────────┘  │
│                                                          │
│  ┌───────────────────────────────────────────────────┐  │
│  │  GlobalMethods (全局方法表)                        │  │
│  │  - 定义在顶层,所有组件可调用                        │  │
│  │  - 通过 callMethod 动作触发                         │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────┬────────────────────────────────────────┘
                  │
        所有组件通过表达式/事件访问
                  │
     ┌────────────┼────────────┐
     ↓            ↓            ↓
┌─────────┐  ┌─────────┐  ┌─────────┐
│Component│  │Component│  │Component│
│    A    │  │    B    │  │    C    │
└─────────┘  └─────────┘  └─────────┘
```

### 5.3 事件系统

**事件绑定方式:**

```json
{
  "componentName": "Button",
  "events": {
    // 方式1: 简单动作
    "onClick": {
      "type": "setState",
      "payload": { "loading": true }
    },

    // 方式2: 动作序列
    "onClick": [
      { "type": "validateForm", "payload": { "formId": "userForm" } },
      { "type": "request", "payload": { "url": "/api/submit" } },
      { "type": "navigate", "payload": { "url": "/success" } }
    ],

    // 方式3: 调用全局方法
    "onClick": {
      "type": "callMethod",
      "payload": { "method": "handleSubmit" }
    }
  }
}
```

**事件系统实现:**

```javascript
// runtime/EventSystem.js
class EventSystem {
  constructor(runtime) {
    this.runtime = runtime;
  }

  // 创建事件处理器
  createEventHandler(nodeId, eventName, eventConfig) {
    return async (event, ...args) => {
      try {
        // 执行事件处理
        const result = await this.executeEvent(eventConfig, {
          event,
          args,
          nodeId
        });
        return result;
      } catch (error) {
        console.error(`Event execution failed:`, error);
      }
    };
  }

  // 执行事件(支持单个动作或动作序列)
  async executeEvent(eventConfig, context) {
    if (eventConfig.type) {
      return await this.executeAction(eventConfig, context);
    }

    if (Array.isArray(eventConfig)) {
      return await this.executeActionSequence(eventConfig, context);
    }
  }

  // 执行单个动作
  async executeAction(action, context) {
    const executor = this.runtime.actionRegistry.get(action.type);
    const payload = this.resolvePayload(action.payload, context);
    return await executor.execute(payload, context);
  }

  // 执行动作序列
  async executeActionSequence(actions, context) {
    const results = [];
    for (const action of actions) {
      // 支持条件执行
      if (action.condition) {
        const shouldExecute = this.runtime.expression.evaluate(
          action.condition,
          context
        );
        if (!shouldExecute) continue;
      }

      const result = await this.executeAction(action, context);
      results.push(result);

      // 支持错误中断
      if (result.error && action.stopOnError) {
        break;
      }
    }
    return results;
  }
}
```

### 5.4 全局状态管理 (Global Store)

**核心概念**: 使用 Zustand 实现全局状态管理,类似于 Redux,但配置更简单。

> ⚠️ **重要**: 这不是组件级的 `useState`,而是**页面级的全局 Store**!

```javascript
// runtime/GlobalStoreManager.js
import { createStore } from 'zustand';
import { immer } from 'zustand/middleware/immer';

/**
 * 全局状态管理器
 *
 * 架构对比:
 * - 传统React: 组件内 useState() → 组件私有状态
 * - 低代码平台: GlobalStore → 所有组件共享的全局状态
 *
 * 类似于:
 * - Redux Store (但更轻量)
 * - Zustand Store
 * - MobX Store
 */
class GlobalStoreManager {
  constructor(initialStore = {}) {
    // 创建全局 Store
    this.store = createStore(
      immer((set, get) => ({
        ...initialStore,  // 来自 Schema 的 store 字段

        setStore: (updater) => {
          set((store) => {
            if (typeof updater === 'function') {
              updater(store);
            } else {
              Object.assign(store, updater);
            }
          });
        },

        getStore: () => get()
      }))
    );
  }

  // 获取状态(支持路径访问)
  getStore(path) {
    const store = this.store.getState();
    if (!path) return store;

    // 支持 "user.name" 路径访问
    return path.split('.').reduce((obj, key) => obj?.[key], store);
  }

  // 设置状态
  setStore(updates) {
    this.store.getState().setStore(updates);
  }

  // 订阅状态变化 (用于响应式更新)
  subscribe(listener) {
    return this.store.subscribe(listener);
  }
}

/**
 * 使用示例:
 *
 * // Schema 定义
 * {
 *   "store": { "users": [], "loading": false }
 * }
 *
 * // 运行时
 * const storeManager = new GlobalStoreManager({ users: [], loading: false });
 *
 * // 任意组件可访问
 * const users = storeManager.getStore('users');
 * storeManager.setStore({ loading: true });
 */
```

### 5.5 数据源管理

支持HTTP/GraphQL等多种数据源:

```javascript
// runtime/DataSourceManager.js
class DataSourceManager {
  constructor(runtime) {
    this.runtime = runtime;
    this.dataSources = new Map();
  }

  // 注册数据源
  register(dataSourceConfig) {
    const { id, type, config } = dataSourceConfig;
    this.dataSources.set(id, {
      id,
      type,
      config,
      loading: false,
      data: null,
      error: null
    });

    // 自动加载
    if (config.autoLoad) {
      this.load(id);
    }
  }

  // 加载数据
  async load(id, params = {}) {
    const dataSource = this.dataSources.get(id);
    if (!dataSource) throw new Error(`DataSource "${id}" not found`);

    dataSource.loading = true;
    this.updateState(id, { loading: true, error: null });

    try {
      const data = await this.executeLoad(dataSource, params);

      dataSource.data = data;
      dataSource.loading = false;

      this.updateState(id, { data, loading: false });
      return data;
    } catch (error) {
      dataSource.error = error;
      this.updateState(id, { loading: false, error: error.message });
      throw error;
    }
  }

  // 执行加载
  async executeLoad(dataSource, params) {
    const { type, config } = dataSource;

    switch (type) {
      case 'http':
        const { url, method = 'GET', headers = {} } = config;
        const response = await fetch(this.resolveUrl(url, params), {
          method,
          headers: { 'Content-Type': 'application/json', ...headers },
          body: method !== 'GET' ? JSON.stringify(params.data) : undefined
        });
        return await response.json();

      case 'graphql':
        // GraphQL实现
        break;

      case 'static':
        return config.data;
    }
  }

  // 解析URL变量: /api/users/${id}
  resolveUrl(url, params) {
    return url.replace(/\${(\w+)}/g, (match, key) => {
      return params[key] ?? this.runtime.state.getState(key) ?? match;
    });
  }

  // 更新到全局状态
  updateState(id, updates) {
    this.runtime.state.setState({
      [`dataSource_${id}`]: updates
    });
  }
}
```

### 5.6 组件与全局Store的交互

> ⚠️ **概念澄清**: 这里不是传统意义的"父子组件通信"!
>
> 在低代码平台中,所有组件都是通过**全局Store**进行数据交互,而不是通过组件层级的 props 传递。

**架构对比:**

```javascript
// 传统React: 父子组件通信
function ParentPage() {
  const [users, setUsers] = useState([]);  // 父组件的状态

  return <UserList users={users} />;  // 通过props传递
}

// 低代码平台: 组件与全局Store交互
const schema = {
  "store": { "users": [] },  // 全局Store (不属于任何组件)
  "componentTree": {
    "children": [
      {
        "componentName": "UserList",
        "props": {
          "users": "${store.users}"  // 从全局Store读取
        }
      }
    ]
  }
};
```

**1. 组件读取全局状态**

```json
{
  "componentName": "UserList",
  "props": {
    // 通过表达式从全局Store读取数据
    "users": "${store.users}",
    "loading": "${store.loading}",

    // 支持计算属性
    "userCount": "${store.users.length}",

    // 支持复杂表达式
    "activeUsers": "${store.users.filter(u => u.active)}"
  }
}
```

**2. 组件触发全局方法**

```json
{
  "componentName": "UserList",
  "props": {
    "users": "${store.users}",

    // onDelete 不是传统的回调函数
    // 而是一个事件配置,会调用全局methods中的handleDelete
    "onDelete": {
      "type": "callMethod",
      "payload": { "method": "handleDelete" }
    }
  }
}
```

**数据流示意图:**

```
┌─────────────────────────────────────────────────────┐
│  全局 Runtime                                        │
│  ┌─────────────────────────────────────────────┐   │
│  │ GlobalStore: { users: [...], loading: false }│   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │ Methods: { handleDelete: {...} }            │   │
│  └─────────────────────────────────────────────┘   │
└────────────┬────────────────────────────────────────┘
             │
    所有组件通过表达式访问
             │
  ┌──────────┼──────────┐
  ↓          ↓          ↓
┌─────┐  ┌─────┐  ┌─────────┐
│Button│  │Table│  │UserList │
└─────┘  └─────┘  └─────────┘
   │                    │
   │ onClick            │ onDelete
   │                    │
   └────────┬───────────┘
            ↓
     触发全局 handleDelete 方法
            ↓
     更新 GlobalStore.users
            ↓
     所有依赖 store.users 的组件自动重新渲染
```

**2. 兄弟组件通信(EventBus)**

```javascript
// runtime/EventBus.js
class EventBus {
  constructor() {
    this.events = new Map();
  }

  // 订阅事件
  on(eventName, callback) {
    if (!this.events.has(eventName)) {
      this.events.set(eventName, []);
    }
    this.events.get(eventName).push(callback);

    return () => this.off(eventName, callback);
  }

  // 触发事件
  async emit(eventName, data) {
    const listeners = this.events.get(eventName) || [];
    const results = [];

    for (const listener of listeners) {
      const result = await listener(data);
      results.push(result);
    }

    return results;
  }
}
```

**Schema中的通信配置:**

```json
{
  "componentTree": {
    "children": [
      // 组件A: 发送消息
      {
        "componentName": "Button",
        "events": {
          "onClick": {
            "type": "emitEvent",
            "payload": {
              "eventName": "refreshList",
              "data": { "timestamp": "${Date.now()}" }
            }
          }
        }
      },

      // 组件B: 接收消息
      {
        "componentName": "Table",
        "listeners": {
          "refreshList": [
            { "type": "fetchDataSource", "payload": { "id": "tableData" } }
          ]
        }
      }
    ]
  }
}
```

### 5.7 动作系统 (Action System)

> **核心问题**: 低代码平台中，用户不能直接写 JavaScript 代码，如何实现业务逻辑（如删除、请求接口、显示提示）？
>
> **解决方案**: 提供预定义的"动作积木"，用户通过 JSON 配置来组合使用。

**架构设计理念:**

```
传统开发:
  用户点击删除 → 写 JS 函数 → 调用 API → 刷新列表
  ❌ 需要编程能力

低代码平台:
  用户点击删除 → 配置动作序列 → 运行时执行 → 自动完成
  ✅ 无需编程，配置即可
```

**动作系统的三层架构:**

```
┌─────────────────────────────────────────────────┐
│  用户配置层 (JSON Schema)                        │
│  {                                              │
│    "events": {                                  │
│      "onClick": [                               │
│        { "type": "confirm", "payload": {...} }, │
│        { "type": "request", "payload": {...} }, │
│        { "type": "message", "payload": {...} }  │
│      ]                                          │
│    }                                            │
│  }                                              │
└────────────────┬────────────────────────────────┘
                 │ 运行时解析
                 ↓
┌─────────────────────────────────────────────────┐
│  动作注册表 (ActionRegistry)                     │
│  - confirm: 确认对话框                           │
│  - request: HTTP 请求                            │
│  - message: 消息提示                             │
│  - setStore: 更新状态                            │
│  - ...                                          │
└────────────────┬────────────────────────────────┘
                 │ 执行引擎
                 ↓
┌─────────────────────────────────────────────────┐
│  原生 JavaScript 实现                            │
│  async execute(payload) {                       │
│    await fetch(url, { method, body })           │
│    return response.json()                       │
│  }                                              │
└─────────────────────────────────────────────────┘
```

**内置15+常用动作:**

> 每个动作都是一个**预定义的 JavaScript 函数**，用户通过 JSON 配置来调用。

```javascript
// runtime/ActionRegistry.js
class ActionRegistry {
  constructor(runtime) {
    this.runtime = runtime;
    this.actions = new Map();
    this.registerBuiltinActions();
  }

  /**
   * 注册动作
   * @param {string} type - 动作类型（如 'confirm', 'request'）
   * @param {Object} handler - 动作处理器
   * @param {Function} handler.execute - 实际执行的函数
   */
  register(type, handler) {
    this.actions.set(type, handler);
  }

  /**
   * 执行动作
   * @param {string} type - 动作类型
   * @param {Object} payload - 动作参数
   */
  async execute(type, payload) {
    const action = this.actions.get(type);
    if (!action) {
      throw new Error(`Action "${type}" not found`);
    }
    return await action.execute(payload);
  }

  registerBuiltinActions() {
    // 1. 状态管理
    this.register('setStore', {
      execute: async (payload) => {
        this.runtime.store.setStore(payload);
      }
    });

    // 2. HTTP 请求
    this.register('request', {
      execute: async ({ url, method = 'GET', data, headers = {} }) => {
        console.log(`📡 HTTP ${method} ${url}`);
        const response = await fetch(url, {
          method,
          headers: { 'Content-Type': 'application/json', ...headers },
          body: data ? JSON.stringify(data) : undefined
        });
        const result = await response.json();
        console.log(`✅ Response:`, result);
        return result;
      }
    });

    // 3. 数据源加载
    this.register('fetchDataSource', {
      execute: async ({ id, params }) => {
        return await this.runtime.dataSource.load(id, params);
      }
    });

    // 4. 页面导航
    this.register('navigate', {
      execute: async ({ url, replace = false }) => {
        replace ? window.location.replace(url) : window.location.href = url;
      }
    });

    // 5. 消息提示
    this.register('message', {
      execute: async ({ type = 'info', content }) => {
        // 集成 Ant Design Message 或其他 UI 库
        window.antdMessage?.[type](content);
      }
    });

    // 6. 确认对话框
    this.register('confirm', {
      execute: async ({ message, title }) => {
        // 返回 true/false，可以用于条件执行
        return window.confirm(message);
      }
    });

    // 7-8. 弹窗管理
    this.register('openModal', {
      execute: async ({ modalId }) => {
        this.runtime.store.setStore({ [`${modalId}_visible`]: true });
      }
    });

    this.register('closeModal', {
      execute: async ({ modalId }) => {
        this.runtime.store.setStore({ [`${modalId}_visible`]: false });
      }
    });

    // 9-10. 表单操作
    this.register('validateForm', {
      execute: async ({ formId }) => {
        // 触发表单验证
        const form = this.runtime.formRegistry.get(formId);
        return await form.validate();
      }
    });

    this.register('resetForm', {
      execute: async ({ formId }) => {
        const form = this.runtime.formRegistry.get(formId);
        form.resetFields();
      }
    });

    // 11. 触发事件（用于组件间通信）
    this.register('emitEvent', {
      execute: async ({ eventName, data }) => {
        await this.runtime.eventBus.emit(eventName, data);
      }
    });

    // 12. 调用全局方法
    this.register('callMethod', {
      execute: async ({ method, params = [] }) => {
        return await this.runtime.callMethod(method, params);
      }
    });

    // 13. 延迟执行
    this.register('delay', {
      execute: async ({ milliseconds }) => {
        await new Promise(resolve => setTimeout(resolve, milliseconds));
      }
    });

    // 14. 条件执行
    this.register('condition', {
      execute: async ({ condition, thenActions, elseActions }) => {
        const shouldExecute = this.runtime.expression.evaluate(condition);
        const actions = shouldExecute ? thenActions : elseActions;
        if (actions) {
          return await this.runtime.eventSystem.executeActionSequence(actions);
        }
      }
    });

    // 15. 循环执行
    this.register('loop', {
      execute: async ({ items, actions }) => {
        const results = [];
        for (const item of items) {
          const result = await this.runtime.eventSystem.executeActionSequence(
            actions,
            { item }
          );
          results.push(result);
        }
        return results;
      }
    });
  }
}
```

**为什么需要动作系统？**

1. **降低门槛**: 用户不需要会编程，通过配置即可实现业务逻辑
2. **标准化**: 统一的动作接口，所有操作都是 `{ type, payload }` 的形式
3. **可组合**: 多个动作可以组成序列，实现复杂逻辑
4. **可扩展**: 开发者可以注册自定义动作
5. **安全可控**: 动作在沙箱中执行，避免任意代码执行的风险

**使用示例:**

```json
// 用户配置（不需要写代码）
{
  "events": {
    "onClick": [
      // 步骤1: 弹出确认框
      {
        "type": "confirm",
        "payload": { "message": "确认删除?" }
      },
      // 步骤2: 发送 HTTP 请求
      {
        "type": "request",
        "payload": {
          "url": "/api/users/123",
          "method": "DELETE"
        }
      },
      // 步骤3: 显示成功提示
      {
        "type": "message",
        "payload": {
          "type": "success",
          "content": "删除成功"
        }
      },
      // 步骤4: 刷新列表
      {
        "type": "fetchDataSource",
        "payload": { "id": "userList" }
      }
    ]
  }
}
```

```javascript
// 运行时自动执行（用户看不到这部分代码）
async function handleClick() {
  // 执行动作序列
  const confirmed = await actionRegistry.execute('confirm', {
    message: "确认删除?"
  });

  if (confirmed) {
    await actionRegistry.execute('request', {
      url: "/api/users/123",
      method: "DELETE"
    });

    await actionRegistry.execute('message', {
      type: "success",
      content: "删除成功"
    });

    await actionRegistry.execute('fetchDataSource', {
      id: "userList"
    });
  }
}
```

**自定义动作:**

开发者可以注册自定义动作来扩展平台能力：

```javascript
// 注册自定义上传动作
runtime.actionRegistry.register('customUpload', {
  execute: async ({ file, onProgress, onSuccess }) => {
    const formData = new FormData();
    formData.append('file', file);

    const xhr = new XMLHttpRequest();
    xhr.upload.onprogress = (e) => {
      const percent = (e.loaded / e.total) * 100;
      runtime.eventSystem.executeEvent(onProgress, { percent });
    };

    xhr.onload = () => {
      const result = JSON.parse(xhr.responseText);
      runtime.eventSystem.executeEvent(onSuccess, { result });
    };

    xhr.open('POST', '/api/upload');
    xhr.send(formData);
  }
});

// 用户就可以在 Schema 中使用
{
  "events": {
    "onChange": {
      "type": "customUpload",
      "payload": {
        "file": "${event.target.files[0]}"
      }
    }
  }
}
```

---

### 5.7.1 全局方法 (Global Methods) 的实现原理

> **重要澄清**: methods 不是字符串形式的函数体，而是 **JSON 配置的动作序列**！

**常见误解:**

```javascript
❌ 错误理解: methods 是字符串形式的代码
{
  "methods": {
    "handleDelete": "async function(userId) { await fetch(...) }"  // ❌ 错误！
  }
}

✅ 正确理解: methods 是动作序列的配置
{
  "methods": {
    "handleDelete": {
      "params": ["userId"],
      "actions": [                    // ← JSON 配置，不是代码字符串
        { "type": "confirm", ... },
        { "type": "request", ... }
      ]
    }
  }
}
```

**实现原理:**

```
┌─────────────────────────────────────────────────┐
│  用户配置全局方法 (Schema)                        │
├─────────────────────────────────────────────────┤
│  {                                              │
│    "methods": {                                 │
│      "handleDelete": {                          │
│        "params": ["userId"],                    │
│        "actions": [                             │
│          { "type": "confirm", ... },            │
│          { "type": "request", ... },            │
│          { "type": "message", ... }             │
│        ]                                        │
│      }                                          │
│    }                                            │
│  }                                              │
└────────────────┬────────────────────────────────┘
                 │ 运行时注册
                 ↓
┌─────────────────────────────────────────────────┐
│  Runtime 初始化时，将 methods 注册到 Map          │
├─────────────────────────────────────────────────┤
│  this.methods = new Map()                       │
│  this.methods.set('handleDelete', {             │
│    params: ['userId'],                          │
│    actions: [...]                               │
│  })                                             │
└────────────────┬────────────────────────────────┘
                 │ 组件事件触发
                 ↓
┌─────────────────────────────────────────────────┐
│  用户点击删除按钮                                 │
├─────────────────────────────────────────────────┤
│  <Button                                        │
│    onClick={{                                   │
│      type: "callMethod",                        │
│      payload: {                                 │
│        method: "handleDelete",                  │
│        params: [123]  ← 传入 userId             │
│      }                                          │
│    }}                                           │
│  />                                             │
└────────────────┬────────────────────────────────┘
                 │ 执行动作
                 ↓
┌─────────────────────────────────────────────────┐
│  运行时执行                                       │
├─────────────────────────────────────────────────┤
│  // callMethod 动作被触发                        │
│  async callMethod(methodName, params) {         │
│    // 1. 从 Map 中获取方法配置                   │
│    const methodConfig = this.methods.get(       │
│      'handleDelete'                             │
│    );                                           │
│                                                 │
│    // 2. 依次执行 actions 序列                   │
│    for (const action of methodConfig.actions) { │
│      await actionRegistry.execute(              │
│        action.type,                             │
│        action.payload                           │
│      );                                         │
│    }                                            │
│  }                                              │
└─────────────────────────────────────────────────┘
```

**完整示例:**

```json
{
  "store": {
    "users": []
  },

  "methods": {
    // ❌ 不是这样: "handleDelete": "function() { ... }"

    // ✅ 而是这样: JSON 配置的动作序列
    "handleDelete": {
      "params": ["userId"],  // 方法参数
      "actions": [           // 动作序列（按顺序执行）
        // 动作1: 弹确认框
        {
          "type": "confirm",
          "payload": { "message": "确认删除用户?" }
        },
        // 动作2: 发送删除请求
        {
          "type": "request",
          "payload": {
            "url": "/api/users/${params[0]}",  // 使用参数
            "method": "DELETE"
          }
        },
        // 动作3: 显示提示
        {
          "type": "message",
          "payload": {
            "type": "success",
            "content": "删除成功"
          }
        },
        // 动作4: 更新列表
        {
          "type": "setStore",
          "payload": {
            "users": "${store.users.filter(u => u.id !== params[0])}"
          }
        }
      ]
    }
  },

  "componentTree": {
    "children": [
      {
        "componentName": "Button",
        "props": { "children": "删除" },
        "events": {
          "onClick": {
            "type": "callMethod",      // 触发 callMethod 动作
            "payload": {
              "method": "handleDelete",  // 方法名
              "params": [123]            // 传入参数
            }
          }
        }
      }
    ]
  }
}
```

**运行时实现:**

```javascript
class LowCodeRuntime {
  constructor(schema) {
    // 注册全局方法
    this.methods = new Map();
    if (schema.methods) {
      Object.entries(schema.methods).forEach(([name, config]) => {
        this.methods.set(name, config);
      });
    }
  }

  /**
   * 调用全局方法
   * @param {string} methodName - 方法名
   * @param {Array} params - 参数数组
   */
  async callMethod(methodName, params = []) {
    const methodConfig = this.methods.get(methodName);
    if (!methodConfig) {
      throw new Error(`Method "${methodName}" not found`);
    }

    console.log(`🎯 调用方法: ${methodName}`, params);

    // 构建上下文（包含参数）
    const context = {
      params,
      store: this.store.getStore(),
      dataSource: this.dataSource.getContext()
    };

    // 依次执行 actions 序列
    const results = [];
    for (const action of methodConfig.actions) {
      // 解析 payload 中的表达式（如 ${params[0]}）
      const resolvedPayload = this.expression.evaluateObject(
        action.payload,
        context
      );

      // 执行动作
      const result = await this.actionRegistry.execute(
        action.type,
        resolvedPayload
      );

      results.push(result);

      // 如果是 confirm 返回 false，中断执行
      if (action.type === 'confirm' && !result) {
        console.log('❌ 用户取消操作');
        break;
      }
    }

    return results;
  }
}
```

**关键点总结:**

| 维度 | 传统开发 | 低代码平台 |
|------|---------|-----------|
| **方法定义** | JavaScript 函数 | JSON 配置的动作序列 |
| **执行方式** | 直接调用函数 | 运行时解析并执行动作 |
| **代码形式** | `function() { ... }` | `{ params: [], actions: [...] }` |
| **灵活性** | 高（可以写任何代码） | 中（受限于预定义动作） |
| **安全性** | 低（任意代码执行） | 高（只能使用注册的动作） |
| **学习成本** | 需要会编程 | 配置即可，无需编程 |

**为什么不用字符串形式的代码？**

1. ❌ **安全风险**: `eval()` 或 `new Function()` 可以执行任意代码，存在 XSS 风险
2. ❌ **难以解析**: 字符串代码难以静态分析和验证
3. ❌ **不可移植**: JavaScript 代码无法跨平台（如小程序）
4. ✅ **JSON 配置**: 安全、可序列化、可验证、易于理解
5. ✅ **动作系统**: 提供足够的灵活性，同时保证安全

### 5.8 表达式引擎

**支持的表达式类型:**

```javascript
// 1. 全局Store访问
"${store.userName}"
"${store.user.profile.email}"

// 2. 数据源访问
"${dataSource.userList.data}"
"${dataSource.userList.loading}"

// 3. 计算表达式
"${store.price * store.quantity}"
"${store.users.length > 0}"

// 4. 函数调用
"${store.users.filter(u => u.age > 18)}"
"${store.name.toUpperCase()}"

// 5. 三元表达式
"${store.isVip ? 'VIP用户' : '普通用户'}"

// 6. 模板字符串
"`用户: ${store.userName}, 年龄: ${store.age}`"

// 7. 混合使用
"${store.users.find(u => u.id === dataSource.currentUserId.data)}"
```

**表达式引擎实现:**

```javascript
// runtime/ExpressionEngine.js
class ExpressionEngine {
  constructor(runtime) {
    this.runtime = runtime;
    this.cache = new Map(); // 表达式缓存
  }

  /**
   * 评估表达式
   *
   * 表达式上下文说明:
   * - store: 全局 Store (来自 schema.store)
   * - dataSource: 数据源状态 (来自 runtime.dataSource)
   * - 不提供 state,避免与 store 混淆
   */
  evaluate(expression, extraContext = {}) {
    if (typeof expression !== 'string' || !expression.includes('${')) {
      return expression;
    }

    // 检查缓存
    let compiledFn = this.cache.get(expression);
    if (!compiledFn) {
      compiledFn = this.compile(expression);
      this.cache.set(expression, compiledFn);
    }

    // 构建表达式上下文
    const context = {
      store: this.runtime.store.getStore(),        // 全局 Store
      dataSource: this.getDataSourceContext(),     // 数据源
      ...extraContext                              // 额外的上下文(如事件参数)
    };

    try {
      return compiledFn(context);
    } catch (error) {
      console.error('Expression evaluation error:', error);
      console.error('Expression:', expression);
      console.error('Context:', context);
      return undefined;
    }
  }

  // 编译表达式为函数
  compile(expression) {
    const code = expression.slice(2, -1); // 去除 ${ }

    // 使用 with 语句创建上下文作用域
    // 允许直接访问 store.xxx 而不是 context.store.xxx
    return new Function('context', `
      with(context) {
        return ${code};
      }
    `);
  }

  // 获取数据源上下文
  getDataSourceContext() {
    const context = {};
    this.runtime.dataSource.dataSources.forEach((ds, id) => {
      context[id] = {
        data: ds.data,
        loading: ds.loading,
        error: ds.error
      };
    });
    return context;
  }

  /**
   * 批量解析对象中的所有表达式
   * 用于解析组件的 props
   */
  evaluateObject(obj, extraContext = {}) {
    if (!obj || typeof obj !== 'object') {
      return obj;
    }

    const result = Array.isArray(obj) ? [] : {};

    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'string') {
        result[key] = this.evaluate(value, extraContext);
      } else if (typeof value === 'object' && value !== null) {
        result[key] = this.evaluateObject(value, extraContext);
      } else {
        result[key] = value;
      }
    }

    return result;
  }
}

/**
 * 使用示例:
 *
 * const engine = new ExpressionEngine(runtime);
 *
 * // 简单访问
 * engine.evaluate("${store.userName}");  // → "John"
 *
 * // 计算
 * engine.evaluate("${store.users.length}");  // → 5
 *
 * // 复杂表达式
 * engine.evaluate("${store.users.filter(u => u.active).map(u => u.name)}");
 * // → ["Alice", "Bob"]
 *
 * // 批量解析
 * engine.evaluateObject({
 *   users: "${store.users}",
 *   count: "${store.users.length}",
 *   title: "用户列表"
 * });
 * // → { users: [...], count: 5, title: "用户列表" }
 */
```

### 5.9 完整运行时实现

```javascript
// runtime/LowCodeRuntime.js
/**
 * 低代码运行时 - 整个页面的核心引擎
 *
 * 架构说明:
 * - 每个页面有一个 Runtime 实例 (页面级单例)
 * - Runtime 包含全局 Store、全局 Methods、事件系统等
 * - 所有组件通过 Runtime 访问数据和触发动作
 */
class LowCodeRuntime {
  constructor(schema) {
    this.schema = schema;

    console.log('🚀 初始化 LowCodeRuntime');

    // 初始化全局状态管理器
    this.store = new GlobalStoreManager(schema.store || {});
    console.log('✅ GlobalStore 初始化完成:', schema.store);

    // 初始化事件总线 (用于兄弟组件通信)
    this.eventBus = new EventBus();

    // 初始化表达式引擎 (解析 ${store.xxx})
    this.expression = new ExpressionEngine(this);

    // 初始化动作注册表 (内置动作 + 自定义动作)
    this.actionRegistry = new ActionRegistry(this);

    // 初始化事件系统 (处理组件事件)
    this.eventSystem = new EventSystem(this);

    // 初始化数据源管理器
    this.dataSource = new DataSourceManager(this);

    // 注册全局方法
    this.methods = new Map();
    if (schema.methods) {
      Object.entries(schema.methods).forEach(([name, config]) => {
        this.methods.set(name, config);
        console.log(`✅ 注册全局方法: ${name}`);
      });
    }

    // 异步初始化
    this.init();
  }

  /**
   * 初始化运行时
   */
  async init() {
    try {
      // 注册数据源
      if (this.schema.dataSources) {
        this.schema.dataSources.forEach(ds => {
          this.dataSource.register(ds);
          console.log(`✅ 注册数据源: ${ds.id}`);
        });
      }

      // 执行 onMount 生命周期
      if (this.schema.lifeCycles?.onMount) {
        console.log('🔄 执行 onMount 生命周期');
        await this.eventSystem.executeActionSequence(
          this.schema.lifeCycles.onMount,
          {}
        );
      }

      console.log('✅ Runtime 初始化完成');
    } catch (error) {
      console.error('❌ Runtime 初始化失败:', error);
    }
  }

  /**
   * 调用全局方法
   */
  async callMethod(methodName, params = []) {
    const methodConfig = this.methods.get(methodName);
    if (!methodConfig) {
      throw new Error(`Method "${methodName}" not found`);
    }

    console.log(`🎯 调用全局方法: ${methodName}`, params);

    // 执行方法的 actions 序列
    return await this.eventSystem.executeActionSequence(
      methodConfig.actions,
      { params }
    );
  }

  /**
   * 销毁运行时
   */
  destroy() {
    try {
      // 执行 onUnmount 生命周期
      if (this.schema.lifeCycles?.onUnmount) {
        console.log('🔄 执行 onUnmount 生命周期');
        this.eventSystem.executeActionSequence(
          this.schema.lifeCycles.onUnmount,
          {}
        );
      }

      // 清理事件总线
      this.eventBus.clear();

      console.log('✅ Runtime 销毁完成');
    } catch (error) {
      console.error('❌ Runtime 销毁失败:', error);
    }
  }
}

/**
 * 使用示例:
 *
 * const schema = {
 *   store: { users: [], loading: false },
 *   methods: { handleDelete: { actions: [...] } },
 *   dataSources: [{ id: 'userApi', ... }],
 *   componentTree: { ... }
 * };
 *
 * const runtime = new LowCodeRuntime(schema);
 *
 * // 访问全局 Store
 * const users = runtime.store.getStore('users');
 * runtime.store.setStore({ loading: true });
 *
 * // 调用全局方法
 * await runtime.callMethod('handleDelete', [userId]);
 *
 * // 解析表达式
 * const value = runtime.expression.evaluate('${store.users.length}');
 */
```

### 5.10 渲染器集成：状态注入与事件收集

> **关键步骤**:
> 1. 创建全局 Runtime (包含 GlobalStore)
> 2. 遍历组件树,解析表达式注入状态
> 3. 收集事件配置,转换为真实的事件处理函数
> 4. 订阅 Store 变化,实现响应式更新

```javascript
// renderer/Renderer.jsx
import React, { useState, useEffect, useSyncExternalStore } from 'react';
import MaterialRegistry from '../material-registry/MaterialRegistry';
import LowCodeRuntime from '../runtime/LowCodeRuntime';

/**
 * 低代码渲染器
 *
 * 职责:
 * 1. 初始化全局 Runtime (包含 GlobalStore、Methods 等)
 * 2. 递归渲染组件树
 * 3. 解析表达式 (如 ${store.users}) 并注入到 props
 * 4. 收集 events 配置并转换为事件处理函数
 * 5. 订阅 Store 变化,触发重新渲染
 */
function Renderer({ schema }) {
  // 创建全局 Runtime 实例 (整个页面只有一个)
  const [runtime] = useState(() => {
    console.log('🚀 初始化 Runtime with schema.store:', schema.store);
    return new LowCodeRuntime(schema);
  });

  // 订阅全局 Store 的变化
  // 当 Store 更新时,会触发所有使用该状态的组件重新渲染
  const store = useSyncExternalStore(
    runtime.store.subscribe.bind(runtime.store),
    () => runtime.store.getStore()
  );

  useEffect(() => {
    console.log('✅ Runtime mounted, store:', store);
    return () => {
      console.log('❌ Runtime unmounting');
      runtime.destroy();
    };
  }, []);

  /**
   * 递归渲染节点
   *
   * @param {Object} nodeSchema - 节点配置
   * @returns {ReactElement}
   */
  const renderNode = (nodeSchema) => {
    const { id, componentName, props = {}, children, events } = nodeSchema;

    // 1️⃣ 从物料注册表获取组件
    const Component = MaterialRegistry.getComponent(componentName);
    if (!Component) {
      console.warn(`❌ Component ${componentName} not found`);
      return null;
    }

    // 2️⃣ 解析 props 中的表达式,注入全局状态
    // 例如: { users: "${store.users}" }
    //   →  { users: [实际的用户数组] }
    const resolvedProps = resolvePropsWithExpressions(props, runtime);

    // 3️⃣ 收集并转换 events 配置为真实的事件处理函数
    // 例如: { onClick: { type: "callMethod", payload: {...} } }
    //   →  { onClick: async () => { runtime.callMethod(...) } }
    const eventHandlers = collectEventHandlers(id, events, runtime);

    // 4️⃣ 递归渲染子节点
    const childNodes = children?.map((child, index) =>
      renderNode({ ...child, id: child.id || `${id}_child_${index}` })
    );

    // 5️⃣ 使用 React.createElement 创建真实的 React 元素
    return React.createElement(
      Component,
      {
        key: id,
        ...resolvedProps,     // 注入状态
        ...eventHandlers      // 注入事件处理器
      },
      childNodes
    );
  };

  return (
    <div className="lowcode-renderer">
      {renderNode(schema.componentTree)}
    </div>
  );
}

/**
 * 解析 props 中的表达式
 *
 * @param {Object} props - 原始 props 配置
 * @param {LowCodeRuntime} runtime - 运行时实例
 * @returns {Object} 解析后的 props
 */
function resolvePropsWithExpressions(props, runtime) {
  const resolved = {};

  for (const [key, value] of Object.entries(props)) {
    if (typeof value === 'string' && value.includes('${')) {
      // 表达式: "${store.users}" → [实际数据]
      resolved[key] = runtime.expression.evaluate(value);

      console.log(`📊 表达式解析: ${key}:`, {
        原始值: value,
        解析结果: resolved[key]
      });
    } else if (typeof value === 'object' && value !== null) {
      // 递归解析嵌套对象
      resolved[key] = resolvePropsWithExpressions(value, runtime);
    } else {
      // 普通值直接传递
      resolved[key] = value;
    }
  }

  return resolved;
}

/**
 * 收集事件配置并转换为事件处理函数
 *
 * @param {string} nodeId - 节点ID
 * @param {Object} events - 事件配置
 * @param {LowCodeRuntime} runtime - 运行时实例
 * @returns {Object} 事件处理器映射
 */
function collectEventHandlers(nodeId, events, runtime) {
  if (!events) return {};

  const handlers = {};

  for (const [eventName, eventConfig] of Object.entries(events)) {
    // 创建事件处理函数
    // 当组件调用 props.onClick(...args) 时,会执行这个函数
    handlers[eventName] = runtime.eventSystem.createEventHandler(
      nodeId,
      eventName,
      eventConfig
    );

    console.log(`🎯 事件注册: ${eventName}`, {
      组件ID: nodeId,
      事件配置: eventConfig
    });
  }

  return handlers;
}

export default Renderer;
```

**完整的渲染流程示意图:**

```
Schema 定义
├── store: { users: [] }
├── methods: { handleDelete: {...} }
└── componentTree: { ... }
        ↓
┌────────────────────────────────────────────────────┐
│  1. 初始化 Runtime                                  │
│     - 创建 GlobalStore (Zustand)                   │
│     - 注册全局 Methods                              │
│     - 初始化 EventSystem、ExpressionEngine         │
└──────────────┬─────────────────────────────────────┘
               ↓
┌────────────────────────────────────────────────────┐
│  2. 递归渲染组件树                                  │
│     - 获取组件: MaterialRegistry.get('UserList')   │
│     - 解析表达式: "${store.users}" → [数组]        │
│     - 收集事件: { onDelete: {...} } → 函数          │
└──────────────┬─────────────────────────────────────┘
               ↓
┌────────────────────────────────────────────────────┐
│  3. 创建 React 元素                                 │
│     React.createElement(                           │
│       UserList,                                    │
│       {                                            │
│         users: [实际数组],  ← 来自 GlobalStore      │
│         onDelete: async (id) => {  ← 事件处理器    │
│           await runtime.callMethod('handleDelete') │
│         }                                          │
│       }                                            │
│     )                                              │
└──────────────┬─────────────────────────────────────┘
               ↓
         渲染真实的 React 组件
               ↓
         用户交互 (点击删除)
               ↓
         触发 onDelete(userId)
               ↓
         执行全局 Method
               ↓
         更新 GlobalStore
               ↓
         所有依赖该状态的组件自动重新渲染
```

### 5.11 完整案例:用户管理页面

> 这个案例展示了如何使用全局 Store、全局 Methods、数据源和事件系统构建一个完整的 CRUD 页面。

```json
{
  "version": "1.0.0",

  // 全局状态 Store
  "store": {
    "users": [],
    "modalVisible": false,
    "selectedUser": null,
    "filters": {
      "keyword": "",
      "status": "all"
    }
  },

  // 数据源定义
  "dataSources": [
    {
      "id": "userList",
      "type": "http",
      "config": {
        "url": "/api/users",
        "method": "GET",
        "autoLoad": true
      }
    }
  ],

  // 页面生命周期
  "lifeCycles": {
    "onMount": [
      { "type": "setStore", "payload": { "loading": true } },
      { "type": "fetchDataSource", "payload": { "id": "userList" } }
    ]
  },

  // 全局方法
  "methods": {
    "handleDelete": {
      "params": ["userId"],
      "actions": [
        { "type": "confirm", "payload": { "message": "确认删除?" } },
        {
          "type": "request",
          "payload": {
            "url": "/api/users/${params[0]}",
            "method": "DELETE"
          }
        },
        { "type": "message", "payload": { "type": "success", "content": "删除成功" } },
        { "type": "fetchDataSource", "payload": { "id": "userList" } }
      ]
    },

    "handleEdit": {
      "params": ["user"],
      "actions": [
        {
          "type": "setStore",
          "payload": {
            "selectedUser": "${params[0]}",
            "modalVisible": true
          }
        }
      ]
    },

    "handleModalClose": {
      "actions": [
        {
          "type": "setStore",
          "payload": {
            "modalVisible": false,
            "selectedUser": null
          }
        }
      ]
    },

    "handleFilterChange": {
      "params": ["filters"],
      "actions": [
        { "type": "setStore", "payload": { "filters": "${params[0]}" } },
        { "type": "fetchDataSource", "payload": { "id": "userList" } }
      ]
    }
  },

  // 组件树
  "componentTree": {
    "componentName": "Page",
    "props": { "title": "用户管理" },
    "children": [
      // 操作栏
      {
        "componentName": "Space",
        "props": { "style": { "marginBottom": 16 } },
        "children": [
          {
            "componentName": "Button",
            "props": {
              "type": "primary",
              "children": "新增用户"
            },
            "events": {
              "onClick": {
                "type": "setStore",
                "payload": { "selectedUser": null, "modalVisible": true }
              }
            }
          },
          {
            "componentName": "Input",
            "props": {
              "placeholder": "搜索用户",
              "value": "${store.filters.keyword}"
            },
            "events": {
              "onChange": {
                "type": "callMethod",
                "payload": {
                  "method": "handleFilterChange",
                  "params": ["${Object.assign({}, store.filters, { keyword: event.target.value })}"]
                }
              }
            }
          }
        ]
      },

      // 用户表格
      {
        "componentName": "Table",
        "props": {
          "dataSource": "${dataSource.userList.data}",
          "loading": "${dataSource.userList.loading}",
          "rowKey": "id",
          "columns": [
            { "title": "用户名", "dataIndex": "username" },
            { "title": "邮箱", "dataIndex": "email" },
            { "title": "状态", "dataIndex": "status" },
            {
              "title": "操作",
              "render": {
                "componentName": "Space",
                "children": [
                  {
                    "componentName": "Button",
                    "props": {
                      "type": "link",
                      "children": "编辑"
                    },
                    "events": {
                      "onClick": {
                        "type": "callMethod",
                        "payload": {
                          "method": "handleEdit",
                          "params": ["${record}"]
                        }
                      }
                    }
                  },
                  {
                    "componentName": "Button",
                    "props": {
                      "type": "link",
                      "danger": true,
                      "children": "删除"
                    },
                    "events": {
                      "onClick": {
                        "type": "callMethod",
                        "payload": {
                          "method": "handleDelete",
                          "params": ["${record.id}"]
                        }
                      }
                    }
                  }
                ]
              }
            }
          ]
        }
      },

      // 编辑模态框
      {
        "componentName": "Modal",
        "props": {
          "visible": "${store.modalVisible}",
          "title": "${store.selectedUser ? '编辑用户' : '新增用户'}"
        },
        "events": {
          "onCancel": {
            "type": "callMethod",
            "payload": { "method": "handleModalClose" }
          }
        },
        "children": [
          {
            "componentName": "Form",
            "props": {
              "initialValues": "${store.selectedUser}"
            }
          }
        ]
      }
    ]
  }
}
```

**数据流分析:**

```
1. 页面加载
   ↓
   lifeCycles.onMount 触发
   ↓
   setStore({ loading: true })
   ↓
   fetchDataSource('userList')
   ↓
   请求 /api/users
   ↓
   dataSource.userList.data 更新
   ↓
   Table 组件的 dataSource="${dataSource.userList.data}" 自动更新

2. 用户点击"删除"按钮
   ↓
   触发 onClick 事件
   ↓
   callMethod('handleDelete', [userId])
   ↓
   执行 actions 序列:
     - confirm() → 用户确认
     - request(DELETE /api/users/123)
     - message('删除成功')
     - fetchDataSource('userList') → 刷新列表
   ↓
   GlobalStore 更新
   ↓
   所有依赖的组件自动重新渲染

3. 用户点击"编辑"按钮
   ↓
   callMethod('handleEdit', [userObject])
   ↓
   setStore({
     selectedUser: userObject,
     modalVisible: true
   })
   ↓
   Modal 的 visible="${store.modalVisible}" → 显示弹窗
   Form 的 initialValues="${store.selectedUser}" → 填充数据
```

### 5.12 发布流程与产物管理

> **核心问题**: 用户在低代码平台配置完页面后，如何发布？产物是什么？如何运行？

#### 5.12.1 产物是什么？

**答案：产物就是 Schema JSON 文件！**

```json
// 产物：一个 JSON 文件（如 user-manage-page.json）
{
  "id": "page_user_manage",
  "version": "1.0.0",
  "name": "用户管理页面",
  "store": { "users": [], "loading": false },
  "methods": { "handleDelete": {...} },
  "dataSources": [...],
  "componentTree": {...}
}
```

**为什么是 JSON？**

| 特性 | JSON Schema | 编译后的代码 |
|------|------------|-------------|
| **可读性** | ✅ 易读易理解 | ❌ 压缩后难读 |
| **可存储** | ✅ 直接存数据库 | ❌ 需要文件系统 |
| **可版本化** | ✅ Git 友好 | ⚠️ 可以但不直观 |
| **可回滚** | ✅ 切换 JSON | ⚠️ 需要重新部署 |
| **跨平台** | ✅ Web/小程序/App | ❌ 需要针对性编译 |
| **热更新** | ✅ 直接替换 JSON | ❌ 需要重新打包 |

---

#### 5.12.2 发布流程

```
┌─────────────────────────────────────────────────────────┐
│  1. 设计阶段 (Designer)                                  │
│  用户在设计器中拖拽配置                                   │
├─────────────────────────────────────────────────────────┤
│  → 实时保存草稿到数据库                                   │
│  → 用户可以预览效果                                       │
└────────────────┬────────────────────────────────────────┘
                 │ 点击"保存"
                 ↓
┌─────────────────────────────────────────────────────────┐
│  2. 保存阶段                                             │
│  将 Schema JSON 保存到数据库                             │
├─────────────────────────────────────────────────────────┤
│  POST /api/pages/:id/save                               │
│  {                                                       │
│    "pageId": "page_user_manage",                        │
│    "version": "draft",                                  │
│    "schema": { /* 完整的 Schema */ },                   │
│    "updatedBy": "user123",                              │
│    "updatedAt": "2025-01-15T10:00:00Z"                  │
│  }                                                       │
└────────────────┬────────────────────────────────────────┘
                 │ 点击"预览"
                 ↓
┌─────────────────────────────────────────────────────────┐
│  3. 预览阶段                                             │
│  在沙箱环境中渲染 Schema                                  │
├─────────────────────────────────────────────────────────┤
│  GET /preview/:pageId?version=draft                     │
│  → 获取 Schema                                           │
│  → Renderer 渲染                                         │
│  → 用户测试交互                                           │
└────────────────┬────────────────────────────────────────┘
                 │ 确认无误，点击"发布"
                 ↓
┌─────────────────────────────────────────────────────────┐
│  4. 发布阶段                                             │
│  将 Schema 标记为正式版本                                 │
├─────────────────────────────────────────────────────────┤
│  POST /api/pages/:id/publish                            │
│  {                                                       │
│    "pageId": "page_user_manage",                        │
│    "version": "1.0.0",  ← 生成版本号                     │
│    "status": "published",                               │
│    "publishedBy": "user123",                            │
│    "publishedAt": "2025-01-15T11:00:00Z"                │
│  }                                                       │
│                                                          │
│  → 数据库操作：                                           │
│    - 创建新版本记录                                       │
│    - 更新页面状态为"已发布"                                │
│    - 记录发布历史                                         │
└────────────────┬────────────────────────────────────────┘
                 │
                 ↓
┌─────────────────────────────────────────────────────────┐
│  5. 运行阶段                                             │
│  用户访问发布后的页面                                     │
├─────────────────────────────────────────────────────────┤
│  GET /app/user-manage                                   │
│  → 路由系统解析路径                                       │
│  → 查询数据库获取最新发布版本的 Schema                     │
│  → Renderer 渲染 Schema                                  │
│  → 用户看到页面                                           │
└─────────────────────────────────────────────────────────┘
```

---

#### 5.12.3 数据库表结构设计

```sql
-- 页面表（主表）
CREATE TABLE lowcode_pages (
  id VARCHAR(50) PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  route VARCHAR(200) NOT NULL,  -- 页面路由
  current_version VARCHAR(20),   -- 当前发布版本
  status ENUM('draft', 'published', 'archived'),
  created_by VARCHAR(50),
  created_at TIMESTAMP,
  updated_at TIMESTAMP,
  INDEX idx_route (route)
);

-- 页面版本表（存储每个版本的 Schema）
CREATE TABLE lowcode_page_versions (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  page_id VARCHAR(50) NOT NULL,
  version VARCHAR(20) NOT NULL,      -- 版本号：draft, 1.0.0, 1.0.1
  schema JSON NOT NULL,              -- ← Schema 存储在这里
  status ENUM('draft', 'published', 'archived'),
  published_by VARCHAR(50),
  published_at TIMESTAMP,
  created_at TIMESTAMP,
  FOREIGN KEY (page_id) REFERENCES lowcode_pages(id),
  INDEX idx_page_version (page_id, version)
);

-- 发布历史表
CREATE TABLE lowcode_publish_history (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  page_id VARCHAR(50) NOT NULL,
  from_version VARCHAR(20),
  to_version VARCHAR(20),
  published_by VARCHAR(50),
  published_at TIMESTAMP,
  rollback_at TIMESTAMP,             -- 如果回滚了，记录回滚时间
  INDEX idx_page (page_id)
);
```

---

#### 5.12.4 两种运行方案

**方案A: 运行时渲染（推荐）**

```javascript
// 前端应用入口
import React from 'react';
import { BrowserRouter, Route } from 'react-router-dom';
import LowCodeRenderer from '@lowcode/renderer';

function App() {
  return (
    <BrowserRouter>
      {/* 动态路由：所有低代码页面都走这个路由 */}
      <Route path="/app/:pageRoute" component={LowCodePage} />
    </BrowserRouter>
  );
}

// 低代码页面组件
function LowCodePage({ match }) {
  const [schema, setSchema] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // 根据路由获取 Schema
    fetchSchema(match.params.pageRoute).then(data => {
      setSchema(data);
      setLoading(false);
    });
  }, [match.params.pageRoute]);

  if (loading) return <div>加载中...</div>;

  // 直接渲染 Schema
  return <LowCodeRenderer schema={schema} />;
}

// API 请求
async function fetchSchema(route) {
  const response = await fetch(`/api/pages/schema?route=${route}`);
  return await response.json();
}
```

**优点：**
- ✅ **热更新**：修改 Schema 立即生效，无需重新打包
- ✅ **版本切换**：数据库切换版本即可
- ✅ **回滚快速**：秒级回滚
- ✅ **统一管理**：所有页面共用一套 Runtime

**缺点：**
- ❌ 首次加载需要下载 Schema（但可以缓存）
- ❌ 依赖 Runtime 引擎

---

**方案B: 编译为代码（可选）**

```javascript
// 编译器：将 Schema 转换为 React 代码
class SchemaCompiler {
  compile(schema) {
    const code = `
import React from 'react';
import { Button, Table } from 'antd';

function GeneratedPage() {
  const [store, setStore] = useState(${JSON.stringify(schema.store)});

  // 编译 methods
  const handleDelete = async (userId) => {
    const confirmed = window.confirm("确认删除?");
    if (!confirmed) return;

    await fetch(\`/api/users/\${userId}\`, { method: 'DELETE' });
    alert('删除成功');
    // 刷新列表
  };

  // 编译组件树
  return (
    <div>
      <Button onClick={() => handleDelete(123)}>删除</Button>
      <Table dataSource={store.users} />
    </div>
  );
}

export default GeneratedPage;
    `;

    return code;
  }
}

// 发布时生成代码文件
POST /api/pages/:id/publish
→ 编译 Schema 为 React 代码
→ 生成 src/pages/UserManage.jsx 文件
→ 重新打包部署
```

**优点：**
- ✅ 不依赖 Runtime（代码完全独立）
- ✅ 性能更好（没有解析开销）
- ✅ 可以优化代码

**缺点：**
- ❌ 需要重新打包部署
- ❌ 发布流程复杂
- ❌ 回滚需要重新部署

---

#### 5.12.5 版本管理与回滚

```javascript
// 版本管理 API
class PageVersionManager {
  // 发布新版本
  async publish(pageId, schema) {
    const version = this.generateVersion(); // 生成版本号：1.0.0, 1.0.1

    await db.query(`
      INSERT INTO lowcode_page_versions (page_id, version, schema, status)
      VALUES (?, ?, ?, 'published')
    `, [pageId, version, JSON.stringify(schema)]);

    // 更新主表的当前版本
    await db.query(`
      UPDATE lowcode_pages
      SET current_version = ?, status = 'published'
      WHERE id = ?
    `, [version, pageId]);

    return version;
  }

  // 回滚到指定版本
  async rollback(pageId, targetVersion) {
    await db.query(`
      UPDATE lowcode_pages
      SET current_version = ?
      WHERE id = ?
    `, [targetVersion, pageId]);

    // 记录回滚历史
    await db.query(`
      INSERT INTO lowcode_publish_history (page_id, to_version, rollback_at)
      VALUES (?, ?, NOW())
    `, [pageId, targetVersion]);
  }

  // 获取版本列表
  async getVersions(pageId) {
    return await db.query(`
      SELECT version, published_at, published_by
      FROM lowcode_page_versions
      WHERE page_id = ?
      ORDER BY published_at DESC
    `, [pageId]);
  }
}
```

---

#### 5.12.6 完整的发布架构图

```
┌─────────────────────────────────────────────────────────────┐
│  用户操作                                                     │
│  [保存草稿] → [预览] → [发布] → [查看版本] → [回滚]            │
└────────────────┬────────────────────────────────────────────┘
                 │
                 ↓
┌─────────────────────────────────────────────────────────────┐
│  后端 API                                                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │ /save       │  │ /publish    │  │ /rollback   │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└────────────────┬────────────────────────────────────────────┘
                 │
                 ↓
┌─────────────────────────────────────────────────────────────┐
│  数据库                                                       │
│  ┌───────────────────────────────────────────────────────┐  │
│  │ lowcode_pages                                         │  │
│  │ - id: page_user_manage                                │  │
│  │ - current_version: "1.0.0"                            │  │
│  │ - status: published                                   │  │
│  └───────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────┐  │
│  │ lowcode_page_versions                                 │  │
│  │ - page_id: page_user_manage                           │  │
│  │ - version: "1.0.0"                                    │  │
│  │ - schema: { "store": {...}, "methods": {...} }       │  │
│  └───────────────────────────────────────────────────────┘  │
└────────────────┬────────────────────────────────────────────┘
                 │
                 ↓
┌─────────────────────────────────────────────────────────────┐
│  前端运行                                                     │
│  用户访问 /app/user-manage                                   │
│    → 查询 Schema (version: 1.0.0)                            │
│    → Renderer 渲染                                           │
│    → 页面展示                                                 │
└─────────────────────────────────────────────────────────────┘
```

---

#### 5.12.7 发布优化

**1. CDN 缓存**
```javascript
// Schema 加上 CDN 缓存
GET /api/pages/schema?route=/user-manage
Response Headers:
  Cache-Control: public, max-age=300  // 缓存 5 分钟
  ETag: "v1.0.0"
```

**2. 增量更新**
```javascript
// 只传输变化的部分
{
  "version": "1.0.1",
  "diff": {
    "methods.handleDelete.actions[2]": {
      "type": "replace",
      "value": { "type": "message", "payload": {...} }
    }
  }
}
```

**3. 预加载**
```javascript
// 应用启动时预加载常用页面的 Schema
async function preloadSchemas() {
  const routes = ['/dashboard', '/user-manage', '/order-list'];
  await Promise.all(routes.map(route =>
    fetch(`/api/pages/schema?route=${route}`)
      .then(r => r.json())
      .then(schema => schemaCache.set(route, schema))
  ));
}
```

---

#### 5.12.8 性能问题深度分析与解决方案

> 运行时渲染存在以下性能问题：
> - ❌ Runtime 引擎 ~200KB
> - ❌ 每次加载 Schema ~10-50KB
> - ❌ 动态加载物料有延迟
> - ❌ 首屏加载慢，体验差

**这是低代码平台面临的主要性能瓶颈。**

---

**性能对比分析**

| 加载项 | 传统手写 React | 运行时渲染（未优化） | 编译为代码 |
|-------|---------------|-------------------|-----------|
| **Runtime 引擎** | 0KB | 200KB ❌ | 0KB |
| **Schema JSON** | 0KB | 20-50KB ❌ | 0KB |
| **业务代码** | 100KB | 0KB | 80KB ✅ |
| **总计** | 100KB | 220-250KB | 80KB |
| **首屏时间** | ~500ms | ~2-3s ❌ | ~800ms ✅ |

---

### 解决方案：三种模式

**方案A：运行时渲染 + 激进优化（适合低频访问）**

```javascript
// 核心优化策略
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// 1. Runtime 打入主包（一次性加载）
// main.js
import LowCodeRenderer from '@lowcode/renderer';  // 200KB
// ✅ 优点：所有页面共享，只加载一次
// ❌ 缺点：增加主包体积

// 2. Schema 激进缓存
class SchemaCache {
  async fetch(route) {
    // 优先级1: 内存缓存（最快）
    if (this.memoryCache.has(route)) {
      return this.memoryCache.get(route);
    }

    // 优先级2: localStorage（持久化）
    const cached = localStorage.getItem(`schema:${route}`);
    if (cached) {
      const { schema, timestamp } = JSON.parse(cached);
      if (Date.now() - timestamp < 3600000) { // 1小时
        return schema;
      }
    }

    // 优先级3: 网络请求
    const schema = await fetch(`/api/schema?route=${route}`).then(r => r.json());

    // 缓存
    this.memoryCache.set(route, schema);
    localStorage.setItem(`schema:${route}`, JSON.stringify({
      schema,
      timestamp: Date.now()
    }));

    return schema;
  }
}

// 3. 物料预打包（不动态加载）
// material-registry/index.js
import Button from '@materials/button';
import Table from '@materials/table';
import Form from '@materials/form';
// ... 常用 10-20 个物料

MaterialRegistry.registerBatch({ Button, Table, Form });

// 4. Service Worker 离线缓存
// service-worker.js
self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('/api/schema')) {
    event.respondWith(
      caches.match(event.request)
        .then(cached => cached || fetch(event.request))
    );
  }
});
```

**优化后的性能：**
```
首次访问（冷启动）:
  主 bundle: 500KB（含 Runtime 200KB + 物料 300KB）
  Schema: 20KB
  首屏: ~2s

第二次访问（缓存命中）:
  主 bundle: 缓存 ✅
  Schema: localStorage 缓存 ✅
  首屏: ~200ms ✅✅✅

切换页面:
  Schema: 缓存命中 ✅
  首屏: ~100ms ✅✅✅
```

---

**方案B：编译为代码（推荐 C 端应用）⭐**

```javascript
// 编译器：Schema → 优化的 React 代码
class OptimizedCompiler {
  compile(schema) {
    // 分析用到的物料和动作
    const usedMaterials = this.analyzeComponents(schema);
    const usedActions = this.analyzeActions(schema);

    return `
// ✅ 只引入用到的物料（Tree Shaking）
import { Button, Table } from 'antd';

// ✅ 只生成用到的动作代码（不需要整个 Runtime）
const confirmAction = (msg) => window.confirm(msg);
const requestAction = async (url, opts) => {
  const res = await fetch(url, opts);
  return res.json();
};

// ✅ 编译为标准 React 组件
export default function UserManagePage() {
  const [store, setStore] = useState({
    users: [],
    loading: false
  });

  const handleDelete = async (userId) => {
    if (!confirmAction('确认删除?')) return;

    await requestAction(\`/api/users/\${userId}\`, { method: 'DELETE' });
    antd.message.success('删除成功');

    // 刷新列表
    const users = await requestAction('/api/users');
    setStore({ ...store, users });
  };

  return (
    <div>
      <Button onClick={() => setStore({ modalVisible: true })}>
        新增
      </Button>
      <Table
        dataSource={store.users}
        columns={[
          { title: '用户名', dataIndex: 'username' },
          {
            title: '操作',
            render: (_, record) => (
              <Button onClick={() => handleDelete(record.id)}>删除</Button>
            )
          }
        ]}
      />
    </div>
  );
}
    `;
  }
}

// 发布流程
POST /api/pages/:id/publish
  ↓ 编译
src/pages/UserManage.jsx
  ↓ Webpack 打包
dist/user-manage.chunk.js (50KB) ✅
  ↓ 部署
CDN
```

**性能：**
```
首次访问:
  主 bundle: 300KB
  页面 chunk: 50KB（只包含该页面）
  首屏: ~800ms ✅✅

再次访问:
  完全缓存 ✅
  首屏: ~100ms ✅✅✅

优势:
  ✅ 体积小（Tree Shaking）
  ✅ 无 Runtime 解析开销
  ✅ 标准 React 代码，可优化

劣势:
  ❌ 失去热更新
  ❌ 发布需要重新打包
```

---

**方案C：混合模式（大型应用推荐）⭐⭐⭐**

```javascript
// 根据访问频率自动选择方案
class SmartPublisher {
  async publish(pageId, schema, options) {
    const { route, visitFrequency } = options;

    // 高频页面 → 编译为代码
    if (visitFrequency === 'high') {
      await this.compileToCode(schema, route);
    }
    // 低频页面 → 运行时渲染
    else {
      await this.saveAsSchema(schema, route);
    }
  }
}

// 路由配置
function App() {
  return (
    <BrowserRouter>
      {/* 高频页面：编译后的静态路由 */}
      <Route path="/dashboard" component={CompiledDashboard} />
      <Route path="/user-manage" component={CompiledUserManage} />

      {/* 低频页面：动态运行时渲染 */}
      <Route path="/app/:route" component={RuntimePage} />
    </BrowserRouter>
  );
}
```

---

### 真实场景性能对比

| 场景 | 推荐方案 | 首屏时间 | 包体积 | 热更新 |
|------|---------|---------|--------|--------|
| **中后台管理** | 方案A + 优化 | 1-2s → 200ms（缓存） | 500KB | ✅ |
| **C端高频页面** | 方案B | 800ms → 100ms（缓存） | 300KB | ❌ |
| **大型应用** | 方案C | 1s → 150ms（缓存） | 400KB | ⚠️ |

---

### 最佳实践建议

```javascript
// 中后台系统（用户可接受稍慢的首屏）
方案A + 激进缓存
✅ Runtime 打主包
✅ Schema localStorage 缓存 1小时
✅ 物料预打包
✅ Service Worker
→ 首屏 1-2s（首次），200-500ms（缓存）

// C端应用（性能要求高）
方案B 编译为代码
✅ Schema → React 代码
✅ Tree Shaking
✅ Code Splitting
✅ CDN 部署
→ 首屏 500-800ms

// 大型应用（兼顾性能和灵活性）
方案C 混合模式
✅ 高频页面编译
✅ 低频页面运行时
✅ 按需选择
→ 首屏 800ms-1.5s
```

---

### 总结

纯运行时渲染在性能方面存在明显不足，需要根据实际场景选择合适的优化方案。

**实际解决方案：**
1. **后台系统**：方案A + 激进缓存（可接受）
2. **C端应用**：方案B 编译为代码（推荐）⭐
3. **大型应用**：方案C 混合模式（最佳）⭐⭐⭐

**核心原则**：不要盲目追求"纯配置化"，而应根据场景特点（访问频率、性能要求、灵活性需求）选择合适的技术方案。

---

#### 5.12.9 Schema 编译器深度实现（方案B详解）

对于 C 端高性能场景，编译方案是最优选择。编译器的核心目标是：**保持 Runtime 架构不变，优化依赖加载方式**，将运行时的动态加载转换为编译时的静态引入。

**核心原则**：
- ✅ 保持 GlobalStoreManager、ExpressionEngine、Renderer 等核心架构
- ✅ Schema 内联到代码中（避免网络请求）
- ✅ 物料静态引入（支持 Tree Shaking）
- ✅ 动作静态引入（避免动态查找）
- ✅ 使用精简版 Runtime（移除动态加载逻辑）
- ❌ 不转换为原生 React 代码（保持架构一致性）

---

**编译器架构设计**

编译器采用三阶段架构，专注于依赖分析和代码生成：

```javascript
// packages/compiler/src/Compiler.js

class SchemaCompiler {
  constructor(options = {}) {
    this.options = {
      runtimePackage: '@lowcode/runtime-slim',  // 使用精简版 Runtime
      outputFormat: 'esm',
      minify: true,
      ...options
    };

    // 编译器三阶段流水线
    this.pipeline = [
      new SchemaValidator(),      // 1. Schema 验证
      new DependencyAnalyzer(),   // 2. 依赖分析（物料、动作）
      new CodeGenerator()         // 3. 生成代码（保持 Runtime 架构）
    ];
  }

  /**
   * 编译 Schema 为优化的 React 组件
   * @param {Object} schema - Schema JSON
   * @returns {CompileResult}
   */
  async compile(schema) {
    let context = { schema, options: this.options };

    // 执行编译流水线
    for (const stage of this.pipeline) {
      context = await stage.execute(context);
    }

    return {
      success: true,
      code: context.generatedCode,        // 生成的 React 组件代码
      dependencies: context.dependencies   // 依赖清单
    };
  }
}
```

---

**阶段1：Schema 验证**

```javascript
// packages/compiler/src/stages/SchemaValidator.js

class SchemaValidator {
  async execute(context) {
    const { schema } = context;

    // 验证 Schema 基本结构
    if (!schema.id || !schema.componentTree) {
      throw new Error('Invalid schema: missing required fields');
    }

    // Schema 直接传递，不做结构转换
    return { ...context };
  }
}
```

---

**阶段2：依赖分析**

编译器的核心工作是分析 Schema 中用到的物料和动作，生成静态 import 语句：

```javascript
// packages/compiler/src/stages/DependencyAnalyzer.js

class DependencyAnalyzer {
  async execute(context) {
    const { schema } = context;

    // 递归分析组件树，提取所有用到的物料
    const materials = this.analyzeMaterials(schema.componentTree);

    // 分析方法中用到的动作
    const actions = this.analyzeActions(schema.methods || {});

    const dependencies = {
      materials,  // { 'antd': ['Button', 'Table'], ... }
      actions     // Set(['request', 'confirm', 'message', ...])
    };

    return { ...context, dependencies };
  }

  /**
   * 递归遍历组件树，收集所有物料
   */
  analyzeMaterials(tree) {
    const materials = new Map();

    const traverse = (node) => {
      const { componentName, children } = node;

      // 记录物料使用
      const library = this.resolveLibrary(componentName);  // 'Button' → 'antd'
      if (!materials.has(library)) {
        materials.set(library, new Set());
      }
      materials.get(library).add(componentName);

      // 递归子节点
      if (children) {
        children.forEach(child => traverse(child));
      }
    };

    traverse(tree);

    // 转换为对象格式
    const result = {};
    materials.forEach((components, library) => {
      result[library] = Array.from(components);
    });

    return result;
  }

  /**
   * 分析方法中用到的动作类型
   */
  analyzeActions(methods) {
    const actions = new Set();

    Object.values(methods).forEach(method => {
      method.actions?.forEach(action => {
        actions.add(action.type);  // 'request', 'confirm', 'setState', ...
      });
    });

    return actions;
  }

  /**
   * 根据组件名推断所属的物料库
   */
  resolveLibrary(componentName) {
    // 简化示例：实际需要查询物料注册表
    const antdComponents = ['Button', 'Table', 'Form', 'Modal', 'Input'];
    if (antdComponents.includes(componentName)) {
      return 'antd';
    }
    return '@lowcode/materials';
  }
}
```

---

**阶段3：代码生成**

生成包含 Runtime 渲染器的 React 组件：

```javascript
// packages/compiler/src/stages/CodeGenerator.js

class CodeGenerator {
  async execute(context) {
    const { schema, dependencies, options } = context;

    // 生成 import 语句
    const imports = this.generateImports(dependencies, options.runtimePackage);

    // 生成预注册代码
    const registrations = this.generateRegistrations(dependencies);

    // Schema 内联（序列化为 JavaScript 对象）
    const schemaCode = this.serializeSchema(schema);

    // 组装完整代码
    const generatedCode = \`
\${imports}

/**
 * \${schema.name || schema.id}
 * Auto-generated by @lowcode/compiler
 * 
 * ⚠️ 架构说明：
 * - 使用精简版 Runtime（移除动态加载逻辑）
 * - Schema 内联（避免网络请求）
 * - 物料静态引入（支持 Tree Shaking）
 * - 动作静态引入（避免运行时查找）
 * 
 * ✅ 核心架构与运行时模式完全一致：
 * - GlobalStoreManager：全局状态管理
 * - ExpressionEngine：表达式解析
 * - Renderer：组件渲染
 * - EventHandler：事件处理
 */

// Schema 内联
const schema = \${schemaCode};

\${registrations}

export default function \${this.toPascalCase(schema.id)}Page() {
  return (
    <LowCodeRenderer 
      schema={schema}
      materials={materials}
      actions={actions}
    />
  );
}
    \`.trim();

    return { ...context, generatedCode };
  }

  /**
   * 生成 import 语句
   */
  generateImports(dependencies, runtimePackage) {
    const lines = [];

    // 1. 导入 React
    lines.push("import React from 'react';");

    // 2. 导入精简版 Runtime
    lines.push(\`import { LowCodeRenderer } from '\${runtimePackage}';\`);

    // 3. 导入物料（静态引入，支持 Tree Shaking）
    Object.entries(dependencies.materials).forEach(([library, components]) => {
      lines.push(\`import { \${components.join(', ')} } from '\${library}';\`);
    });

    // 4. 导入动作实现
    const actionsList = Array.from(dependencies.actions);
    if (actionsList.length > 0) {
      const actionImports = actionsList.map(action => \`\${action}Action\`).join(', ');
      lines.push(\`import { \${actionImports} } from '@lowcode/actions';\`);
    }

    return lines.join('\n');
  }

  /**
   * 生成预注册代码
   */
  generateRegistrations(dependencies) {
    const code = [];

    // 物料预注册
    code.push('// 物料预注册（避免动态加载）');
    code.push('const materials = {');
    Object.values(dependencies.materials).flat().forEach(comp => {
      code.push(\`  \${comp},\`);
    });
    code.push('};');
    code.push('');

    // 动作预注册
    const actionsList = Array.from(dependencies.actions);
    if (actionsList.length > 0) {
      code.push('// 动作预注册（避免运行时查找）');
      code.push('const actions = {');
      actionsList.forEach(action => {
        code.push(\`  \${action}: \${action}Action,\`);
      });
      code.push('};');
    }

    return code.join('\n');
  }

  /**
   * 序列化 Schema 为 JavaScript 对象
   */
  serializeSchema(schema) {
    return JSON.stringify(schema, null, 2);
  }

  toPascalCase(str) {
    return str.replace(/(^\w|-\w)/g, s => s.replace('-', '').toUpperCase());
  }
}
```

---

**完整示例：编译前后对比**

**输入：运行时模式的页面组件**

```javascript
// 运行时模式：需要动态加载 Schema 和物料
import { LowCodeRenderer } from '@lowcode/runtime';  // 200KB

export default function RuntimePage() {
  const [schema, setSchema] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // 1. 网络请求加载 Schema（~200ms）
    fetch('/api/schema?route=/user-manage')
      .then(res => res.json())
      .then(data => {
        setSchema(data);
        setLoading(false);
      });
  }, []);

  if (loading) return <div>Loading...</div>;

  // 2. Runtime 内部动态加载物料和动作（~300ms）
  return <LowCodeRenderer schema={schema} />;
}
```

**输出：编译模式的页面组件**

```javascript
// 编译模式：所有依赖静态引入
import React from 'react';
import { LowCodeRenderer } from '@lowcode/runtime-slim';  // 50KB（精简版）
import { Button, Table } from 'antd';  // 静态引入物料
import { requestAction, confirmAction, messageAction, setStateAction } from '@lowcode/actions';  // 静态引入动作

/**
 * 用户管理页面
 * Auto-generated by @lowcode/compiler
 * 
 * ⚠️ 架构说明：
 * - 使用精简版 Runtime（移除动态加载逻辑）
 * - Schema 内联（避免网络请求）
 * - 物料静态引入（支持 Tree Shaking）
 * - 动作静态引入（避免运行时查找）
 * 
 * ✅ 核心架构与运行时模式完全一致：
 * - GlobalStoreManager：全局状态管理
 * - ExpressionEngine：表达式解析
 * - Renderer：组件渲染
 * - EventHandler：事件处理
 */

// Schema 内联（避免网络请求）
const schema = {
  "id": "user-manage",
  "name": "用户管理页面",
  "store": {
    "users": [],
    "loading": false
  },
  "methods": {
    "loadUsers": {
      "params": [],
      "actions": [
        { "type": "setState", "payload": { "loading": true } },
        {
          "type": "request",
          "method": "GET",
          "url": "/api/users",
          "successAction": {
            "type": "setState",
            "payload": { "users": "\${response.data}", "loading": false }
          }
        }
      ]
    },
    "handleDelete": {
      "params": ["userId"],
      "actions": [
        { "type": "confirm", "message": "确认删除该用户？" },
        {
          "type": "request",
          "method": "DELETE",
          "url": "/api/users/\${userId}",
          "successAction": { "type": "message", "content": "删除成功" }
        },
        { "type": "method", "method": "loadUsers" }
      ]
    }
  },
  "lifecycle": {
    "onLoad": [{ "type": "method", "method": "loadUsers" }]
  },
  "componentTree": {
    "componentName": "div",
    "props": { "className": "page" },
    "children": [
      {
        "componentName": "Button",
        "props": { "type": "primary", "loading": "\${store.loading}" },
        "events": { "onClick": { "type": "method", "method": "loadUsers" } },
        "children": [{ "componentName": "text", "value": "刷新" }]
      },
      {
        "componentName": "Table",
        "props": {
          "dataSource": "\${store.users}",
          "loading": "\${store.loading}"
        }
      }
    ]
  }
};

// 物料预注册（避免动态加载）
const materials = {
  Button,
  Table,
};

// 动作预注册（避免运行时查找）
const actions = {
  request: requestAction,
  confirm: confirmAction,
  message: messageAction,
  setState: setStateAction,
};

export default function UserManagePage() {
  return (
    <LowCodeRenderer 
      schema={schema}
      materials={materials}
      actions={actions}
    />
  );
}
```

---

**Runtime 分层设计**

为了支持编译模式，Runtime 需要分为两个版本：

```javascript
// packages/runtime/src/index.js (完整版 - 用于运行时渲染)
export { LowCodeRenderer } from './Renderer';
export { MaterialLoader } from './MaterialLoader';      // 动态加载物料
export { ActionRegistry } from './ActionRegistry';      // 动作注册表
export { SchemaLoader } from './SchemaLoader';          // Schema 加载器
// 体积：~200KB

// packages/runtime-slim/src/index.js (精简版 - 用于编译模式)
export { LowCodeRenderer } from '../runtime/src/Renderer';
// ❌ 不包含 MaterialLoader（物料已静态引入）
// ❌ 不包含 ActionRegistry（动作已静态引入）
// ❌ 不包含 SchemaLoader（Schema 已内联）
// 体积：~50KB（减少 75%）
```

**LowCodeRenderer 支持预注册**

```javascript
// packages/runtime/src/Renderer.jsx

export function LowCodeRenderer({ schema, materials, actions }) {
  const [runtime] = useState(() => {
    // 创建 Runtime 实例
    const rt = new LowCodeRuntime(schema);

    // 如果提供了预注册的物料，直接使用（编译模式）
    if (materials) {
      rt.materialRegistry.registerBatch(materials);
    }

    // 如果提供了预注册的动作，直接使用（编译模式）
    if (actions) {
      rt.actionRegistry.registerBatch(actions);
    }

    return rt;
  });

  // 渲染逻辑完全一致（运行时模式和编译模式共享同一套渲染逻辑）
  return renderComponentTree(runtime, schema.componentTree);
}
```

---

**性能对比：运行时 vs 编译**

| 指标 | 运行时渲染 | 编译模式 | 性能提升 |
|------|-----------|---------|---------|
| **Schema 加载** | \`fetch('/api/schema')\` ~200ms | 内联（0ms） | **100% ↓** |
| **物料加载** | 动态 \`import()\` ~300ms | 静态 \`import\`（Webpack处理） | **100% ↓** |
| **动作查找** | \`ActionRegistry.get('request')\` ~1ms | 直接引用 \`requestAction\` | **100% ↓** |
| **Runtime 体积** | 200KB（含加载逻辑） | 50KB（精简版） | **75% ↓** |
| **首屏 JS 总体积** | 220KB（Runtime 200KB + Schema 20KB） | 80KB（Runtime 50KB + Code 30KB） | **64% ↓** |
| **首次加载时间** | 2.5s | 0.8s | **68% ↓** |
| **GlobalStore** | ✅ GlobalStoreManager | ✅ GlobalStoreManager（一致） | - |
| **表达式解析** | ✅ ExpressionEngine | ✅ ExpressionEngine（一致） | - |
| **事件处理** | ✅ EventHandler | ✅ EventHandler（一致） | - |
| **跨组件数据共享** | ✅ \`\${store.xxx}\` | ✅ \`\${store.xxx}\`（一致） | - |

**关键发现**：
- ✅ 性能提升来自**依赖优化**，不是架构改变
- ✅ 核心架构（Store、表达式、事件）完全一致
- ✅ 跨组件数据流向机制保持不变
- ✅ 开发和维护成本最低

---

**集成到发布流程**

```javascript
// 发布接口
app.post('/api/pages/:id/publish', async (req, res) => {
  const { id } = req.params;
  const { schema, publishMode } = req.body;

  if (publishMode === 'compile') {
    // 方案B：编译模式
    const compiler = new SchemaCompiler({
      runtimePackage: '@lowcode/runtime-slim',
      outputFormat: 'esm',
      minify: true
    });

    const result = await compiler.compile(schema);

    if (result.success) {
      // 写入文件系统
      const outputPath = path.join(__dirname, \`../pages/\${id}.jsx\`);
      await fs.writeFile(outputPath, result.code);

      // 触发 Webpack/Vite 构建
      await buildPage(id);

      res.json({
        success: true,
        mode: 'compile',
        entry: \`/pages/\${id}.js\`,
        dependencies: result.dependencies
      });
    }
  } else {
    // 方案A：运行时模式
    await db.pageVersions.create({
      pageId: id,
      schema: schema,
      mode: 'runtime'
    });

    res.json({ success: true, mode: 'runtime' });
  }
});
```

---

**编译方案的优势**

1. **性能最优**：消除动态加载开销，首屏时间减少 68%
2. **体积最小**：Tree Shaking 剔除未使用的物料，体积减少 64%
3. **架构一致**：核心逻辑与运行时模式完全相同，维护成本低
4. **调试友好**：生成的是标准 React 代码，有完整的 Source Map
5. **SEO 友好**：可进行 SSR/SSG 等服务端渲染优化
6. **独立部署**：编译产物可独立部署到 CDN

**编译方案的劣势**

1. **失去热更新**：修改 Schema 后需重新编译和部署
2. **构建时间**：编译过程需要 1-3 秒（可通过增量编译优化）

---

**服务端渲染（SSR）支持**

编译模式的重要优势之一是**天然支持 SSR/SSG**，这是运行时模式难以实现的。

**为什么编译模式适合 SSR？**

```javascript
// 编译后的组件是标准 React 组件
export default function UserManagePage() {
  return (
    <LowCodeRenderer
      schema={schema}
      materials={materials}
      actions={actions}
    />
  );
}

// ✅ 可以直接用于 Next.js
// pages/user-manage.jsx (Next.js App Router)
export default UserManagePage;

// ✅ 支持 SSR
export async function getServerSideProps() {
  // 可以在服务端预加载数据
  const users = await fetchUsers();

  return {
    props: {
      initialData: { users }
    }
  };
}

// ✅ 支持 SSG
export async function getStaticProps() {
  const users = await fetchUsers();

  return {
    props: { initialData: { users } },
    revalidate: 60 // ISR: 每60秒重新生成
  };
}
```

**Runtime 需要支持 SSR**

为了在服务端渲染，Runtime 需要：

1. **避免浏览器 API 依赖**

```javascript
// packages/runtime-slim/src/Renderer.jsx

export function LowCodeRenderer({ schema, materials, actions, initialData }) {
  const [runtime] = useState(() => {
    const rt = new LowCodeRuntime(schema);

    rt.materialRegistry.registerBatch(materials);
    rt.actionRegistry.registerBatch(actions);

    // ✅ 如果有服务端预加载的数据，初始化到 Store
    if (initialData) {
      rt.storeManager.updateStore(initialData);
    }

    return rt;
  });

  // ⚠️ 避免在 render 阶段使用浏览器 API
  // ❌ window.location
  // ❌ document.cookie
  // ❌ localStorage

  // ✅ 使用 useEffect 包裹浏览器 API
  useEffect(() => {
    if (typeof window !== 'undefined') {
      // 客户端才执行的逻辑
    }
  }, []);

  return renderComponentTree(runtime, schema.componentTree);
}
```

2. **动作系统的 SSR 适配**

```javascript
// packages/actions/src/requestAction.js

export async function requestAction(config, context) {
  const { url, method, data } = config;

  // ✅ 服务端和客户端都可以用 fetch
  const response = await fetch(url, {
    method,
    body: data ? JSON.stringify(data) : undefined,
    headers: {
      'Content-Type': 'application/json',
      // ⚠️ 服务端请求需要处理认证
      ...(context.isServer && context.cookies ? {
        'Cookie': context.cookies
      } : {})
    }
  });

  return response.json();
}
```

3. **SSR 时的数据预加载**

```javascript
// 发布时生成支持 SSR 的代码
class SSRCodeGenerator extends CodeGenerator {
  generateCode(schema) {
    const code = super.generateCode(schema);

    // 分析 lifecycle.onLoad 中的数据请求
    const dataFetchActions = this.analyzeDataFetch(schema.lifecycle?.onLoad);

    // 生成 getServerSideProps
    const ssrCode = this.generateSSRFunction(dataFetchActions);

    return code + '\n\n' + ssrCode;
  }

  generateSSRFunction(dataFetchActions) {
    return `
// SSR 数据预加载
export async function getServerSideProps(context) {
  try {
    // 在服务端预执行数据请求
    ${dataFetchActions.map(action => `
    const ${action.key} = await fetch('${action.url}', {
      headers: {
        cookie: context.req.headers.cookie || ''
      }
    }).then(r => r.json());
    `).join('\n')}

    return {
      props: {
        initialData: {
          ${dataFetchActions.map(a => a.key).join(',\n          ')}
        }
      }
    };
  } catch (error) {
    return { props: { initialData: {} } };
  }
}
    `;
  }
}
```

**完整的 SSR 示例**

**编译产物（支持 Next.js）**

```javascript
// pages/user-manage.jsx
import React from 'react';
import { LowCodeRenderer } from '@lowcode/runtime-slim';
import { Button, Table } from 'antd';
import { requestAction, messageAction } from '@lowcode/actions';

const schema = {
  "id": "user-manage",
  "store": {
    "users": [],
    "loading": false
  },
  "methods": {
    "loadUsers": {
      "actions": [
        { "type": "request", "url": "/api/users" }
      ]
    }
  },
  "lifecycle": {
    "onLoad": [{ "type": "method", "method": "loadUsers" }]
  },
  "componentTree": {
    "componentName": "div",
    "children": [
      {
        "componentName": "Table",
        "props": { "dataSource": "${store.users}" }
      }
    ]
  }
};

const materials = { Button, Table };
const actions = { request: requestAction, message: messageAction };

export default function UserManagePage({ initialData }) {
  return (
    <LowCodeRenderer
      schema={schema}
      materials={materials}
      actions={actions}
      initialData={initialData}  // 服务端预加载的数据
    />
  );
}

// SSR：每次请求时在服务端获取数据
export async function getServerSideProps(context) {
  try {
    const users = await fetch('https://api.example.com/users', {
      headers: {
        cookie: context.req.headers.cookie || ''
      }
    }).then(r => r.json());

    return {
      props: {
        initialData: { users }
      }
    };
  } catch (error) {
    return { props: { initialData: {} } };
  }
}

// 或者 SSG：构建时生成静态页面
/*
export async function getStaticProps() {
  const users = await fetch('https://api.example.com/users').then(r => r.json());

  return {
    props: { initialData: { users } },
    revalidate: 60  // ISR: 60秒后重新生成
  };
}
*/
```

**性能对比：CSR vs SSR**

| 指标 | 编译模式 CSR | 编译模式 SSR | 提升 |
|------|------------|------------|------|
| **首屏内容渲染** | 客户端请求数据后渲染 | 服务端直接返回 HTML | **FCP 减少 60%** |
| **SEO** | ⚠️ 需要等 JS 执行 | ✅ 搜索引擎直接抓取 | **SEO 友好** |
| **LCP** | ~2s（等待 JS + 数据） | ~0.5s（HTML 已渲染） | **75% ↓** |
| **TTI** | ~3s | ~1.5s | **50% ↓** |
| **弱网环境** | ❌ 体验差 | ✅ 体验好 | **显著提升** |

**业界实践**

1. **阿里低代码引擎**：支持 SSR，通过 `@alilc/lowcode-engine-ssr` 包实现
2. **百度 Amis**：支持服务端渲染，用于 SEO 敏感场景
3. **腾讯 TMagic**：提供 SSR 方案用于 H5 营销页面
4. **现代电商平台**：商品详情页大量使用低代码 + SSR（性能和 SEO 双重要求）

**SSR 的关键优势**

1. **SEO 优化**：搜索引擎可以直接抓取完整 HTML
2. **首屏速度**：减少客户端渲染等待时间
3. **弱网友好**：减少客户端 JS 执行负担
4. **社交分享**：Open Graph 元数据可以被正确解析

**SSR 的适用场景**

- ✅ **营销落地页**：需要 SEO + 快速首屏
- ✅ **电商商品页**：SEO + 性能双重要求
- ✅ **内容类页面**：新闻、博客、文档
- ✅ **H5 活动页**：移动端性能优化
- ❌ **高度交互页面**：后台管理系统（CSR 更合适）
- ❌ **实时数据页面**：Dashboard（SSR 收益低）

---

**适用场景**

- ✅ **C端高频页面**：首页、商品详情、列表页等
- ✅ **性能敏感场景**：移动端、弱网环境
- ✅ **SEO需求页面**：营销落地页、内容页
- ❌ **高度动态页面**：需要频繁调整的运营活动页
- ❌ **个性化页面**：千人千面、A/B测试场景
### 5.13 运行时能力总结

---

## 六、构建工具链设计

### 6.1 CLI工具

```javascript
// packages/cli/index.js
const { Command } = require('commander');
const program = new Command();

program
  .name('lowcode-cli')
  .description('Low-Code Platform CLI')
  .version('1.0.0');

// 创建物料
program
  .command('create <name>')
  .description('Create a new material')
  .option('-t, --template <type>', 'Material template', 'basic')
  .action(async (name, options) => {
    const creator = require('./commands/create');
    await creator.create(name, options);
  });

// 开发模式
program
  .command('dev')
  .description('Start development server')
  .option('-p, --port <port>', 'Port number', '3000')
  .action(async (options) => {
    const devServer = require('./commands/dev');
    await devServer.start(options);
  });

// 构建
program
  .command('build')
  .description('Build material')
  .option('-o, --outDir <dir>', 'Output directory', 'dist')
  .action(async (options) => {
    const builder = require('./commands/build');
    await builder.build(options);
  });

// 发布
program
  .command('publish')
  .description('Publish material to registry')
  .option('--registry <url>', 'NPM registry URL')
  .option('--cdn', 'Upload to CDN')
  .action(async (options) => {
    const publisher = require('./commands/publish');
    await publisher.publish(options);
  });

program.parse();
```

### 6.2 开发服务器

```javascript
// packages/cli/commands/dev.js
const express = require('express');
const { createServer } = require('vite');

async function startDevServer(options) {
  const app = express();

  // Vite开发服务器
  const vite = await createServer({
    server: { middlewareMode: true },
    appType: 'custom'
  });

  app.use(vite.middlewares);

  // 物料预览页面
  app.get('/preview', async (req, res) => {
    const template = `
      <!DOCTYPE html>
      <html>
        <head>
          <title>Material Preview</title>
        </head>
        <body>
          <div id="root"></div>
          <script type="module" src="/src/demo/index.jsx"></script>
        </body>
      </html>
    `;
    res.send(await vite.transformIndexHtml('/preview', template));
  });

  const port = options.port || 3000;
  app.listen(port, () => {
    console.log(`🚀 Dev server running at http://localhost:${port}`);
  });
}

module.exports = { start: startDevServer };
```

### 6.3 物料模板

```javascript
// packages/cli/templates/basic/template.js
module.exports = {
  name: '{{name}}',
  files: {
    'src/index.jsx': `
import React from 'react';
import './style.css';

function {{Name}}(props) {
  return (
    <div className="{{name}}">
      {{Name}} Component
    </div>
  );
}

export default {{Name}};
    `,

    'src/style.css': `
.{{name}} {
  padding: 10px;
  border: 1px solid #ccc;
}
    `,

    'lowcode-meta.json': `
{
  "name": "{{Name}}",
  "title": "{{title}}",
  "category": "custom",
  "props": [
    {
      "name": "className",
      "title": "样式类名",
      "type": "string"
    }
  ],
  "snippets": {
    "componentName": "{{Name}}",
    "props": {}
  }
}
    `,

    'package.json': `
{
  "name": "@lowcode-materials/{{name}}",
  "version": "1.0.0",
  "main": "dist/index.js",
  "scripts": {
    "dev": "lowcode-cli dev",
    "build": "lowcode-cli build"
  }
}
    `
  }
};
```

---

## 七、物料生态体系

### 7.1 物料分层

```
┌────────────────────────────────────────┐
│         页面模板 (Page Templates)        │  完整页面
├────────────────────────────────────────┤
│          区块 (Blocks)                  │  组合型组件
├────────────────────────────────────────┤
│       业务组件 (Business Components)    │  业务封装
├────────────────────────────────────────┤
│       基础组件 (Base Components)        │  原子组件
└────────────────────────────────────────┘
```

**示例:**

```javascript
// 1. 基础组件
@lowcode-materials/button
@lowcode-materials/input
@lowcode-materials/table

// 2. 业务组件
@mycompany/user-selector     // 用户选择器
@mycompany/dept-tree         // 部门树

// 3. 区块
@mycompany/login-form-block  // 登录表单区块
@mycompany/user-list-block   // 用户列表区块

// 4. 页面模板
@mycompany/dashboard-template // 仪表盘模板
@mycompany/form-page-template // 表单页模板
```

### 7.2 物料标准规范

```javascript
// 物料包结构规范
{
  "name": "@scope/material-name",
  "version": "1.0.0",
  "description": "物料描述",

  // 入口文件
  "main": "dist/index.js",
  "module": "dist/index.es.js",

  // 依赖
  "peerDependencies": {
    "react": ">=16.8.0",
    "react-dom": ">=16.8.0"
  },

  // 低代码元信息
  "lowcode": {
    "meta": "dist/metadata.json",
    "preview": "dist/preview.png"
  },

  // 其他标准字段
  "keywords": ["lowcode", "material", "component"],
  "license": "MIT"
}
```

### 7.3 物料市场

```javascript
// 物料市场后端API
class MaterialMarketAPI {
  // 获取物料列表
  async list(params) {
    // GET /api/materials?category=basic&keyword=button
    return {
      total: 100,
      items: [
        {
          id: 'mat_001',
          name: '@lc/button',
          title: '按钮',
          description: '基础按钮组件',
          category: 'basic',
          version: '1.0.0',
          downloads: 1000,
          rating: 4.5,
          author: 'lowcode-team',
          preview: 'https://cdn.../preview.png'
        }
      ]
    };
  }

  // 获取物料详情
  async detail(materialId) {
    // GET /api/materials/:id
    return {
      id: 'mat_001',
      name: '@lc/button',
      versions: ['1.0.0', '1.1.0', '2.0.0'],
      readme: '# Button Component\n...',
      metadata: { /* lowcode-meta.json */ },
      dependencies: ['react'],
      demos: [
        { title: '基础用法', code: '...' }
      ]
    };
  }

  // 安装物料
  async install(materialName, version) {
    // POST /api/materials/install
    // 后端执行: npm install @lc/button@1.0.0
    return { success: true };
  }
}
```

---

## 八、性能与安全

### 8.1 渲染性能优化

```javascript
// 1. 组件缓存
const MaterialCache = new Map();

function getCachedComponent(componentName) {
  if (!MaterialCache.has(componentName)) {
    const Component = loadComponent(componentName);
    MaterialCache.set(componentName, React.memo(Component));
  }
  return MaterialCache.get(componentName);
}

// 2. 表达式缓存
class ExpressionCache {
  constructor(maxSize = 1000) {
    this.cache = new Map();
    this.maxSize = maxSize;
  }

  get(key) {
    return this.cache.get(key);
  }

  set(key, value) {
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
}

// 3. 虚拟列表
import { FixedSizeList } from 'react-window';

function LargeList({ items }) {
  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {({ index, style }) => (
        <div style={style}>{items[index]}</div>
      )}
    </FixedSizeList>
  );
}
```

### 8.2 安全防护

```javascript
// 1. 表达式沙箱
class SafeExpressionEvaluator {
  constructor() {
    this.allowedGlobals = ['Math', 'Date', 'JSON', 'Object', 'Array'];
    this.blockedGlobals = ['window', 'document', 'eval', 'Function'];
  }

  evaluate(expression, context) {
    // 检查是否包含危险代码
    if (this.containsDangerousCode(expression)) {
      throw new Error('Expression contains dangerous code');
    }

    // 创建安全上下文
    const safeContext = this.createSafeContext(context);

    // 使用Function构造器(限制作用域)
    try {
      const fn = new Function(
        ...Object.keys(safeContext),
        `return (${expression});`
      );
      return fn(...Object.values(safeContext));
    } catch (error) {
      console.error('Expression evaluation error:', error);
      return null;
    }
  }

  containsDangerousCode(expression) {
    const dangerousPatterns = [
      /eval\s*\(/,
      /Function\s*\(/,
      /\bwindow\b/,
      /\bdocument\b/,
      /__proto__/,
      /constructor/
    ];

    return dangerousPatterns.some(pattern => pattern.test(expression));
  }

  createSafeContext(context) {
    // 只暴露安全的API
    return {
      ...context,
      Math,
      Date,
      JSON: JSON,
      console: {
        log: console.log.bind(console),
        warn: console.warn.bind(console)
      }
    };
  }
}

// 2. XSS防护
import DOMPurify from 'dompurify';

function sanitizeProps(props) {
  const sanitized = {};

  for (const [key, value] of Object.entries(props)) {
    if (typeof value === 'string') {
      // 对字符串内容进行清洗
      sanitized[key] = DOMPurify.sanitize(value);
    } else if (key === 'dangerouslySetInnerHTML') {
      // 禁止使用dangerouslySetInnerHTML
      console.warn('dangerouslySetInnerHTML is not allowed');
      continue;
    } else {
      sanitized[key] = value;
    }
  }

  return sanitized;
}

// 3. 权限控制
class PermissionManager {
  checkPermission(user, action, resource) {
    // 检查用户是否有权限执行某个操作
    const userRoles = user.roles || [];
    const requiredRoles = this.getRequiredRoles(action, resource);

    return requiredRoles.some(role => userRoles.includes(role));
  }

  getRequiredRoles(action, resource) {
    const permissionMap = {
      'schema.edit': ['admin', 'editor'],
      'schema.publish': ['admin'],
      'material.install': ['admin', 'developer']
    };

    const key = `${resource}.${action}`;
    return permissionMap[key] || [];
  }
}
```

---

## 九、实战案例

### 9.1 案例一:表单生成器

```javascript
// 1. 定义表单Schema
const formSchema = {
  componentTree: {
    componentName: 'Form',
    props: {
      layout: 'horizontal',
      onSubmit: { type: 'submitForm', payload: { api: '/api/users' } }
    },
    children: [
      {
        componentName: 'FormItem',
        props: { label: '用户名', name: 'username', rules: [{ required: true }] },
        children: [
          { componentName: 'Input', props: { placeholder: '请输入用户名' } }
        ]
      },
      {
        componentName: 'FormItem',
        props: { label: '邮箱', name: 'email' },
        children: [
          { componentName: 'Input', props: { type: 'email' } }
        ]
      },
      {
        componentName: 'FormItem',
        children: [
          { componentName: 'Button', props: { type: 'primary', htmlType: 'submit', children: '提交' } }
        ]
      }
    ]
  }
};

// 2. 渲染
<Renderer schema={formSchema} />
```

### 9.2 案例二:数据大屏

```javascript
const dashboardSchema = {
  componentTree: {
    componentName: 'DashboardLayout',
    props: { columns: 24, rows: 12 },
    children: [
      {
        componentName: 'ChartCard',
        props: {
          gridArea: { x: 0, y: 0, w: 12, h: 6 },
          title: '销售趋势'
        },
        children: [
          {
            componentName: 'LineChart',
            props: {
              dataSource: '${dataSources.sales.data}',
              xField: 'date',
              yField: 'amount'
            }
          }
        ]
      },
      {
        componentName: 'StatCard',
        props: {
          gridArea: { x: 12, y: 0, w: 6, h: 3 },
          title: '今日订单',
          value: '${dataSources.stats.data.orders}'
        }
      }
    ]
  },
  dataSources: [
    {
      id: 'sales',
      type: 'http',
      config: { url: '/api/sales/trend', method: 'GET' }
    },
    {
      id: 'stats',
      type: 'http',
      config: { url: '/api/stats/today', method: 'GET' }
    }
  ]
};
```

### 9.3 案例三:移动端页面

```javascript
const mobileSchema = {
  platform: 'mobile',
  componentTree: {
    componentName: 'MobilePage',
    props: { title: '商品详情' },
    children: [
      {
        componentName: 'ImageSwiper',
        props: {
          images: '${state.product.images}',
          autoplay: true
        }
      },
      {
        componentName: 'ProductInfo',
        props: {
          title: '${state.product.title}',
          price: '${state.product.price}'
        }
      },
      {
        componentName: 'BottomBar',
        children: [
          {
            componentName: 'Button',
            props: {
              type: 'primary',
              children: '立即购买',
              onClick: { type: 'navigate', payload: { url: '/order' } }
            }
          }
        ]
      }
    ]
  },
  state: {
    product: null
  },
  lifeCycles: {
    onMount: [
      { type: 'fetchDataSource', payload: { id: 'product' } }
    ]
  }
};
```

---

## 十、总结与展望

### 10.1 三阶段对比

| 特性 | 阶段一:最简实现 | 阶段二:物料独立 | 阶段三:企业级 |
|------|----------------|----------------|--------------|
| 物料管理 | 内置 | NPM包 | Monorepo + 物料市场 |
| 构建工具 | 无 | 简单脚本 | 统一CLI工具 |
| 版本管理 | 无 | 基础 | 完善的版本系统 |
| 团队规模 | <5人 | 5-20人 | >50人 |
| 扩展性 | 低 | 中 | 高 |
| 学习成本 | 低 | 中 | 高 |

### 10.2 核心要点回顾

1. **Schema协议是核心** - 它决定了平台的能力边界
2. **物料体系是生态** - 丰富的物料才能支撑复杂应用
3. **渲染引擎是性能关键** - 直接影响用户体验
4. **工程化是规模化基础** - 没有好的工具链,难以支撑大团队

### 10.3 未来展望

- **AI辅助设计** - 通过AI自动生成Schema
- **多端融合** - 一份Schema,多端运行
- **云端协同** - 实时多人协作编辑
- **智能优化** - 自动性能优化和代码生成

---

## 附录

### A. 常见问题

**Q: 低代码平台适合哪些场景?**
A: 中后台管理系统、数据大屏、移动端H5页面、简单官网等配置类页面

**Q: 低代码能完全替代手写代码吗?**
A: 不能。低代码适合标准化场景,复杂业务逻辑仍需手写代码

**Q: 如何保证物料质量?**
A: 通过物料审核机制、单元测试要求、文档规范等方式

**Q: Schema如何做版本兼容?**
A: 通过Schema迁移工具,自动升级旧版本Schema

### B. 参考资源

- [阿里低代码引擎](https://lowcode-engine.com/)
- [百度amis](https://aisuda.bce.baidu.com/amis/)
- [腾讯tmagic-editor](https://tmagic-editor.com/)
- [飞书多维表格](https://www.feishu.cn/product/base)

### C. 技术栈推荐

| 类别 | 推荐方案 |
|------|---------|
| UI框架 | React 18+ |
| 状态管理 | Zustand / Jotai |
| 拖拽 | dnd-kit |
| 构建工具 | Vite |
| Monorepo | pnpm + Turborepo |
| 表达式解析 | @babel/parser |
| 样式方案 | TailwindCSS |

---

**文档版本**: v2.0
**更新时间**: 2025-12-20
**维护者**: 低代码平台团队
