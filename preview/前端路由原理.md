# 前端路由管理方案全解析

## 前言

前端路由是单页应用（SPA）的核心技术之一，它使得我们能够在不刷新页面的情况下实现页面切换。本文将深入剖析前端路由的实现原理，以及 React Router 和 Vue Router 的设计思想和使用方法。

## 一、前端路由的演进历程

### 1.1 传统多页应用（MPA）

在 SPA 出现之前，Web 应用采用传统的多页面模式：

```
用户点击链接 → 浏览器发起请求 → 服务器返回新 HTML → 页面完全刷新
```

**缺点：**
- 页面完全刷新，用户体验差
- 重复加载资源（CSS、JS）
- 无法保持应用状态
- 白屏时间长

### 1.2 前端路由的诞生

为了解决传统多页应用的问题，前端路由应运而生：

```
用户点击链接 → URL 变化 → JavaScript 监听变化 → 动态渲染组件
```

**优点：**
- 无需刷新页面
- 用户体验流畅
- 可以保持应用状态
- 资源按需加载

### 1.3 路由模式演进

```
Hash 模式 (#/path)
    ↓
History 模式 (/path)  ← 主流
    ↓
Memory 模式 (无 URL 变化)  ← SSR、React Native
```

## 二、前端路由实现原理

### 2.1 Hash 路由原理

#### 核心机制

Hash 路由利用 URL 中的 hash（#）部分来模拟路由：

```javascript
// URL: http://example.com/#/user/123
console.log(window.location.hash) // #/user/123
```

**关键特性：**
1. Hash 变化不会触发页面刷新
2. Hash 变化会触发 `hashchange` 事件
3. Hash 不会被发送到服务器

#### 手写简易 Hash 路由

```javascript
class HashRouter {
  constructor() {
    // 路由表：路径 → 回调函数
    this.routes = {}
    // 当前路径
    this.currentPath = '/'

    // 监听 hash 变化
    window.addEventListener('hashchange', () => {
      this.currentPath = this.getHash()
      this.render()
    })

    // 页面加载时执行一次
    window.addEventListener('load', () => {
      this.currentPath = this.getHash()
      this.render()
    })
  }

  // 获取当前 hash
  getHash() {
    return window.location.hash.slice(1) || '/'
  }

  // 注册路由
  route(path, callback) {
    this.routes[path] = callback
  }

  // 渲染对应组件
  render() {
    const callback = this.routes[this.currentPath]
    if (callback) {
      callback()
    }
  }

  // 编程式导航
  push(path) {
    window.location.hash = path
  }
}

// 使用示例
const router = new HashRouter()

router.route('/', () => {
  document.getElementById('app').innerHTML = '<h1>Home Page</h1>'
})

router.route('/about', () => {
  document.getElementById('app').innerHTML = '<h1>About Page</h1>'
})

router.route('/user/:id', () => {
  const id = router.currentPath.split('/')[2]
  document.getElementById('app').innerHTML = `<h1>User ${id}</h1>`
})

// 导航
router.push('/about')
```

#### Hash 路由的优缺点

**优点：**
- 兼容性好（IE8+）
- 无需服务器配置
- 实现简单

**缺点：**
- URL 不美观（带 #）
- 不利于 SEO
- 服务端无法获取 hash 信息

---

### 2.2 History 路由原理

#### 核心机制

History 路由基于 HTML5 History API：

```javascript
// 改变 URL 但不刷新页面
history.pushState(state, title, url)
history.replaceState(state, title, url)

// 前进后退
history.back()
history.forward()
history.go(-2)

// 监听浏览器前进后退
window.addEventListener('popstate', (event) => {
  console.log('URL 变化:', location.pathname)
  console.log('状态数据:', event.state)
})
```

**关键 API：**
1. `pushState()`：添加历史记录，URL 变化
2. `replaceState()`：替换当前历史记录
3. `popstate` 事件：浏览器前进/后退时触发

**注意：** `pushState` 和 `replaceState` 不会触发 `popstate` 事件！

#### 手写简易 History 路由

```javascript
class HistoryRouter {
  constructor() {
    this.routes = {}
    this.currentPath = '/'

    // 监听浏览器前进后退
    window.addEventListener('popstate', (event) => {
      this.currentPath = window.location.pathname
      this.render(event.state)
    })

    // 页面加载时执行
    window.addEventListener('load', () => {
      this.currentPath = window.location.pathname
      this.render()
    })

    // 劫持 a 标签点击事件
    document.addEventListener('click', (e) => {
      if (e.target.tagName === 'A') {
        e.preventDefault()
        const href = e.target.getAttribute('href')
        this.push(href)
      }
    })
  }

  // 注册路由
  route(path, callback) {
    this.routes[path] = callback
  }

  // 渲染对应组件
  render(state) {
    const callback = this.routes[this.currentPath]
    if (callback) {
      callback(state)
    }
  }

  // 编程式导航
  push(path, state = {}) {
    history.pushState(state, '', path)
    this.currentPath = path
    this.render(state)
  }

  // 替换当前路由
  replace(path, state = {}) {
    history.replaceState(state, '', path)
    this.currentPath = path
    this.render(state)
  }

  // 前进/后退
  go(n) {
    history.go(n)
  }
}

// 使用示例
const router = new HistoryRouter()

router.route('/', () => {
  document.getElementById('app').innerHTML = '<h1>Home Page</h1>'
})

router.route('/about', () => {
  document.getElementById('app').innerHTML = '<h1>About Page</h1>'
})

// 导航
router.push('/about', { from: 'home' })
```

#### History 路由的优缺点

**优点：**
- URL 美观，无 #
- 利于 SEO
- 可以携带状态数据

**缺点：**
- 需要服务器配置（处理 404）
- 兼容性：IE10+

#### 服务器配置示例

```nginx
# Nginx 配置
location / {
  try_files $uri $uri/ /index.html;
}
```

```javascript
// Node.js Express
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'dist/index.html'))
})
```

---

### 2.3 Memory 路由原理

Memory 路由将历史记录保存在内存中，不改变 URL：

```javascript
class MemoryRouter {
  constructor(initialPath = '/') {
    this.routes = {}
    this.history = [initialPath]
    this.currentIndex = 0
  }

  get currentPath() {
    return this.history[this.currentIndex]
  }

  push(path) {
    // 删除当前位置之后的历史
    this.history = this.history.slice(0, this.currentIndex + 1)
    this.history.push(path)
    this.currentIndex++
    this.render()
  }

  go(n) {
    const newIndex = this.currentIndex + n
    if (newIndex >= 0 && newIndex < this.history.length) {
      this.currentIndex = newIndex
      this.render()
    }
  }

  route(path, callback) {
    this.routes[path] = callback
  }

  render() {
    const callback = this.routes[this.currentPath]
    if (callback) callback()
  }
}
```

**适用场景：**
- React Native
- 测试环境
- 服务端渲染（SSR）

---

## 三、React Router 详解

### 3.1 核心概念

React Router 基于 React 组件化思想，将路由也视为组件。

**核心组件：**
1. `BrowserRouter` / `HashRouter`：路由容器
2. `Routes` / `Route`：路由配置
3. `Link` / `NavLink`：声明式导航
4. `useNavigate`：编程式导航
5. `useParams` / `useSearchParams`：获取路由参数

### 3.2 基础使用

```jsx
import {
  BrowserRouter,
  Routes,
  Route,
  Link,
  useParams,
  useNavigate,
  useLocation
} from 'react-router-dom'

// 1. 基础路由配置
function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
        <Link to="/users">Users</Link>
      </nav>

      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/users" element={<Users />} />
        <Route path="/users/:id" element={<UserDetail />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </BrowserRouter>
  )
}

// 2. 获取路由参数
function UserDetail() {
  const { id } = useParams() // 获取 :id
  return <h1>User {id}</h1>
}

// 3. 编程式导航
function Home() {
  const navigate = useNavigate()

  const goToAbout = () => {
    navigate('/about')
  }

  const goToUser = (id) => {
    navigate(`/users/${id}`, {
      state: { from: 'home' } // 携带状态
    })
  }

  return (
    <div>
      <h1>Home</h1>
      <button onClick={goToAbout}>Go to About</button>
      <button onClick={() => goToUser(123)}>Go to User 123</button>
    </div>
  )
}

// 4. 获取 location 信息
function UserDetail() {
  const location = useLocation()
  const { id } = useParams()

  console.log(location.pathname)  // /users/123
  console.log(location.state)     // { from: 'home' }

  return <h1>User {id}</h1>
}
```

### 3.3 嵌套路由

```jsx
// 父路由组件
function Users() {
  return (
    <div>
      <h1>Users</h1>
      <nav>
        <Link to="active">Active Users</Link>
        <Link to="inactive">Inactive Users</Link>
      </nav>

      {/* Outlet 用于渲染子路由 */}
      <Outlet />
    </div>
  )
}

// 路由配置
<Routes>
  <Route path="/users" element={<Users />}>
    <Route path="active" element={<ActiveUsers />} />
    <Route path="inactive" element={<InactiveUsers />} />
  </Route>
</Routes>
```

### 3.4 路由守卫

```jsx
// 认证路由守卫
function RequireAuth({ children }) {
  const { user } = useAuth()
  const location = useLocation()

  if (!user) {
    // 重定向到登录页，并记住当前位置
    return <Navigate to="/login" state={{ from: location }} replace />
  }

  return children
}

// 使用
<Routes>
  <Route path="/login" element={<Login />} />
  <Route
    path="/dashboard"
    element={
      <RequireAuth>
        <Dashboard />
      </RequireAuth>
    }
  />
</Routes>
```

### 3.5 懒加载（代码拆分）

```jsx
import { lazy, Suspense } from 'react'

// 1. 使用 React.lazy 动态导入
const Home = lazy(() => import('./pages/Home'))
const About = lazy(() => import('./pages/About'))
const Users = lazy(() => import('./pages/Users'))

// 2. 包裹在 Suspense 中
function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/users/*" element={<Users />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  )
}
```

### 3.6 React Router 6 核心原理

#### 原理图示

```
BrowserRouter
    ↓ (提供 Router Context)
Routes
    ↓ (匹配路由)
Route
    ↓ (渲染对应组件)
Component
    ↓ (使用 Hooks 获取路由信息)
useParams / useNavigate / useLocation
```

#### 简化实现

```jsx
// 1. Router Context
const RouterContext = React.createContext()

function BrowserRouter({ children }) {
  const [location, setLocation] = useState(window.location.pathname)

  useEffect(() => {
    // 监听 popstate
    const handlePopState = () => {
      setLocation(window.location.pathname)
    }

    window.addEventListener('popstate', handlePopState)
    return () => window.removeEventListener('popstate', handlePopState)
  }, [])

  const navigate = (to) => {
    window.history.pushState({}, '', to)
    setLocation(to)
  }

  return (
    <RouterContext.Provider value={{ location, navigate }}>
      {children}
    </RouterContext.Provider>
  )
}

// 2. Routes 组件（匹配路由）
function Routes({ children }) {
  const { location } = useContext(RouterContext)

  // 遍历子 Route，找到匹配的路由
  let element = null
  React.Children.forEach(children, (child) => {
    if (matchPath(child.props.path, location)) {
      element = child.props.element
    }
  })

  return element
}

// 3. Route 组件（占位符，实际逻辑在 Routes 中）
function Route({ path, element }) {
  return null
}

// 4. Link 组件
function Link({ to, children }) {
  const { navigate } = useContext(RouterContext)

  const handleClick = (e) => {
    e.preventDefault()
    navigate(to)
  }

  return <a href={to} onClick={handleClick}>{children}</a>
}

// 5. useNavigate Hook
function useNavigate() {
  const { navigate } = useContext(RouterContext)
  return navigate
}

// 6. 路径匹配函数
function matchPath(pattern, pathname) {
  // 简化版，实际实现更复杂（支持参数、通配符等）
  const regex = new RegExp(
    '^' + pattern.replace(/:\w+/g, '([^/]+)') + '$'
  )
  return regex.test(pathname)
}
```

---

## 四、Vue Router 详解

### 4.1 核心概念

Vue Router 是 Vue 官方路由管理器，与 Vue 深度集成。

**核心概念：**
1. `createRouter`：创建路由实例
2. `RouterView`：路由出口
3. `RouterLink`：声明式导航
4. `useRouter` / `useRoute`：Composition API
5. 导航守卫：全局/路由/组件级别

### 4.2 基础使用（Vue 3）

```vue
<!-- main.js -->
<script>
import { createApp } from 'vue'
import { createRouter, createWebHistory } from 'vue-router'
import App from './App.vue'

// 1. 定义路由配置
const routes = [
  {
    path: '/',
    name: 'Home',
    component: () => import('./views/Home.vue')
  },
  {
    path: '/about',
    name: 'About',
    component: () => import('./views/About.vue')
  },
  {
    path: '/users/:id',
    name: 'UserDetail',
    component: () => import('./views/UserDetail.vue'),
    props: true // 将 params 作为 props 传递
  },
  {
    path: '/:pathMatch(.*)*',
    name: 'NotFound',
    component: () => import('./views/NotFound.vue')
  }
]

// 2. 创建路由实例
const router = createRouter({
  history: createWebHistory(), // 或 createWebHashHistory()
  routes
})

// 3. 安装插件
const app = createApp(App)
app.use(router)
app.mount('#app')
</script>

<!-- App.vue -->
<template>
  <div id="app">
    <nav>
      <!-- 声明式导航 -->
      <RouterLink to="/">Home</RouterLink>
      <RouterLink to="/about">About</RouterLink>
      <RouterLink :to="{ name: 'UserDetail', params: { id: 123 } }">
        User 123
      </RouterLink>
    </nav>

    <!-- 路由出口 -->
    <RouterView />
  </div>
</template>

<!-- UserDetail.vue -->
<script setup>
import { useRoute, useRouter } from 'vue-router'

const route = useRoute()
const router = useRouter()

// 获取路由参数
console.log(route.params.id) // 123
console.log(route.query)     // URL 查询参数
console.log(route.path)      // /users/123

// 编程式导航
const goToAbout = () => {
  router.push('/about')
}

const goToUser = (id) => {
  router.push({
    name: 'UserDetail',
    params: { id },
    query: { tab: 'profile' }
  })
}

const goBack = () => {
  router.back()
}
</script>

<template>
  <div>
    <h1>User {{ route.params.id }}</h1>
    <button @click="goToAbout">Go to About</button>
    <button @click="goBack">Go Back</button>
  </div>
</template>
```

### 4.3 嵌套路由

```javascript
const routes = [
  {
    path: '/users',
    component: Users,
    children: [
      {
        // 匹配 /users
        path: '',
        component: UserList
      },
      {
        // 匹配 /users/:id
        path: ':id',
        component: UserDetail
      },
      {
        // 匹配 /users/:id/posts
        path: ':id/posts',
        component: UserPosts
      }
    ]
  }
]
```

```vue
<!-- Users.vue -->
<template>
  <div>
    <h1>Users</h1>
    <RouterView /> <!-- 嵌套路由出口 -->
  </div>
</template>
```

### 4.4 命名视图

```javascript
const routes = [
  {
    path: '/',
    components: {
      default: Home,
      sidebar: Sidebar,
      footer: Footer
    }
  }
]
```

```vue
<template>
  <RouterView /> <!-- 默认视图 -->
  <RouterView name="sidebar" />
  <RouterView name="footer" />
</template>
```

### 4.5 导航守卫

#### 全局守卫

```javascript
// 全局前置守卫
router.beforeEach((to, from, next) => {
  console.log('导航到:', to.path)
  console.log('来自:', from.path)

  // 认证检查
  if (to.meta.requiresAuth && !isLoggedIn()) {
    next('/login') // 重定向
  } else {
    next() // 放行
  }
})

// 全局解析守卫
router.beforeResolve((to, from, next) => {
  // 在所有组件内守卫和异步路由组件被解析之后调用
  next()
})

// 全局后置钩子（无 next 参数）
router.afterEach((to, from) => {
  // 修改页面标题
  document.title = to.meta.title || 'My App'

  // 发送分析数据
  analytics.track(to.path)
})
```

#### 路由独享守卫

```javascript
const routes = [
  {
    path: '/admin',
    component: Admin,
    beforeEnter: (to, from, next) => {
      if (isAdmin()) {
        next()
      } else {
        next('/forbidden')
      }
    }
  }
]
```

#### 组件内守卫

```vue
<script>
export default {
  // 进入组件前
  beforeRouteEnter(to, from, next) {
    // 此时组件实例还未创建，无法访问 this
    next(vm => {
      // 通过回调访问组件实例
      vm.loadData()
    })
  },

  // 路由更新时（参数变化，如 /users/1 → /users/2）
  beforeRouteUpdate(to, from, next) {
    // 可以访问 this
    this.loadData(to.params.id)
    next()
  },

  // 离开组件前
  beforeRouteLeave(to, from, next) {
    // 询问用户是否确认离开
    if (this.hasUnsavedChanges) {
      const confirmed = window.confirm('有未保存的更改，确定离开吗？')
      next(confirmed)
    } else {
      next()
    }
  }
}
</script>

<!-- Composition API 写法 -->
<script setup>
import { onBeforeRouteUpdate, onBeforeRouteLeave } from 'vue-router'

onBeforeRouteUpdate((to, from) => {
  // 路由更新
  loadData(to.params.id)
})

onBeforeRouteLeave((to, from) => {
  // 离开前确认
  if (hasUnsavedChanges.value) {
    return window.confirm('有未保存的更改，确定离开吗？')
  }
})
</script>
```

### 4.6 路由元信息

```javascript
const routes = [
  {
    path: '/dashboard',
    component: Dashboard,
    meta: {
      requiresAuth: true,
      title: 'Dashboard',
      roles: ['admin', 'user']
    }
  }
]

// 在守卫中使用
router.beforeEach((to, from, next) => {
  if (to.meta.requiresAuth) {
    // 检查认证
  }

  if (to.meta.roles) {
    // 检查角色权限
  }

  next()
})
```

### 4.7 Vue Router 核心原理

#### 原理图示

```
createRouter
    ↓
路由表（routes）
    ↓
路由匹配器（matcher）
    ↓
监听 URL 变化（history.listen）
    ↓
匹配路由 → 执行守卫 → 更新视图
    ↓
RouterView 渲染对应组件
```

#### 简化实现

```javascript
// 1. 创建路由实例
function createRouter(options) {
  const { routes, history } = options

  // 路由匹配器
  const matcher = createMatcher(routes)

  // 当前路由
  let currentRoute = reactive({
    path: '/',
    params: {},
    query: {}
  })

  // 监听 URL 变化
  history.listen((location) => {
    const matched = matcher.match(location)
    currentRoute.path = matched.path
    currentRoute.params = matched.params
  })

  // 导航方法
  const push = (to) => {
    history.push(to)
  }

  const replace = (to) => {
    history.replace(to)
  }

  return {
    currentRoute,
    push,
    replace,
    install(app) {
      // 全局注册组件
      app.component('RouterView', RouterView)
      app.component('RouterLink', RouterLink)

      // 提供路由实例
      app.provide('router', this)
      app.provide('route', currentRoute)
    }
  }
}

// 2. RouterView 组件
const RouterView = {
  setup() {
    const route = inject('route')

    return () => {
      const Component = route.matched?.component
      return Component ? h(Component) : null
    }
  }
}

// 3. RouterLink 组件
const RouterLink = {
  props: {
    to: [String, Object]
  },
  setup(props) {
    const router = inject('router')

    const handleClick = (e) => {
      e.preventDefault()
      router.push(props.to)
    }

    return () => h('a', { onClick: handleClick }, slots.default?.())
  }
}

// 4. useRouter / useRoute Hooks
function useRouter() {
  return inject('router')
}

function useRoute() {
  return inject('route')
}
```

---

## 五、React Router vs Vue Router 对比

### 5.1 设计理念差异

| 维度 | React Router | Vue Router |
|------|-------------|-----------|
| **设计思想** | 组件化路由（Routes as Components） | 配置化路由（Routes as Config） |
| **声明方式** | JSX 声明式 | JavaScript 配置对象 |
| **嵌套路由** | 通过组件嵌套 | 通过 children 配置 |
| **动态性** | 可动态生成路由组件 | 通过配置数组定义 |
| **类型推导** | 弱（依赖泛型） | 强（路由名称、参数） |

### 5.2 核心 API 对比

#### 路由配置

```jsx
// React Router：JSX 声明式
<Routes>
  <Route path="/" element={<Home />} />
  <Route path="/users/:id" element={<User />} />
</Routes>
```

```javascript
// Vue Router：配置对象
const routes = [
  { path: '/', component: Home },
  { path: '/users/:id', component: User }
]
```

#### 导航

```jsx
// React Router
const navigate = useNavigate()
navigate('/about')
navigate('/users/123', { state: { from: 'home' } })

// 声明式
<Link to="/about">About</Link>
```

```javascript
// Vue Router
const router = useRouter()
router.push('/about')
router.push({ name: 'User', params: { id: 123 } })

// 声明式
<RouterLink to="/about">About</RouterLink>
```

#### 获取路由信息

```jsx
// React Router
const params = useParams()
const location = useLocation()
const [searchParams] = useSearchParams()

console.log(params.id)
console.log(location.pathname)
console.log(searchParams.get('tab'))
```

```javascript
// Vue Router
const route = useRoute()

console.log(route.params.id)
console.log(route.path)
console.log(route.query.tab)
```

### 5.3 高级特性对比

| 特性 | React Router | Vue Router |
|------|-------------|-----------|
| **路由守卫** | 需要自定义组件包裹 | 内置丰富的守卫系统 |
| **懒加载** | React.lazy + Suspense | 原生支持 import() |
| **命名路由** | ❌ | ✅ |
| **命名视图** | ❌ | ✅ |
| **过渡动画** | 需要自己实现 | 配合 Transition 组件 |
| **滚动行为** | 手动处理 | scrollBehavior 配置 |
| **路由元信息** | 通过 route 对象传递 | meta 字段 |

### 5.4 实战对比

#### 权限路由

```jsx
// React Router
function PrivateRoute({ children }) {
  const { user } = useAuth()
  return user ? children : <Navigate to="/login" />
}

<Route
  path="/dashboard"
  element={
    <PrivateRoute>
      <Dashboard />
    </PrivateRoute>
  }
/>
```

```javascript
// Vue Router
router.beforeEach((to, from, next) => {
  if (to.meta.requiresAuth && !isLoggedIn()) {
    next('/login')
  } else {
    next()
  }
})

// 路由配置
{
  path: '/dashboard',
  component: Dashboard,
  meta: { requiresAuth: true }
}
```

#### 嵌套路由

```jsx
// React Router
function Users() {
  return (
    <div>
      <h1>Users</h1>
      <Outlet /> {/* 子路由出口 */}
    </div>
  )
}

<Route path="/users" element={<Users />}>
  <Route path=":id" element={<UserDetail />} />
</Route>
```

```javascript
// Vue Router
{
  path: '/users',
  component: Users,
  children: [
    {
      path: ':id',
      component: UserDetail
    }
  ]
}

// Users.vue
<template>
  <div>
    <h1>Users</h1>
    <RouterView /> <!-- 子路由出口 -->
  </div>
</template>
```

---

## 六、路由最佳实践

### 6.1 路由设计原则

1. **语义化路径**
   ```javascript
   // ✅ 清晰语义
   /users/:id
   /products/:id/reviews
   /settings/profile

   // ❌ 难以理解
   /u/:id
   /p/:id/r
   /s/p
   ```

2. **RESTful 风格**
   ```javascript
   GET    /api/users      → 获取用户列表
   GET    /api/users/:id  → 获取单个用户
   POST   /api/users      → 创建用户
   PUT    /api/users/:id  → 更新用户
   DELETE /api/users/:id  → 删除用户
   ```

3. **扁平化优于深度嵌套**
   ```javascript
   // ✅ 扁平
   /products
   /products/:id
   /products/:id/reviews

   // ❌ 过度嵌套
   /categories/:catId/products/:prodId/reviews/:reviewId
   ```

### 6.2 性能优化

#### 路由懒加载

```javascript
// React Router
const Home = lazy(() => import('./pages/Home'))
const About = lazy(() => import('./pages/About'))

<Suspense fallback={<Loading />}>
  <Routes>
    <Route path="/" element={<Home />} />
    <Route path="/about" element={<About />} />
  </Routes>
</Suspense>
```

```javascript
// Vue Router
const routes = [
  {
    path: '/',
    component: () => import('./views/Home.vue')
  },
  {
    path: '/about',
    // 魔法注释：指定 chunk 名称
    component: () => import(/* webpackChunkName: "about" */ './views/About.vue')
  }
]
```

#### 预加载关键路由

```javascript
// React Router
import { Link } from 'react-router-dom'

function Nav() {
  // 鼠标悬停时预加载
  const handleMouseEnter = () => {
    import('./pages/About') // 预加载
  }

  return <Link to="/about" onMouseEnter={handleMouseEnter}>About</Link>
}
```

```javascript
// Vue Router
router.beforeEach((to, from, next) => {
  // 预加载下一页可能访问的路由
  if (to.path === '/home') {
    import('./views/About.vue')
  }
  next()
})
```

### 6.3 状态管理整合

#### React Router + Zustand

```typescript
import { create } from 'zustand'
import { useNavigate } from 'react-router-dom'

interface AuthStore {
  user: User | null
  login: (credentials: Credentials) => Promise<void>
  logout: () => void
}

export const useAuthStore = create<AuthStore>()((set) => ({
  user: null,

  login: async (credentials) => {
    const user = await api.login(credentials)
    set({ user })
    // 登录后跳转
    const navigate = useNavigate()
    navigate('/dashboard')
  },

  logout: () => {
    set({ user: null })
  }
}))
```

#### Vue Router + Pinia

```typescript
import { defineStore } from 'pinia'
import { useRouter } from 'vue-router'

export const useAuthStore = defineStore('auth', {
  state: () => ({
    user: null as User | null
  }),

  actions: {
    async login(credentials: Credentials) {
      this.user = await api.login(credentials)

      // 登录后跳转
      const router = useRouter()
      router.push('/dashboard')
    },

    logout() {
      this.user = null
      const router = useRouter()
      router.push('/login')
    }
  }
})
```

### 6.4 SEO 优化

#### 动态修改页面标题

```javascript
// React Router
function PageTitle({ title }) {
  useEffect(() => {
    document.title = title
  }, [title])
  return null
}

function About() {
  return (
    <>
      <PageTitle title="About - My App" />
      <div>About Page</div>
    </>
  )
}
```

```javascript
// Vue Router
router.afterEach((to) => {
  document.title = to.meta.title || 'Default Title'
})

// 路由配置
{
  path: '/about',
  component: About,
  meta: { title: 'About - My App' }
}
```

#### SSR 服务端渲染

```javascript
// React Router (使用 React Router v6 + Express)
import { StaticRouter } from 'react-router-dom/server'

app.get('*', (req, res) => {
  const html = renderToString(
    <StaticRouter location={req.url}>
      <App />
    </StaticRouter>
  )
  res.send(html)
})
```

```javascript
// Vue Router (使用 @vue/server-renderer)
import { renderToString } from '@vue/server-renderer'
import { createMemoryHistory } from 'vue-router'

app.get('*', async (req, res) => {
  const router = createRouter({
    history: createMemoryHistory(),
    routes
  })

  router.push(req.url)
  await router.isReady()

  const html = await renderToString(createApp(App).use(router))
  res.send(html)
})
```

---

## 七、常见问题与解决方案

### 7.1 路由参数变化不刷新

**问题：** 同一组件，路由参数变化（如 /users/1 → /users/2）时组件不重新加载。

**React Router 解决方案：**

```jsx
function UserDetail() {
  const { id } = useParams()

  useEffect(() => {
    loadUser(id) // 参数变化时重新加载
  }, [id]) // 依赖 id

  return <div>User {id}</div>
}
```

**Vue Router 解决方案：**

```vue
<script setup>
import { watch } from 'vue'
import { useRoute } from 'vue-router'

const route = useRoute()

watch(() => route.params.id, (newId) => {
  loadUser(newId) // 参数变化时重新加载
})
</script>
```

或使用守卫：

```vue
<script>
export default {
  beforeRouteUpdate(to, from, next) {
    this.loadUser(to.params.id)
    next()
  }
}
</script>
```

### 7.2 路由跳转前确认

```jsx
// React Router
import { useBlocker } from 'react-router-dom'

function Form() {
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false)

  useBlocker(() => {
    if (hasUnsavedChanges) {
      return !window.confirm('有未保存的更改，确定离开吗？')
    }
    return false
  })
}
```

```vue
<!-- Vue Router -->
<script setup>
import { ref } from 'vue'
import { onBeforeRouteLeave } from 'vue-router'

const hasUnsavedChanges = ref(false)

onBeforeRouteLeave(() => {
  if (hasUnsavedChanges.value) {
    return window.confirm('有未保存的更改，确定离开吗？')
  }
})
</script>
```

### 7.3 路由滚动行为

```javascript
// React Router
import { useEffect } from 'react'
import { useLocation } from 'react-router-dom'

function ScrollToTop() {
  const { pathname } = useLocation()

  useEffect(() => {
    window.scrollTo(0, 0)
  }, [pathname])

  return null
}

// 在 App 中使用
<BrowserRouter>
  <ScrollToTop />
  <Routes>...</Routes>
</BrowserRouter>
```

```javascript
// Vue Router
const router = createRouter({
  history: createWebHistory(),
  routes,
  scrollBehavior(to, from, savedPosition) {
    // 返回保存的位置（浏览器前进/后退）
    if (savedPosition) {
      return savedPosition
    }

    // 锚点跳转
    if (to.hash) {
      return { el: to.hash }
    }

    // 滚动到顶部
    return { top: 0 }
  }
})
```

---

## 八、总结

### 8.1 核心要点

1. **前端路由原理**
   - Hash 模式：监听 `hashchange` 事件
   - History 模式：监听 `popstate` 事件 + `pushState/replaceState`
   - Memory 模式：内存中维护历史栈

2. **React Router 特点**
   - 组件化路由声明
   - 灵活的嵌套路由
   - 需要手动实现守卫逻辑

3. **Vue Router 特点**
   - 配置化路由定义
   - 丰富的守卫系统
   - 与 Vue 生态深度集成

4. **选择建议**
   - React 项目 → React Router v6
   - Vue 2 项目 → Vue Router v3
   - Vue 3 项目 → Vue Router v4

### 8.2 学习路线

```
阶段 1：理解前端路由原理
  ├─ 手写 Hash 路由
  └─ 手写 History 路由

阶段 2：掌握基础使用
  ├─ 路由配置
  ├─ 声明式导航
  └─ 编程式导航

阶段 3：进阶特性
  ├─ 嵌套路由
  ├─ 路由守卫
  ├─ 懒加载
  └─ 动态路由

阶段 4：实战应用
  ├─ 权限路由
  ├─ 性能优化
  ├─ SEO 优化
  └─ 状态管理整合
```

---

希望这篇文章能帮助你深入理解前端路由的实现原理和最佳实践！
