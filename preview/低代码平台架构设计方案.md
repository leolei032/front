# 低代码平台架构设计方案

## 一、整体架构概览

### 1.1 核心理念

低代码平台的本质是：**通过可视化配置生成页面 Schema，再通过渲染引擎将 Schema 转换为可运行的应用**。

```
配置阶段（设计器）  →  Schema（JSON描述）  →  运行阶段（渲染器）  →  最终应用
```

### 1.2 三层架构

```
┌─────────────────────────────────────────────────────┐
│                   应用层（Application Layer）          │
│  - 设计器（Designer）                                  │
│  - 预览器（Previewer）                                 │
│  - 发布管理（Publisher）                               │
└─────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────┐
│                   引擎层（Engine Layer）               │
│  - Schema解析引擎                                      │
│  - 渲染引擎（Renderer）                                │
│  - 数据流引擎（State Management）                      │
│  - 事件引擎（Event System）                            │
│  - 物料引擎（Material System）                         │
└─────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────┐
│                   基础层（Foundation Layer）           │
│  - 组件物料库（Component Materials）                   │
│  - 数据源适配器（DataSource Adapters）                 │
│  - 插件系统（Plugin System）                           │
│  - 工具函数库（Utils）                                 │
└─────────────────────────────────────────────────────┘
```

---

## 二、核心模块设计

### 2.1 Schema 协议设计

Schema 是低代码平台的核心，它是页面的 JSON 描述协议。

```javascript
// Schema 结构示例
const PageSchema = {
  // 元信息
  meta: {
    id: "page_001",
    version: "1.0.0",
    name: "用户列表页",
    createTime: "2025-01-01",
  },

  // 数据源定义
  dataSources: [
    {
      id: "ds_user_list",
      type: "http",
      config: {
        url: "/api/users",
        method: "GET",
      },
    },
  ],

  // 状态定义
  state: {
    selectedUser: null,
    filterKeyword: "",
  },

  // 组件树
  componentTree: {
    componentName: "Page",
    id: "root",
    props: {
      title: "用户管理",
    },
    children: [
      {
        componentName: "Table",
        id: "table_001",
        props: {
          dataSource: "${dataSources.ds_user_list.data}",
          columns: [
            /* ... */
          ],
        },
        events: {
          onRowClick: {
            type: "setState",
            payload: { selectedUser: "${record}" },
          },
        },
      },
    ],
  },

  // 生命周期
  lifeCycles: {
    onMount: [{ type: "fetchDataSource", dataSourceId: "ds_user_list" }],
  },
};
```

**Schema 设计原则：**

- **声明式**：描述"是什么"而非"怎么做"
- **可序列化**：纯 JSON 格式，便于存储和传输
- **可扩展**：支持自定义字段和插件扩展
- **版本化**：支持 Schema 版本管理和升级

---

### 2.2 渲染引擎（Renderer Engine）

渲染引擎负责将 Schema 转换为真实的 React 组件树。

```javascript
// 渲染引擎核心实现（伪代码）
class Renderer {
  constructor(schema, materialRegistry) {
    this.schema = schema;
    this.materialRegistry = materialRegistry; // 物料注册表
    this.context = this.initContext(schema);
  }

  // 初始化上下文（数据源、状态、事件等）
  initContext(schema) {
    return {
      dataSources: this.initDataSources(schema.dataSources),
      state: schema.state || {},
      setState: (updates) => {
        /* 状态更新逻辑 */
      },
      executeAction: (action) => {
        /* 动作执行逻辑 */
      },
    };
  }

  // 递归渲染组件树
  renderComponentTree(nodeSchema, context) {
    const { componentName, id, props, children, events } = nodeSchema;

    // 1. 从物料库获取组件
    const Component = this.materialRegistry.getComponent(componentName);

    // 2. 解析props（支持表达式绑定）
    const resolvedProps = this.resolveProps(props, context);

    // 3. 绑定事件
    const eventHandlers = this.bindEvents(events, context);

    // 4. 递归渲染子节点
    const childNodes = children?.map((child) =>
      this.renderComponentTree(child, context)
    );

    // 5. 返回React元素
    return React.createElement(
      Component,
      { key: id, ...resolvedProps, ...eventHandlers },
      childNodes
    );
  }

  // 解析props中的表达式（如 ${dataSources.xxx}）
  resolveProps(props, context) {
    const resolved = {};
    for (const [key, value] of Object.entries(props)) {
      if (typeof value === "string" && value.startsWith("${")) {
        // 表达式求值
        resolved[key] = this.evaluateExpression(value, context);
      } else if (typeof value === "object") {
        resolved[key] = this.resolveProps(value, context);
      } else {
        resolved[key] = value;
      }
    }
    return resolved;
  }

  // 表达式求值引擎
  evaluateExpression(expr, context) {
    // 简化示例：实际需要安全的沙箱环境
    const code = expr.slice(2, -1); // 去掉 ${ }
    return new Function("context", `with(context) { return ${code} }`)(context);
  }

  // 渲染入口
  render() {
    return this.renderComponentTree(this.schema.componentTree, this.context);
  }
}

// 使用示例
const renderer = new Renderer(pageSchema, materialRegistry);
const App = () => renderer.render();
```

**渲染引擎关键点：**

- **动态组件加载**：根据 componentName 动态获取组件
- **表达式绑定**：支持 `${expression}` 语法绑定动态数据
- **上下文传递**：将数据源、状态、方法注入到表达式环境
- **性能优化**：缓存解析结果、虚拟滚动等

---

### 2.3 物料系统（Material System）

物料系统管理所有可用的组件、区块和模板。

```javascript
// 物料注册表
class MaterialRegistry {
  constructor() {
    this.components = new Map();
    this.blocks = new Map();
    this.templates = new Map();
  }

  // 注册组件
  registerComponent(name, component, meta) {
    this.components.set(name, {
      component,
      meta: {
        title: meta.title,
        category: meta.category,
        props: meta.props, // props定义（用于属性面板）
        thumbnail: meta.thumbnail,
        snippets: meta.snippets, // 初始Schema片段
      },
    });
  }

  // 获取组件
  getComponent(name) {
    return this.components.get(name)?.component;
  }

  // 获取物料元信息（用于设计器左侧物料面板）
  getMaterialList(category) {
    return Array.from(this.components.values())
      .filter((m) => !category || m.meta.category === category)
      .map((m) => m.meta);
  }
}

// 物料描述协议
const ButtonMaterial = {
  componentName: "Button",
  component: Button, // React组件
  meta: {
    title: "按钮",
    category: "basic",
    props: [
      {
        name: "type",
        title: "类型",
        setter: "SelectSetter",
        options: ["primary", "default", "danger"],
      },
      {
        name: "onClick",
        title: "点击事件",
        setter: "ActionSetter",
      },
    ],
    snippets: {
      componentName: "Button",
      props: { type: "primary", children: "按钮" },
    },
  },
};

// 注册物料
materialRegistry.registerComponent("Button", Button, ButtonMaterial.meta);
```

**物料系统分层：**

1. **基础组件**：Button、Input、Table 等原子组件
2. **业务组件**：UserCard、OrderList 等业务封装
3. **区块（Block）**：表单区块、列表区块等组合
4. **页面模板**：完整的页面 Schema

---

### 2.4 设计器（Designer）

设计器是配置 Schema 的可视化工具。

```javascript
// 设计器核心架构
class Designer {
  constructor() {
    this.schema = this.initSchema();
    this.selection = null; // 当前选中的节点
    this.history = new HistoryManager(); // 撤销重做
  }

  // 核心能力
  capabilities = {
    // 1. 组件操作
    addComponent(parentId, componentSchema, index) {
      const parent = this.findNode(parentId);
      parent.children.splice(index, 0, componentSchema);
      this.history.push({ type: "add", data: componentSchema });
      this.notifyChange();
    },

    deleteComponent(nodeId) {
      const node = this.findNode(nodeId);
      const parent = this.findParent(nodeId);
      parent.children = parent.children.filter((c) => c.id !== nodeId);
      this.history.push({ type: "delete", data: node });
      this.notifyChange();
    },

    updateProps(nodeId, props) {
      const node = this.findNode(nodeId);
      node.props = { ...node.props, ...props };
      this.history.push({ type: "update", nodeId, props });
      this.notifyChange();
    },

    // 2. 拖拽排序
    moveComponent(nodeId, targetParentId, index) {
      // 移动逻辑
    },

    // 3. 复制粘贴
    copyComponent(nodeId) {
      this.clipboard = this.cloneNode(nodeId);
    },

    pasteComponent(targetParentId) {
      this.addComponent(targetParentId, this.clipboard);
    },
  };

  // 通知变更（触发重新渲染）
  notifyChange() {
    this.listeners.forEach((fn) => fn(this.schema));
  }
}

// 设计器UI结构
const DesignerUI = () => {
  return (
    <div className="designer-layout">
      {/* 左侧：物料面板 */}
      <MaterialPanel materials={materialRegistry.getMaterialList()} />

      {/* 中间：画布 + 模拟器 */}
      <Canvas>
        <Simulator schema={schema} mode="design" />
      </Canvas>

      {/* 右侧：属性配置面板 */}
      <SettingPanel
        selectedNode={selection}
        onPropsChange={(props) => designer.updateProps(selection.id, props)}
      />

      {/* 顶部：工具栏 */}
      <Toolbar>
        <Button onClick={() => designer.history.undo()}>撤销</Button>
        <Button onClick={() => designer.history.redo()}>重做</Button>
        <Button onClick={() => preview()}>预览</Button>
        <Button onClick={() => publish()}>发布</Button>
      </Toolbar>
    </div>
  );
};
```

**设计器核心模块：**

- **画布（Canvas）**：可视化编辑区域，支持拖拽、选中、hover 等交互
- **物料面板**：展示可用组件，支持拖拽添加
- **属性面板**：配置选中组件的 props、events、style
- **大纲树**：展示组件树结构，支持快速定位
- **工具栏**：撤销重做、预览、保存、发布等操作

---

### 2.5 数据流引擎

管理页面的状态、数据源和数据流转。

```javascript
// 数据流管理器
class DataFlowEngine {
  constructor(schema) {
    this.state = schema.state || {};
    this.dataSources = this.initDataSources(schema.dataSources);
    this.listeners = new Set();
  }

  // 初始化数据源
  initDataSources(dsConfigs) {
    const dataSources = {};
    dsConfigs.forEach((config) => {
      dataSources[config.id] = {
        loading: false,
        data: null,
        error: null,
        fetch: () => this.fetchDataSource(config),
      };
    });
    return dataSources;
  }

  // 请求数据源
  async fetchDataSource(config) {
    const ds = this.dataSources[config.id];
    ds.loading = true;
    this.notify();

    try {
      const adapter = DataSourceAdapterFactory.create(config.type);
      const data = await adapter.fetch(config);
      ds.data = data;
      ds.error = null;
    } catch (error) {
      ds.error = error;
    } finally {
      ds.loading = false;
      this.notify();
    }
  }

  // 状态更新
  setState(updates) {
    this.state = { ...this.state, ...updates };
    this.notify();
  }

  // 获取完整上下文
  getContext() {
    return {
      state: this.state,
      dataSources: this.dataSources,
      setState: this.setState.bind(this),
    };
  }

  // 订阅变更
  subscribe(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  notify() {
    this.listeners.forEach((fn) => fn(this.getContext()));
  }
}

// 数据源适配器工厂
class DataSourceAdapterFactory {
  static adapters = {
    http: HttpAdapter,
    graphql: GraphQLAdapter,
    websocket: WebSocketAdapter,
  };

  static create(type) {
    const Adapter = this.adapters[type];
    if (!Adapter) throw new Error(`Unknown datasource type: ${type}`);
    return new Adapter();
  }
}

// HTTP适配器示例
class HttpAdapter {
  async fetch(config) {
    const response = await fetch(config.url, {
      method: config.method,
      headers: config.headers,
      body: config.body ? JSON.stringify(config.body) : undefined,
    });
    return response.json();
  }
}
```

**数据流设计要点：**

- **响应式**：数据变化自动触发 UI 更新
- **数据源抽象**：统一接口，支持 HTTP、GraphQL、WebSocket 等
- **依赖追踪**：自动识别数据依赖，按需更新
- **缓存策略**：避免重复请求

---

### 2.6 事件系统

处理用户交互和动作执行。

```javascript
// 事件引擎
class EventEngine {
  constructor(dataFlowEngine) {
    this.dataFlow = dataFlowEngine;
    this.actions = this.registerActions();
  }

  // 注册内置动作
  registerActions() {
    return {
      // 状态更新
      setState: (payload) => {
        this.dataFlow.setState(payload);
      },

      // 请求数据源
      fetchDataSource: (payload) => {
        const ds = this.dataFlow.dataSources[payload.dataSourceId];
        ds.fetch();
      },

      // 路由跳转
      navigate: (payload) => {
        window.location.href = payload.url;
      },

      // 弹窗提示
      showMessage: (payload) => {
        alert(payload.message);
      },

      // 自定义JS
      customJS: (payload) => {
        const fn = new Function("context", payload.code);
        fn(this.dataFlow.getContext());
      },
    };
  }

  // 执行动作
  executeAction(actionConfig, eventData) {
    const { type, payload } = actionConfig;
    const action = this.actions[type];

    if (!action) {
      console.error(`Unknown action type: ${type}`);
      return;
    }

    // 解析payload中的表达式
    const resolvedPayload = this.resolvePayload(payload, eventData);
    action(resolvedPayload);
  }

  // 执行动作链
  executeActionChain(actions, eventData) {
    actions.forEach((action) => this.executeAction(action, eventData));
  }

  resolvePayload(payload, eventData) {
    // 将 ${event.xxx} 替换为实际值
    // 实现略
  }
}

// 事件绑定示例
const eventConfig = {
  onClick: [
    { type: "setState", payload: { selectedId: "${event.id}" } },
    { type: "fetchDataSource", payload: { dataSourceId: "ds_detail" } },
  ],
};
```

**事件系统特点：**

- **动作抽象**：将事件处理抽象为可配置的动作链
- **内置动作**：setState、fetch、navigate 等常用动作
- **自定义扩展**：支持注册自定义动作
- **串行执行**：支持动作链按顺序执行

---

## 三、关键流程

### 3.1 页面渲染流程

```
1. 加载Schema
   ↓
2. 初始化数据流引擎（DataFlowEngine）
   - 创建state
   - 初始化dataSources
   ↓
3. 初始化事件引擎（EventEngine）
   ↓
4. 执行生命周期 onMount
   - 触发初始数据请求
   ↓
5. 渲染引擎递归渲染组件树
   - 解析props表达式
   - 绑定事件处理器
   - 创建React元素
   ↓
6. React渲染到DOM
   ↓
7. 用户交互触发事件
   ↓
8. 事件引擎执行动作链
   - 更新state
   - 触发数据请求
   ↓
9. 数据变化触发重新渲染
   ↓
10. 回到步骤5
```

### 3.2 设计器编辑流程

```
1. 用户从物料面板拖拽组件
   ↓
2. 画布监听drop事件
   ↓
3. Designer.addComponent()
   - 生成组件Schema节点
   - 插入到目标位置
   - 记录历史（撤销重做）
   ↓
4. 触发Schema变更通知
   ↓
5. 画布重新渲染（Simulator）
   ↓
6. 用户选中组件
   ↓
7. 属性面板展示该组件的props配置
   ↓
8. 用户修改属性
   ↓
9. Designer.updateProps()
   ↓
10. 回到步骤4
```

### 3.3 构建发布流程

```
1. 用户点击"发布"
   ↓
2. Schema校验
   - 检查必填字段
   - 验证数据源配置
   - 检查组件依赖
   ↓
3. 生成构建产物
   方案A：纯Schema发布
   - 上传Schema到服务器
   - 运行时通过渲染引擎解析

   方案B：编译为源码
   - Schema → AST → React代码
   - 打包为独立应用
   - 部署到CDN
   ↓
4. 版本管理
   - 记录发布版本
   - 支持回滚
   ↓
5. 生成访问链接
```

---

## 四、高级特性

### 4.1 插件系统

支持扩展平台能力。

```javascript
// 插件接口
class Plugin {
  constructor(options) {
    this.options = options;
  }

  // 插件生命周期
  install(platform) {
    // 注册物料
    platform.materialRegistry.registerComponent(/*...*/);

    // 注册setter（属性配置器）
    platform.setterRegistry.register(/*...*/);

    // 注册动作
    platform.eventEngine.registerAction(/*...*/);

    // 扩展Schema
    platform.schemaParser.addTransform(/*...*/);
  }
}

// 使用插件
const chartPlugin = new ChartPlugin({ theme: "dark" });
platform.use(chartPlugin);
```

### 4.2 多端适配

支持 PC、H5、小程序等多端。

```javascript
// 多端物料适配
const ButtonMaterial = {
  componentName: "Button",
  platforms: {
    web: WebButton,
    h5: H5Button,
    miniprogram: MiniProgramButton,
  },
  meta: {
    /* ... */
  },
};

// 渲染时根据平台选择组件
const Component = material.platforms[currentPlatform];
```

### 4.3 主题定制

支持样式主题切换。

```javascript
// Schema中的主题配置
const schema = {
  theme: {
    primaryColor: "#1890ff",
    borderRadius: "4px",
    // CSS变量
    cssVars: {
      "--primary-color": "#1890ff",
    },
  },
  componentTree: {
    /* ... */
  },
};

// 渲染时注入主题
<ThemeProvider theme={schema.theme}>
  <Renderer schema={schema} />
</ThemeProvider>;
```

### 4.4 协同编辑

多人实时协同编辑 Schema。

```javascript
// 基于OT（Operational Transformation）或CRDT
class CollaborationEngine {
  constructor(schemaId) {
    this.ws = new WebSocket(`/collab/${schemaId}`);
    this.localVersion = 0;
  }

  // 本地操作
  applyLocalOp(operation) {
    this.applyOp(operation);
    this.ws.send(
      JSON.stringify({
        type: "op",
        version: this.localVersion++,
        operation,
      })
    );
  }

  // 接收远程操作
  onRemoteOp(message) {
    const { operation, userId } = message;
    // 转换冲突操作
    const transformed = this.transform(operation);
    this.applyOp(transformed);
  }
}
```

---

## 五、技术选型建议

### 5.1 前端技术栈

| 模块       | 推荐技术               | 说明             |
| ---------- | ---------------------- | ---------------- |
| UI 框架    | React 18+              | 组件化、生态丰富 |
| 状态管理   | Zustand / Jotai        | 轻量、灵活       |
| 拖拽       | react-dnd / dnd-kit    | 成熟的拖拽方案   |
| 表达式解析 | @babel/parser          | 安全的 JS 解析   |
| 代码生成   | @babel/generator       | AST 转代码       |
| 样式方案   | CSS Modules / Tailwind | 隔离 + 原子化    |

### 5.2 后端服务

| 服务        | 功能                 | 技术选型              |
| ----------- | -------------------- | --------------------- |
| Schema 存储 | 保存页面配置         | MongoDB / PostgreSQL  |
| 物料管理    | 物料包发布、版本管理 | NPM 私有仓库          |
| 构建服务    | Schema 编译、打包    | Webpack / Vite        |
| 资源托管    | 静态资源 CDN         | OSS + CDN             |
| 协同服务    | 实时同步             | WebSocket / Socket.io |

---

## 六、性能优化策略

### 6.1 渲染性能

```javascript
// 1. 虚拟滚动（大列表场景）
<VirtualList
  data={largeDataset}
  itemHeight={50}
  renderItem={(item) => <Row data={item} />}
/>;

// 2. 组件懒加载
const LazyChart = React.lazy(() => import("./Chart"));

// 3. 表达式缓存
class ExpressionCache {
  cache = new Map();

  evaluate(expr, context) {
    const key = this.getCacheKey(expr, context);
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    const result = this.compute(expr, context);
    this.cache.set(key, result);
    return result;
  }
}

// 4. shouldComponentUpdate优化
React.memo(Component, (prev, next) => {
  // 仅当props真正变化时才重新渲染
});
```

### 6.2 编辑器性能

```javascript
// 1. 防抖更新
const debouncedUpdate = debounce((schema) => {
  saveSchema(schema);
}, 500);

// 2. 增量渲染
// 只重新渲染变化的子树，而非整个画布

// 3. Web Worker
// 将Schema解析、代码生成等CPU密集任务放到Worker
const worker = new Worker("./schema-parser.worker.js");
worker.postMessage({ schema });
```

---

## 七、安全性考虑

### 7.1 表达式沙箱

```javascript
// 使用安全的沙箱执行用户表达式
import { createSandbox } from "safe-eval-sandbox";

const sandbox = createSandbox({
  // 白名单API
  allowedGlobals: ["Math", "Date", "JSON"],
  // 禁止访问
  blockedGlobals: ["window", "document", "eval", "Function"],
});

const result = sandbox.eval(userExpression, context);
```

### 7.2 XSS 防护

```javascript
// 1. 对用户输入的文本进行转义
import DOMPurify from 'dompurify';
const safeHTML = DOMPurify.sanitize(userInput);

// 2. CSP策略
<meta http-equiv="Content-Security-Policy"
      content="script-src 'self'; object-src 'none'">
```

### 7.3 权限控制

```javascript
// Schema级别的权限
const schema = {
  permissions: {
    edit: ["admin", "editor"],
    view: ["*"],
    publish: ["admin"],
  },
};

// 运行时检查
if (!hasPermission(user, "edit", schema)) {
  throw new Error("Permission denied");
}
```

---

## 八、扩展阅读

### 8.1 业界方案参考

- **阿里低码引擎（LowCodeEngine）**：开源的企业级低代码框架
- **百度 amis**：基于 JSON 配置的前端框架
- **腾讯 tmagic-editor**：可视化页面搭建工具
- **飞书多维表格**：表格+低代码的结合

### 8.2 核心概念

- **DSL（领域特定语言）**：Schema 即 DSL
- **AST（抽象语法树）**：代码生成的中间表示
- **IoC（控制反转）**：插件系统的核心思想
- **CRDT（无冲突复制数据类型）**：协同编辑的理论基础

### 8.3 设计模式应用

- **工厂模式**：物料创建、数据源适配器
- **观察者模式**：数据流的响应式更新
- **策略模式**：多端适配、主题切换
- **命令模式**：撤销重做、动作系统
- **组合模式**：组件树结构

---

## 九、实施路线图

### Phase 1：MVP（2-3 个月）

- [ ] 核心 Schema 协议设计
- [ ] 基础渲染引擎
- [ ] 简单设计器（拖拽+属性配置）
- [ ] 5-10 个基础组件
- [ ] 预览和发布

### Phase 2：完善功能（3-4 个月）

- [ ] 数据源系统
- [ ] 事件动作系统
- [ ] 撤销重做
- [ ] 物料市场
- [ ] 多页面管理

### Phase 3：高级特性（4-6 个月）

- [ ] 插件系统
- [ ] 协同编辑
- [ ] 多端适配
- [ ] 性能优化
- [ ] 监控埋点

### Phase 4：生态建设（持续）

- [ ] 开发者文档
- [ ] 物料开发工具链
- [ ] 社区运营
- [ ] 企业级支持

---

## 十、总结

低代码平台的核心是：

1. **Schema 协议**：统一的页面描述语言
2. **渲染引擎**：将 Schema 转换为可运行应用
3. **物料系统**：组件的抽象和管理
4. **设计器**：可视化配置工具
5. **数据流**：状态和数据源管理
6. **事件系统**：交互逻辑的抽象

**关键成功要素：**

- **协议先行**：Schema 设计决定平台上限
- **分层解耦**：引擎层独立于应用层
- **扩展性**：插件化架构支持生态
- **性能优先**：大规模场景下的体验
- **开发者体验**：物料开发要简单

通过模块化、分层的架构设计，可以构建一个灵活、可扩展、高性能的低代码平台。
