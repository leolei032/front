# 跨域问题深度解析

## 1. 同源策略

### 什么是同源策略

```javascript
// 同源策略（Same-Origin Policy）是浏览器的安全机制

// 同源的定义：协议、域名、端口完全相同

// 同源示例
const url1 = 'http://www.example.com:80/page1';
const url2 = 'http://www.example.com:80/page2';
// url1和url2同源 ✓

// 不同源示例
/*
http://www.example.com:80  vs  https://www.example.com:80  ✗ 协议不同
http://www.example.com:80  vs  http://www.example.com:8080 ✗ 端口不同
http://www.example.com:80  vs  http://api.example.com:80  ✗ 域名不同
http://www.example.com:80  vs  http://www.example.net:80  ✗ 域名不同
*/

// 同源策略限制的行为
/*
1. 无法读取Cookie、LocalStorage、IndexedDB
2. 无法操作DOM
3. 无法发送AJAX请求（会发送，但浏览器拦截响应）
*/

// 示例1: Cookie限制
// http://a.com
document.cookie = 'name=value';

// http://b.com
console.log(document.cookie);  // 读不到a.com的cookie

// 示例2: DOM限制
// http://a.com打开一个http://b.com的iframe
const iframe = document.createElement('iframe');
iframe.src = 'http://b.com';
document.body.appendChild(iframe);

// 无法访问iframe的DOM
console.log(iframe.contentDocument);  // SecurityError

// 示例3: AJAX限制
// http://a.com发送请求到http://b.com/api
fetch('http://b.com/api')
  .then(res => res.json())
  .catch(err => console.error(err));
// Error: CORS policy blocked

// 同源策略的意义
/*
安全性：
1. 防止CSRF攻击（Cross-Site Request Forgery）
2. 防止XSS攻击（Cross-Site Scripting）
3. 保护用户隐私数据

如果没有同源策略：
1. 恶意网站可以读取银行网站的Cookie
2. 恶意网站可以操作其他网站的DOM
3. 恶意网站可以冒充用户发送请求
*/
```

## 2. CORS（跨域资源共享）

### CORS原理

```javascript
// CORS (Cross-Origin Resource Sharing)
// 是W3C标准，允许服务器声明哪些源可以访问资源

// CORS请求分类
/*
1. 简单请求（Simple Request）
2. 非简单请求（Preflight Request）
*/

// 简单请求的条件
/*
1. 请求方法：GET、POST、HEAD
2. Content-Type：
   - text/plain
   - multipart/form-data
   - application/x-www-form-urlencoded
3. 请求头：只能包含浏览器自动设置的头部
*/

// 简单请求流程
/*
1. 浏览器自动添加Origin头
   GET /api/users HTTP/1.1
   Origin: http://example.com

2. 服务器检查Origin，决定是否允许
   HTTP/1.1 200 OK
   Access-Control-Allow-Origin: http://example.com
   Access-Control-Allow-Credentials: true

3. 浏览器检查响应头，决定是否返回数据给JS
*/

// 非简单请求流程（需要预检）
/*
1. 浏览器先发送OPTIONS预检请求
   OPTIONS /api/users HTTP/1.1
   Origin: http://example.com
   Access-Control-Request-Method: PUT
   Access-Control-Request-Headers: X-Custom-Header

2. 服务器响应预检请求
   HTTP/1.1 200 OK
   Access-Control-Allow-Origin: http://example.com
   Access-Control-Allow-Methods: PUT, POST, DELETE
   Access-Control-Allow-Headers: X-Custom-Header
   Access-Control-Max-Age: 86400

3. 预检通过后，发送实际请求
   PUT /api/users HTTP/1.1
   Origin: http://example.com
   X-Custom-Header: value

4. 服务器响应实际请求
   HTTP/1.1 200 OK
   Access-Control-Allow-Origin: http://example.com
*/

// Node.js服务器CORS配置
const express = require('express');
const app = express();

// 方法1: 手动设置CORS头
app.use((req, res, next) => {
  // 允许的源（*表示所有源）
  res.setHeader('Access-Control-Allow-Origin', 'http://example.com');

  // 允许的HTTP方法
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');

  // 允许的请求头
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Custom-Header');

  // 是否允许携带Cookie
  res.setHeader('Access-Control-Allow-Credentials', 'true');

  // 预检请求缓存时间（秒）
  res.setHeader('Access-Control-Max-Age', '86400');

  // 允许浏览器访问的响应头
  res.setHeader('Access-Control-Expose-Headers', 'X-Total-Count');

  // 处理OPTIONS预检请求
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }

  next();
});

// 方法2: 使用cors中间件
const cors = require('cors');

// 允许所有源
app.use(cors());

// 允许特定源
app.use(cors({
  origin: 'http://example.com',
  credentials: true
}));

// 动态设置允许的源
app.use(cors({
  origin: function(origin, callback) {
    const allowedOrigins = ['http://example.com', 'http://test.com'];
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true
}));

// 方法3: Nginx配置CORS
/*
location /api {
    # 允许的源
    add_header Access-Control-Allow-Origin $http_origin;

    # 允许的方法
    add_header Access-Control-Allow-Methods 'GET, POST, PUT, DELETE, OPTIONS';

    # 允许的请求头
    add_header Access-Control-Allow-Headers 'Content-Type, Authorization, X-Custom-Header';

    # 允许携带Cookie
    add_header Access-Control-Allow-Credentials 'true';

    # 预检请求缓存
    add_header Access-Control-Max-Age 86400;

    # 处理OPTIONS请求
    if ($request_method = 'OPTIONS') {
        return 204;
    }

    proxy_pass http://backend;
}
*/

// 客户端发送CORS请求
// 简单请求
fetch('http://api.example.com/users', {
  method: 'GET',
  credentials: 'include'  // 携带Cookie
})
  .then(res => res.json())
  .then(data => console.log(data));

// 非简单请求
fetch('http://api.example.com/users', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
    'X-Custom-Header': 'value'
  },
  credentials: 'include',
  body: JSON.stringify({ name: 'John' })
})
  .then(res => res.json())
  .then(data => console.log(data));

// axios配置
import axios from 'axios';

axios.defaults.withCredentials = true;  // 携带Cookie

axios.get('http://api.example.com/users')
  .then(res => console.log(res.data));

// CORS响应头详解
/*
1. Access-Control-Allow-Origin: 允许的源
   - *: 所有源
   - http://example.com: 特定源
   - 注意: 如果需要携带Cookie，不能设置为*

2. Access-Control-Allow-Methods: 允许的HTTP方法
   - GET, POST, PUT, DELETE, OPTIONS

3. Access-Control-Allow-Headers: 允许的请求头
   - Content-Type, Authorization, X-Custom-Header

4. Access-Control-Allow-Credentials: 是否允许携带Cookie
   - true: 允许
   - 注意: Origin不能为*

5. Access-Control-Max-Age: 预检请求缓存时间（秒）
   - 86400: 24小时

6. Access-Control-Expose-Headers: 允许访问的响应头
   - 默认只能访问: Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma
   - 需要访问其他头，必须声明
*/
```

### CORS实战案例

```javascript
// 完整的CORS配置（生产环境）

// 后端（Node.js + Express）
const express = require('express');
const app = express();

// CORS配置
const corsOptions = {
  origin: function(origin, callback) {
    // 允许的源列表
    const whitelist = [
      'http://localhost:3000',
      'http://localhost:8080',
      'https://example.com',
      'https://www.example.com'
    ];

    // 允许无origin的请求（如Postman、curl）
    if (!origin || whitelist.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },

  // 允许的HTTP方法
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],

  // 允许的请求头
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-Requested-With',
    'Accept',
    'Origin'
  ],

  // 允许浏览器访问的响应头
  exposedHeaders: ['X-Total-Count', 'X-Page-Count'],

  // 允许携带Cookie
  credentials: true,

  // 预检请求缓存时间（秒）
  maxAge: 86400,

  // 为传统浏览器提供200状态码
  optionsSuccessStatus: 200
};

app.use(cors(corsOptions));

// API路由
app.get('/api/users', (req, res) => {
  res.json({ users: [] });
});

// 错误处理
app.use((err, req, res, next) => {
  if (err.message === 'Not allowed by CORS') {
    res.status(403).json({ error: 'CORS not allowed' });
  } else {
    next(err);
  }
});

app.listen(3000);

// 前端（React + axios）
import axios from 'axios';

// 创建axios实例
const api = axios.create({
  baseURL: 'http://api.example.com',
  timeout: 10000,
  withCredentials: true  // 携带Cookie
});

// 请求拦截器
api.interceptors.request.use(
  config => {
    // 添加token
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  error => Promise.reject(error)
);

// 响应拦截器
api.interceptors.response.use(
  response => response.data,
  error => {
    if (error.response?.status === 403) {
      console.error('CORS error:', error.message);
    }
    return Promise.reject(error);
  }
);

// 使用
async function fetchUsers() {
  try {
    const users = await api.get('/api/users');
    console.log(users);
  } catch (error) {
    console.error('Failed to fetch users:', error);
  }
}
```

## 3. JSONP

### JSONP原理

```javascript
// JSONP (JSON with Padding)
// 利用<script>标签不受同源策略限制的特性

// 原理
/*
1. 创建<script>标签
2. 设置src为跨域API + 回调函数名
3. 服务器返回：callback(data)
4. 浏览器执行callback函数
*/

// 客户端实现
function jsonp(url, params, callback) {
  return new Promise((resolve, reject) => {
    // 生成唯一的回调函数名
    const callbackName = `jsonp_${Date.now()}_${Math.random().toString(36).substr(2)}`;

    // 将回调函数挂载到window上
    window[callbackName] = function(data) {
      resolve(data);
      // 清理
      delete window[callbackName];
      document.body.removeChild(script);
    };

    // 构建URL参数
    const queryString = Object.keys(params)
      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`)
      .join('&');

    // 创建script标签
    const script = document.createElement('script');
    script.src = `${url}?${queryString}&callback=${callbackName}`;

    // 错误处理
    script.onerror = function() {
      reject(new Error('JSONP request failed'));
      delete window[callbackName];
      document.body.removeChild(script);
    };

    // 添加到页面
    document.body.appendChild(script);
  });
}

// 使用
jsonp('http://api.example.com/users', { page: 1 }, 'handleUsers')
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error(error);
  });

// 服务器端实现（Node.js）
app.get('/api/users', (req, res) => {
  const callback = req.query.callback;
  const data = { users: ['Alice', 'Bob'] };

  // 返回JSONP格式
  res.send(`${callback}(${JSON.stringify(data)})`);
});

// 或使用Express的jsonp方法
app.get('/api/users', (req, res) => {
  res.jsonp({ users: ['Alice', 'Bob'] });
});

// JSONP优缺点
/*
优点:
1. 兼容性好（IE6+）
2. 实现简单

缺点:
1. 只支持GET请求
2. 安全性差（易受XSS攻击）
3. 错误处理困难
4. 无法设置请求头
5. 需要服务器支持
*/

// jQuery实现JSONP
$.ajax({
  url: 'http://api.example.com/users',
  dataType: 'jsonp',
  jsonp: 'callback',  // 回调参数名
  success: function(data) {
    console.log(data);
  },
  error: function(error) {
    console.error(error);
  }
});

// 安全的JSONP实现
function safeJsonp(url, params, timeout = 5000) {
  return new Promise((resolve, reject) => {
    const callbackName = `jsonp_${Date.now()}_${Math.random().toString(36).substr(2)}`;
    let timeoutId;

    window[callbackName] = function(data) {
      clearTimeout(timeoutId);
      resolve(data);
      cleanup();
    };

    const script = document.createElement('script');

    // CSP (Content Security Policy) 兼容
    script.setAttribute('nonce', getNonce());

    // 构建URL
    const queryString = Object.keys(params)
      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`)
      .join('&');

    script.src = `${url}?${queryString}&callback=${callbackName}`;

    script.onerror = function() {
      clearTimeout(timeoutId);
      reject(new Error('JSONP request failed'));
      cleanup();
    };

    // 超时处理
    timeoutId = setTimeout(() => {
      reject(new Error('JSONP request timeout'));
      cleanup();
    }, timeout);

    function cleanup() {
      delete window[callbackName];
      if (script.parentNode) {
        document.body.removeChild(script);
      }
    }

    document.body.appendChild(script);
  });
}

function getNonce() {
  // 从meta标签获取CSP nonce
  const meta = document.querySelector('meta[property="csp-nonce"]');
  return meta ? meta.content : '';
}
```

## 4. 代理（Proxy）

### 开发环境代理

```javascript
// 方式1: Webpack Dev Server代理

// webpack.config.js
module.exports = {
  devServer: {
    port: 3000,
    proxy: {
      // 代理/api请求到http://localhost:4000
      '/api': {
        target: 'http://localhost:4000',
        changeOrigin: true,  // 改变请求头的origin
        pathRewrite: {
          '^/api': ''  // 重写路径：/api/users → /users
        }
      },

      // 多个代理配置
      '/auth': {
        target: 'http://auth.example.com',
        changeOrigin: true,
        secure: false,  // 接受运行在HTTPS上的服务但使用无效证书
        ws: true,  // 代理WebSocket
        onProxyReq: (proxyReq, req, res) => {
          // 请求前的处理
          proxyReq.setHeader('X-Special-Header', 'value');
        },
        onProxyRes: (proxyRes, req, res) => {
          // 响应后的处理
          console.log('Response from:', proxyRes.headers);
        }
      },

      // 代理所有请求
      '/api/**': {
        target: 'http://api.example.com',
        changeOrigin: true
      }
    }
  }
};

// 方式2: Create React App代理

// package.json
{
  "proxy": "http://localhost:4000"
}

// 或创建src/setupProxy.js
const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = function(app) {
  app.use(
    '/api',
    createProxyMiddleware({
      target: 'http://localhost:4000',
      changeOrigin: true,
      pathRewrite: {
        '^/api': ''
      }
    })
  );
};

// 方式3: Vite代理

// vite.config.js
export default {
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:4000',
        changeOrigin: true,
        rewrite: path => path.replace(/^\/api/, '')
      }
    }
  }
};

// 方式4: Vue CLI代理

// vue.config.js
module.exports = {
  devServer: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:4000',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
};

// 客户端请求（无需改变）
fetch('/api/users')
  .then(res => res.json())
  .then(data => console.log(data));

// axios配置
import axios from 'axios';

const api = axios.create({
  baseURL: '/api',  // 会被代理到http://localhost:4000
  timeout: 10000
});

api.get('/users').then(res => console.log(res.data));
```

### 生产环境代理

```javascript
// 方式1: Nginx反向代理

/*
server {
    listen 80;
    server_name example.com;

    # 前端静态文件
    location / {
        root /var/www/frontend;
        try_files $uri $uri/ /index.html;
    }

    # 代理API请求
    location /api {
        # 去掉/api前缀
        rewrite ^/api/(.*)$ /$1 break;

        # 代理到后端服务
        proxy_pass http://backend:4000;

        # 设置请求头
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # 超时设置
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        # WebSocket支持
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }

    # 负载均衡
    location /api2 {
        proxy_pass http://backend_cluster;
    }
}

# 后端服务集群
upstream backend_cluster {
    server backend1:4000 weight=3;
    server backend2:4000 weight=2;
    server backend3:4000 weight=1;
}
*/

// 方式2: Node.js中间层代理

// server.js
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');

const app = express();

// 静态文件
app.use(express.static('build'));

// API代理
app.use('/api', createProxyMiddleware({
  target: 'http://backend:4000',
  changeOrigin: true,
  pathRewrite: {
    '^/api': ''
  },
  onProxyReq: (proxyReq, req, res) => {
    // 添加认证token
    const token = req.headers.authorization;
    if (token) {
      proxyReq.setHeader('Authorization', token);
    }
  },
  onError: (err, req, res) => {
    res.status(500).json({ error: 'Proxy error' });
  }
}));

// 所有其他请求返回index.html（SPA）
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'build', 'index.html'));
});

app.listen(3000);

// 方式3: Apache反向代理

/*
<VirtualHost *:80>
    ServerName example.com

    # 静态文件
    DocumentRoot /var/www/frontend

    # API代理
    ProxyPass /api http://backend:4000
    ProxyPassReverse /api http://backend:4000

    # 设置请求头
    ProxyPreserveHost On
    RequestHeader set X-Forwarded-Proto "http"
</VirtualHost>
*/
```

## 5. postMessage

### 跨窗口通信

```javascript
// postMessage：跨窗口/iframe通信

// 父窗口发送消息到iframe
const iframe = document.getElementById('myIframe');

// 等待iframe加载完成
iframe.onload = function() {
  // 发送消息
  iframe.contentWindow.postMessage(
    { type: 'greeting', message: 'Hello from parent' },
    'http://child-domain.com'  // 目标源（重要：不要用*）
  );
};

// 父窗口接收来自iframe的消息
window.addEventListener('message', function(event) {
  // 验证消息来源（重要！）
  if (event.origin !== 'http://child-domain.com') {
    return;
  }

  console.log('Received from iframe:', event.data);

  // 回复消息
  event.source.postMessage(
    { type: 'reply', message: 'Message received' },
    event.origin
  );
});

// iframe发送消息到父窗口
window.parent.postMessage(
  { type: 'ready', message: 'Iframe is ready' },
  'http://parent-domain.com'
);

// iframe接收来自父窗口的消息
window.addEventListener('message', function(event) {
  if (event.origin !== 'http://parent-domain.com') {
    return;
  }

  console.log('Received from parent:', event.data);
});

// 实战案例：跨域RPC（远程过程调用）

// 父窗口
class IframeRPC {
  constructor(iframe, targetOrigin) {
    this.iframe = iframe;
    this.targetOrigin = targetOrigin;
    this.callbacks = new Map();
    this.messageId = 0;

    window.addEventListener('message', this.handleMessage.bind(this));
  }

  handleMessage(event) {
    if (event.origin !== this.targetOrigin) return;

    const { id, result, error } = event.data;
    const callback = this.callbacks.get(id);

    if (callback) {
      if (error) {
        callback.reject(error);
      } else {
        callback.resolve(result);
      }
      this.callbacks.delete(id);
    }
  }

  call(method, params) {
    return new Promise((resolve, reject) => {
      const id = ++this.messageId;

      this.callbacks.set(id, { resolve, reject });

      this.iframe.contentWindow.postMessage(
        { id, method, params },
        this.targetOrigin
      );

      // 超时处理
      setTimeout(() => {
        if (this.callbacks.has(id)) {
          this.callbacks.delete(id);
          reject(new Error('RPC timeout'));
        }
      }, 5000);
    });
  }
}

// 使用
const iframe = document.getElementById('myIframe');
const rpc = new IframeRPC(iframe, 'http://child-domain.com');

iframe.onload = async function() {
  try {
    const result = await rpc.call('getUserInfo', { id: 123 });
    console.log('User info:', result);
  } catch (error) {
    console.error('RPC error:', error);
  }
};

// iframe（子窗口）
class RPCServer {
  constructor(allowedOrigin) {
    this.allowedOrigin = allowedOrigin;
    this.methods = {};

    window.addEventListener('message', this.handleMessage.bind(this));
  }

  handleMessage(event) {
    if (event.origin !== this.allowedOrigin) return;

    const { id, method, params } = event.data;

    if (!this.methods[method]) {
      event.source.postMessage(
        { id, error: 'Method not found' },
        event.origin
      );
      return;
    }

    try {
      const result = this.methods[method](params);

      if (result instanceof Promise) {
        result
          .then(res => {
            event.source.postMessage({ id, result: res }, event.origin);
          })
          .catch(err => {
            event.source.postMessage({ id, error: err.message }, event.origin);
          });
      } else {
        event.source.postMessage({ id, result }, event.origin);
      }
    } catch (error) {
      event.source.postMessage({ id, error: error.message }, event.origin);
    }
  }

  register(method, handler) {
    this.methods[method] = handler;
  }
}

// 使用
const server = new RPCServer('http://parent-domain.com');

server.register('getUserInfo', async (params) => {
  const response = await fetch(`/api/users/${params.id}`);
  return response.json();
});
```

## 6. 其他跨域方案

### WebSocket

```javascript
// WebSocket不受同源策略限制

// 客户端
const ws = new WebSocket('ws://api.example.com:8080');

ws.onopen = function() {
  console.log('Connected');
  ws.send(JSON.stringify({ type: 'greeting', message: 'Hello' }));
};

ws.onmessage = function(event) {
  const data = JSON.parse(event.data);
  console.log('Received:', data);
};

ws.onerror = function(error) {
  console.error('WebSocket error:', error);
};

ws.onclose = function() {
  console.log('Disconnected');
};

// 服务器（Node.js + ws）
const WebSocket = require('ws');

const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', function(ws, req) {
  // 可以验证origin
  const origin = req.headers.origin;
  if (origin !== 'http://example.com') {
    ws.close();
    return;
  }

  ws.on('message', function(message) {
    const data = JSON.parse(message);
    console.log('Received:', data);

    // 发送响应
    ws.send(JSON.stringify({
      type: 'response',
      message: 'Message received'
    }));
  });
});
```

### document.domain

```javascript
// document.domain：主域相同时使用（不推荐，已废弃）

// http://a.example.com
document.domain = 'example.com';

const iframe = document.createElement('iframe');
iframe.src = 'http://b.example.com';
document.body.appendChild(iframe);

iframe.onload = function() {
  // 可以访问iframe的DOM
  console.log(iframe.contentDocument);
};

// http://b.example.com
document.domain = 'example.com';

// 现在两个页面可以互相访问

// 注意：
// 1. 只能设置为当前域或父域
// 2. 端口会被重置为null
// 3. 已被标记为废弃，不建议使用
```

### window.name

```javascript
// window.name：利用window.name跨域传递数据（不推荐）

// a.html (http://a.com)
const iframe = document.createElement('iframe');
iframe.src = 'http://b.com/data.html';

iframe.onload = function() {
  // 第一次加载完成
  iframe.onload = function() {
    // 第二次加载完成，读取数据
    console.log(iframe.contentWindow.name);  // 可以读取
    document.body.removeChild(iframe);
  };

  // 切换到同源页面
  iframe.src = 'http://a.com/proxy.html';
};

document.body.appendChild(iframe);

// b.html (http://b.com)
window.name = JSON.stringify({ data: 'some data' });

// proxy.html (http://a.com)
// 空页面即可
```

## 7. 跨域方案对比

```javascript
// 跨域方案对比

/*
┌──────────────┬─────────┬────────┬────────┬────────┬────────────┐
│    方案      │ 易用性  │ 兼容性 │ 安全性 │ 性能   │ 推荐度     │
├──────────────┼─────────┼────────┼────────┼────────┼────────────┤
│ CORS         │   ★★★★★ │  ★★★★☆ │ ★★★★★  │ ★★★★★  │ ★★★★★ 首选 │
│ 代理         │   ★★★★☆ │  ★★★★★ │ ★★★★★  │ ★★★★☆  │ ★★★★★ 首选 │
│ JSONP        │   ★★★☆☆ │  ★★★★★ │ ★★☆☆☆  │ ★★★☆☆  │ ★★☆☆☆ 不推荐│
│ postMessage  │   ★★★☆☆ │  ★★★★☆ │ ★★★★☆  │ ★★★★☆  │ ★★★★☆      │
│ WebSocket    │   ★★★★☆ │  ★★★★☆ │ ★★★★☆  │ ★★★★★  │ ★★★★☆      │
│ document.domain│ ★★☆☆☆ │  ★★★☆☆ │ ★★☆☆☆  │ ★★★☆☆  │ ★☆☆☆☆ 废弃 │
│ window.name  │   ★☆☆☆☆ │  ★★★★★ │ ★★☆☆☆  │ ★★☆☆☆  │ ★☆☆☆☆ 不推荐│
└──────────────┴─────────┴────────┴────────┴────────┴────────────┘
*/

// 选择建议
const recommendations = {
  '现代Web应用': 'CORS（首选）',
  '开发环境': 'Webpack Dev Server代理',
  '生产环境': 'Nginx反向代理',
  '跨窗口通信': 'postMessage',
  '实时通信': 'WebSocket',
  '兼容老浏览器': 'JSONP（仅GET请求）',
  '主域相同': '改用CORS（不要用document.domain）'
};

// 安全注意事项
const securityTips = [
  '1. CORS: 不要设置Access-Control-Allow-Origin为*（如果需要携带Cookie）',
  '2. JSONP: 验证回调函数名，防止XSS攻击',
  '3. postMessage: 始终验证event.origin',
  '4. 代理: 限制代理的目标域',
  '5. WebSocket: 验证origin头'
];
```

跨域问题是前端开发中的常见问题，理解各种跨域方案的原理和使用场景对于构建安全可靠的Web应用至关重要！
