# 观察者模式和中介者模式深度解析

## 1. 观察者模式的本质

### 什么是观察者模式

```javascript
// 观察者模式（Observer Pattern）
// 定义：对象间的一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都会得到通知

// 核心角色：
// 1. Subject（主题/被观察者）：维护观察者列表，提供添加/删除观察者的方法
// 2. Observer（观察者）：定义更新接口，接收主题通知

// 基础示例
class Subject {
  constructor() {
    this.observers = [];  // 观察者列表
  }

  // 添加观察者
  attach(observer) {
    this.observers.push(observer);
  }

  // 移除观察者
  detach(observer) {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }

  // 通知所有观察者
  notify(data) {
    this.observers.forEach(observer => {
      observer.update(data);
    });
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }

  update(data) {
    console.log(`${this.name} received:`, data);
  }
}

// 使用
const subject = new Subject();

const observer1 = new Observer('Observer 1');
const observer2 = new Observer('Observer 2');

subject.attach(observer1);
subject.attach(observer2);

subject.notify('Hello!');
// 输出:
// Observer 1 received: Hello!
// Observer 2 received: Hello!

// 特点：
// 1. 直接依赖：观察者直接订阅主题
// 2. 推送模式：主题主动推送数据给观察者
// 3. 紧耦合：主题知道观察者的存在
```

### 观察者模式 vs 发布-订阅模式

```javascript
// 很多人混淆观察者模式和发布-订阅模式
// 它们很相似，但有重要区别：

// 观察者模式：直接依赖
// Subject → Observer (直接通知)

// 发布-订阅模式：通过事件中心解耦
// Publisher → Event Channel → Subscriber (间接通知)

// 发布-订阅模式示例
class EventEmitter {
  constructor() {
    this.events = {};  // 事件中心
  }

  // 订阅
  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
  }

  // 发布
  emit(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(listener => {
        listener(data);
      });
    }
  }

  // 取消订阅
  off(event, listener) {
    if (this.events[event]) {
      const index = this.events[event].indexOf(listener);
      if (index > -1) {
        this.events[event].splice(index, 1);
      }
    }
  }
}

// 使用
const emitter = new EventEmitter();

// 订阅者A
function subscriberA(data) {
  console.log('Subscriber A:', data);
}

// 订阅者B
function subscriberB(data) {
  console.log('Subscriber B:', data);
}

emitter.on('message', subscriberA);
emitter.on('message', subscriberB);

// 发布者（不知道订阅者的存在）
emitter.emit('message', 'Hello!');
// 输出:
// Subscriber A: Hello!
// Subscriber B: Hello!

// 区别总结：
/*
| 特性       | 观察者模式        | 发布-订阅模式      |
|-----------|------------------|-------------------|
| 耦合度     | 紧耦合           | 松耦合             |
| 组件       | Subject, Observer| Publisher, Subscriber, Event Channel |
| 通信       | 直接             | 间接（通过事件中心）|
| 灵活性     | 较低             | 较高              |
| 实现复杂度 | 简单             | 较复杂            |
*/
```

## 2. 观察者模式完整实现

### 基础版实现

```javascript
// 完整的观察者模式实现
class Subject {
  constructor() {
    this.observers = new Set();  // 使用Set避免重复
  }

  // 添加观察者
  attach(observer) {
    if (typeof observer.update !== 'function') {
      throw new Error('Observer must have an update method');
    }
    this.observers.add(observer);
    return this;  // 链式调用
  }

  // 移除观察者
  detach(observer) {
    this.observers.delete(observer);
    return this;
  }

  // 通知所有观察者
  notify(data) {
    this.observers.forEach(observer => {
      try {
        observer.update(data);
      } catch (error) {
        console.error('Observer update failed:', error);
      }
    });
  }

  // 获取观察者数量
  getObserverCount() {
    return this.observers.size;
  }
}

class Observer {
  constructor(name, callback) {
    this.name = name;
    this.callback = callback;
  }

  update(data) {
    console.log(`[${this.name}] Received:`, data);
    if (this.callback) {
      this.callback(data);
    }
  }
}

// 使用
const subject = new Subject();

const observer1 = new Observer('Logger', data => {
  console.log('Logging:', data);
});

const observer2 = new Observer('Analytics', data => {
  console.log('Tracking:', data);
});

subject
  .attach(observer1)
  .attach(observer2);

subject.notify({ event: 'user_login', user: 'John' });
// 输出:
// [Logger] Received: { event: 'user_login', user: 'John' }
// Logging: { event: 'user_login', user: 'John' }
// [Analytics] Received: { event: 'user_login', user: 'John' }
// Tracking: { event: 'user_login', user: 'John' }
```

### 增强版实现（带优先级和过滤）

```javascript
// 增强的观察者模式
class EnhancedSubject {
  constructor() {
    this.observers = [];
  }

  // 添加观察者（支持优先级）
  attach(observer, priority = 0) {
    const entry = { observer, priority };

    // 按优先级插入（优先级高的先执行）
    let inserted = false;
    for (let i = 0; i < this.observers.length; i++) {
      if (priority > this.observers[i].priority) {
        this.observers.splice(i, 0, entry);
        inserted = true;
        break;
      }
    }

    if (!inserted) {
      this.observers.push(entry);
    }

    return this;
  }

  // 移除观察者
  detach(observer) {
    this.observers = this.observers.filter(
      entry => entry.observer !== observer
    );
    return this;
  }

  // 通知（支持条件过滤）
  notify(data, filter = null) {
    this.observers.forEach(({ observer }) => {
      // 应用过滤器
      if (filter && !filter(observer)) {
        return;
      }

      try {
        observer.update(data);
      } catch (error) {
        console.error('Observer update failed:', error);
      }
    });
  }

  // 条件通知
  notifyWhere(data, condition) {
    this.notify(data, observer => condition(observer));
  }
}

class EnhancedObserver {
  constructor(name, tags = []) {
    this.name = name;
    this.tags = new Set(tags);
  }

  update(data) {
    console.log(`[${this.name}]`, data);
  }

  hasTag(tag) {
    return this.tags.has(tag);
  }
}

// 使用
const subject = new EnhancedSubject();

const logger = new EnhancedObserver('Logger', ['logging']);
const analytics = new EnhancedObserver('Analytics', ['tracking']);
const debugger = new EnhancedObserver('Debugger', ['logging', 'debugging']);

// 按优先级添加
subject
  .attach(logger, 1)      // 低优先级
  .attach(analytics, 2)   // 中优先级
  .attach(debugger, 3);   // 高优先级

// 全部通知（按优先级顺序）
subject.notify('Event 1');
// 输出顺序: Debugger → Analytics → Logger

// 条件通知（只通知带'logging'标签的观察者）
subject.notifyWhere('Event 2', observer =>
  observer.hasTag('logging')
);
// 输出: Debugger, Logger (Analytics不会收到)
```

### 异步观察者模式

```javascript
// 支持异步的观察者模式
class AsyncSubject {
  constructor() {
    this.observers = [];
  }

  attach(observer) {
    this.observers.push(observer);
    return this;
  }

  detach(observer) {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
    return this;
  }

  // 异步通知（串行）
  async notifySerial(data) {
    for (const observer of this.observers) {
      try {
        await observer.update(data);
      } catch (error) {
        console.error('Observer update failed:', error);
      }
    }
  }

  // 异步通知（并行）
  async notifyParallel(data) {
    const promises = this.observers.map(observer =>
      Promise.resolve(observer.update(data))
        .catch(error => {
          console.error('Observer update failed:', error);
        })
    );

    await Promise.all(promises);
  }

  // 异步通知（竞速）
  async notifyRace(data) {
    const promises = this.observers.map(observer =>
      Promise.resolve(observer.update(data))
    );

    return Promise.race(promises);
  }
}

class AsyncObserver {
  constructor(name, delay) {
    this.name = name;
    this.delay = delay;
  }

  async update(data) {
    await new Promise(resolve => setTimeout(resolve, this.delay));
    console.log(`[${this.name}] Processed:`, data);
    return `${this.name} result`;
  }
}

// 使用
const subject = new AsyncSubject();

const observer1 = new AsyncObserver('Fast', 100);
const observer2 = new AsyncObserver('Medium', 200);
const observer3 = new AsyncObserver('Slow', 300);

subject
  .attach(observer1)
  .attach(observer2)
  .attach(observer3);

// 串行通知（总耗时600ms）
console.time('serial');
await subject.notifySerial('Serial event');
console.timeEnd('serial');  // ~600ms

// 并行通知（总耗时300ms）
console.time('parallel');
await subject.notifyParallel('Parallel event');
console.timeEnd('parallel');  // ~300ms

// 竞速通知（返回最快的）
const result = await subject.notifyRace('Race event');
console.log('First result:', result);  // "Fast result" (~100ms)
```

## 3. 观察者模式实战案例

### 案例1：事件系统

```javascript
// 实现一个完整的事件系统
class EventSystem {
  constructor() {
    this.listeners = new Map();
  }

  // 添加监听器
  on(event, listener, options = {}) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }

    const entry = {
      listener,
      once: options.once || false,
      priority: options.priority || 0
    };

    // 按优先级插入
    const listeners = this.listeners.get(event);
    let inserted = false;

    for (let i = 0; i < listeners.length; i++) {
      if (entry.priority > listeners[i].priority) {
        listeners.splice(i, 0, entry);
        inserted = true;
        break;
      }
    }

    if (!inserted) {
      listeners.push(entry);
    }

    // 返回取消订阅函数
    return () => this.off(event, listener);
  }

  // 一次性监听
  once(event, listener, options = {}) {
    return this.on(event, listener, { ...options, once: true });
  }

  // 移除监听器
  off(event, listener) {
    if (!this.listeners.has(event)) return;

    const listeners = this.listeners.get(event);
    const index = listeners.findIndex(entry => entry.listener === listener);

    if (index > -1) {
      listeners.splice(index, 1);
    }

    // 如果没有监听器了，删除事件
    if (listeners.length === 0) {
      this.listeners.delete(event);
    }
  }

  // 触发事件
  emit(event, ...args) {
    if (!this.listeners.has(event)) return;

    const listeners = this.listeners.get(event);
    const toRemove = [];

    listeners.forEach(({ listener, once }) => {
      try {
        listener(...args);
      } catch (error) {
        console.error(`Error in listener for "${event}":`, error);
      }

      // 标记需要移除的一次性监听器
      if (once) {
        toRemove.push(listener);
      }
    });

    // 移除一次性监听器
    toRemove.forEach(listener => this.off(event, listener));
  }

  // 获取事件的监听器数量
  listenerCount(event) {
    return this.listeners.get(event)?.length || 0;
  }

  // 清空所有监听器
  clear() {
    this.listeners.clear();
  }
}

// 使用
const events = new EventSystem();

// 普通监听
events.on('user:login', user => {
  console.log('User logged in:', user.name);
});

// 优先级监听
events.on('user:login', user => {
  console.log('[高优先级] Validating user:', user.name);
}, { priority: 10 });

// 一次性监听
events.once('user:login', user => {
  console.log('[仅一次] Welcome:', user.name);
});

// 触发事件
events.emit('user:login', { name: 'John', id: 1 });
// 输出顺序:
// [高优先级] Validating user: John
// User logged in: John
// [仅一次] Welcome: John

events.emit('user:login', { name: 'Jane', id: 2 });
// 输出顺序:
// [高优先级] Validating user: Jane
// User logged in: Jane
// (一次性监听器不再执行)
```

### 案例2：数据绑定（双向绑定原理）

```javascript
// 实现简单的双向数据绑定（类似Vue）
class Observable {
  constructor(data) {
    this.observers = new Map();

    // 使用Proxy拦截属性访问
    return new Proxy(data, {
      get: (target, property) => {
        return target[property];
      },

      set: (target, property, value) => {
        const oldValue = target[property];

        // 值没变，不触发通知
        if (oldValue === value) return true;

        target[property] = value;

        // 通知观察者
        this.notify(property, value, oldValue);

        return true;
      }
    });
  }

  // 订阅属性变化
  watch(property, callback) {
    if (!this.observers.has(property)) {
      this.observers.set(property, []);
    }

    this.observers.get(property).push(callback);

    // 返回取消订阅函数
    return () => {
      const callbacks = this.observers.get(property);
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    };
  }

  // 通知观察者
  notify(property, newValue, oldValue) {
    if (!this.observers.has(property)) return;

    this.observers.get(property).forEach(callback => {
      callback(newValue, oldValue);
    });
  }
}

// 使用
const data = new Observable({
  name: 'John',
  age: 30
});

// 监听name变化
data.watch('name', (newValue, oldValue) => {
  console.log(`Name changed: ${oldValue} → ${newValue}`);
  // 更新DOM
  document.getElementById('name').textContent = newValue;
});

// 监听age变化
data.watch('age', (newValue, oldValue) => {
  console.log(`Age changed: ${oldValue} → ${newValue}`);
  document.getElementById('age').textContent = newValue;
});

// 修改数据
data.name = 'Jane';  // 触发: Name changed: John → Jane
data.age = 31;       // 触发: Age changed: 30 → 31

// 实现双向绑定
function bind(data, property, element) {
  // 数据 → 视图
  data.watch(property, value => {
    if (element.value !== undefined) {
      element.value = value;  // input
    } else {
      element.textContent = value;  // 普通元素
    }
  });

  // 视图 → 数据
  if (element.value !== undefined) {
    element.addEventListener('input', e => {
      data[property] = e.target.value;
    });
  }
}

// 使用
const input = document.getElementById('nameInput');
bind(data, 'name', input);
// 现在input和data.name双向绑定了
```

### 案例3：状态管理（类似Redux）

```javascript
// 实现简单的状态管理器
class Store {
  constructor(initialState = {}, reducer) {
    this.state = initialState;
    this.reducer = reducer;
    this.listeners = [];
  }

  // 获取状态
  getState() {
    return this.state;
  }

  // 订阅状态变化
  subscribe(listener) {
    this.listeners.push(listener);

    // 返回取消订阅函数
    return () => {
      const index = this.listeners.indexOf(listener);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }

  // 派发action
  dispatch(action) {
    // 通过reducer计算新状态
    const newState = this.reducer(this.state, action);

    // 状态没变，不通知
    if (newState === this.state) return;

    this.state = newState;

    // 通知所有订阅者
    this.listeners.forEach(listener => {
      try {
        listener(this.state, action);
      } catch (error) {
        console.error('Listener error:', error);
      }
    });
  }
}

// 使用
// 定义reducer
function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    case 'RESET':
      return { ...state, count: 0 };
    default:
      return state;
  }
}

// 创建store
const store = new Store({ count: 0 }, counterReducer);

// 订阅状态变化
const unsubscribe = store.subscribe((state, action) => {
  console.log('State changed:', state);
  console.log('Action:', action);
  // 更新UI
  document.getElementById('count').textContent = state.count;
});

// 派发actions
store.dispatch({ type: 'INCREMENT' });
// 输出: State changed: { count: 1 }

store.dispatch({ type: 'INCREMENT' });
// 输出: State changed: { count: 2 }

store.dispatch({ type: 'DECREMENT' });
// 输出: State changed: { count: 1 }

// 取消订阅
unsubscribe();
```

## 4. 中介者模式的本质

### 什么是中介者模式

```javascript
// 中介者模式（Mediator Pattern）
// 定义：用一个中介对象来封装一系列对象交互
// 目的：减少对象之间的直接依赖，降低耦合度

// 问题场景：多个对象之间需要相互通信
// 不使用中介者：
// A ←→ B
// ↕     ↕
// C ←→ D
// (6条通信线路，复杂度O(n²))

// 使用中介者：
//     Mediator
//    /  |  \  \
//   A   B   C  D
// (4条通信线路，复杂度O(n))

// 基础示例
class Mediator {
  constructor() {
    this.colleagues = [];
  }

  // 注册同事对象
  register(colleague) {
    this.colleagues.push(colleague);
    colleague.setMediator(this);
  }

  // 中转消息
  relay(message, sender) {
    this.colleagues.forEach(colleague => {
      // 不发给发送者自己
      if (colleague !== sender) {
        colleague.receive(message, sender);
      }
    });
  }
}

class Colleague {
  constructor(name) {
    this.name = name;
    this.mediator = null;
  }

  setMediator(mediator) {
    this.mediator = mediator;
  }

  send(message) {
    console.log(`${this.name} sends: ${message}`);
    this.mediator.relay(message, this);
  }

  receive(message, sender) {
    console.log(`${this.name} received from ${sender.name}: ${message}`);
  }
}

// 使用
const mediator = new Mediator();

const alice = new Colleague('Alice');
const bob = new Colleague('Bob');
const charlie = new Colleague('Charlie');

mediator.register(alice);
mediator.register(bob);
mediator.register(charlie);

alice.send('Hello everyone!');
// 输出:
// Alice sends: Hello everyone!
// Bob received from Alice: Hello everyone!
// Charlie received from Alice: Hello everyone!
```

### 中介者模式 vs 观察者模式

```javascript
// 对比

// 观察者模式：
// - 一对多关系
// - Subject直接通知Observers
// - 适合事件通知场景

// 中介者模式：
// - 多对多关系
// - 所有通信通过Mediator
// - 适合复杂对象交互场景

/*
| 特性       | 观察者模式          | 中介者模式           |
|-----------|--------------------|--------------------|
| 关系       | 一对多             | 多对多              |
| 通信       | Subject → Observers| 通过中介者中转       |
| 目的       | 事件通知           | 解耦复杂交互        |
| Subject   | 知道所有Observers  | 不知道其他对象      |
| 复杂度     | 低                 | 中等               |
*/
```

## 5. 中介者模式完整实现

### 基础版实现

```javascript
// 完整的中介者模式实现
class Mediator {
  constructor() {
    this.colleagues = new Map();
  }

  // 注册同事对象
  register(name, colleague) {
    this.colleagues.set(name, colleague);
    colleague.setMediator(this);
  }

  // 注销
  unregister(name) {
    this.colleagues.delete(name);
  }

  // 发送消息（点对点）
  send(message, from, to) {
    const colleague = this.colleagues.get(to);

    if (!colleague) {
      console.error(`Colleague "${to}" not found`);
      return;
    }

    colleague.receive(message, from);
  }

  // 广播消息（一对多）
  broadcast(message, sender) {
    this.colleagues.forEach((colleague, name) => {
      if (name !== sender) {
        colleague.receive(message, sender);
      }
    });
  }

  // 多播消息（一对部分）
  multicast(message, sender, recipients) {
    recipients.forEach(name => {
      const colleague = this.colleagues.get(name);
      if (colleague && name !== sender) {
        colleague.receive(message, sender);
      }
    });
  }
}

class Colleague {
  constructor(name) {
    this.name = name;
    this.mediator = null;
  }

  setMediator(mediator) {
    this.mediator = mediator;
  }

  // 发送点对点消息
  sendTo(message, recipient) {
    console.log(`[${this.name}] → [${recipient}]: ${message}`);
    this.mediator.send(message, this.name, recipient);
  }

  // 广播消息
  broadcast(message) {
    console.log(`[${this.name}] broadcasts: ${message}`);
    this.mediator.broadcast(message, this.name);
  }

  // 多播消息
  multicast(message, recipients) {
    console.log(`[${this.name}] multicasts to ${recipients.join(', ')}: ${message}`);
    this.mediator.multicast(message, this.name, recipients);
  }

  // 接收消息
  receive(message, sender) {
    console.log(`[${this.name}] received from [${sender}]: ${message}`);
  }
}

// 使用
const mediator = new Mediator();

const alice = new Colleague('Alice');
const bob = new Colleague('Bob');
const charlie = new Colleague('Charlie');

mediator.register('Alice', alice);
mediator.register('Bob', bob);
mediator.register('Charlie', charlie);

// 点对点
alice.sendTo('Hi Bob!', 'Bob');
// 输出:
// [Alice] → [Bob]: Hi Bob!
// [Bob] received from [Alice]: Hi Bob!

// 广播
bob.broadcast('Hello everyone!');
// 输出:
// [Bob] broadcasts: Hello everyone!
// [Alice] received from [Bob]: Hello everyone!
// [Charlie] received from [Bob]: Hello everyone!

// 多播
charlie.multicast('Private message', ['Alice', 'Bob']);
// 输出:
// [Charlie] multicasts to Alice, Bob: Private message
// [Alice] received from [Charlie]: Private message
// [Bob] received from [Charlie]: Private message
```

### 增强版实现（带消息过滤和路由）

```javascript
// 增强的中介者模式
class EnhancedMediator {
  constructor() {
    this.colleagues = new Map();
    this.routes = new Map();  // 消息路由规则
    this.filters = [];        // 消息过滤器
  }

  register(name, colleague) {
    this.colleagues.set(name, colleague);
    colleague.setMediator(this);
  }

  unregister(name) {
    this.colleagues.delete(name);
    this.routes.delete(name);
  }

  // 添加消息过滤器
  addFilter(filter) {
    this.filters.push(filter);
  }

  // 设置路由规则
  setRoute(from, to, condition = null) {
    if (!this.routes.has(from)) {
      this.routes.set(from, []);
    }

    this.routes.get(from).push({ to, condition });
  }

  // 发送消息（支持路由和过滤）
  send(message, from, to = null) {
    // 应用过滤器
    for (const filter of this.filters) {
      if (!filter(message, from, to)) {
        console.log('Message filtered');
        return;
      }
    }

    // 如果指定了接收者
    if (to) {
      this._deliver(message, from, to);
      return;
    }

    // 否则根据路由规则发送
    const routes = this.routes.get(from);
    if (routes) {
      routes.forEach(({ to, condition }) => {
        if (!condition || condition(message)) {
          this._deliver(message, from, to);
        }
      });
    }
  }

  _deliver(message, from, to) {
    const colleague = this.colleagues.get(to);
    if (colleague) {
      colleague.receive(message, from);
    }
  }
}

// 使用
const mediator = new EnhancedMediator();

const server = new Colleague('Server');
const client1 = new Colleague('Client1');
const client2 = new Colleague('Client2');
const logger = new Colleague('Logger');

mediator.register('Server', server);
mediator.register('Client1', client1);
mediator.register('Client2', client2);
mediator.register('Logger', logger);

// 设置路由规则
// Server发送的消息路由到所有Client
mediator.setRoute('Server', 'Client1');
mediator.setRoute('Server', 'Client2');

// 所有消息都路由到Logger
['Server', 'Client1', 'Client2'].forEach(from => {
  mediator.setRoute(from, 'Logger');
});

// 条件路由：只有priority > 5的消息才发给Client1
mediator.setRoute('Server', 'Client1',
  msg => msg.priority > 5
);

// 添加过滤器：过滤掉空消息
mediator.addFilter((message) => {
  return message && message.content;
});

// 发送消息
server.mediator.send({ content: 'Update', priority: 10 }, 'Server');
// Client1和Client2都会收到（priority > 5）

server.mediator.send({ content: 'Info', priority: 3 }, 'Server');
// 只有Client2会收到（priority < 5，被Client1的条件过滤）
```

## 6. 中介者模式实战案例

### 案例1：聊天室

```javascript
// 实现一个完整的聊天室
class ChatRoom {
  constructor(name) {
    this.name = name;
    this.users = new Map();
    this.history = [];
  }

  // 用户加入
  join(user) {
    this.users.set(user.name, user);
    user.setChatRoom(this);

    // 通知其他用户
    this.broadcast({
      type: 'system',
      content: `${user.name} joined the room`
    }, user);

    // 发送历史消息给新用户
    this.history.forEach(msg => {
      user.receive(msg);
    });
  }

  // 用户离开
  leave(user) {
    this.users.delete(user.name);

    this.broadcast({
      type: 'system',
      content: `${user.name} left the room`
    }, user);
  }

  // 发送消息
  send(message, sender, recipient = null) {
    const msg = {
      type: 'message',
      from: sender.name,
      to: recipient,
      content: message,
      timestamp: Date.now()
    };

    // 保存到历史
    this.history.push(msg);

    if (recipient) {
      // 私聊
      const user = this.users.get(recipient);
      if (user) {
        user.receive(msg);
        sender.receive(msg);  // 发送者也看到
      } else {
        sender.receive({
          type: 'error',
          content: `User ${recipient} not found`
        });
      }
    } else {
      // 群聊
      this.broadcast(msg, sender);
    }
  }

  // 广播
  broadcast(message, except = null) {
    this.users.forEach(user => {
      if (user !== except) {
        user.receive(message);
      }
    });
  }

  // 获取在线用户列表
  getUsers() {
    return Array.from(this.users.keys());
  }
}

class User {
  constructor(name) {
    this.name = name;
    this.chatRoom = null;
  }

  setChatRoom(chatRoom) {
    this.chatRoom = chatRoom;
  }

  // 发送消息
  send(message, recipient = null) {
    if (!this.chatRoom) {
      console.error('Not in a chat room');
      return;
    }

    this.chatRoom.send(message, this, recipient);
  }

  // 接收消息
  receive(message) {
    switch (message.type) {
      case 'system':
        console.log(`[SYSTEM] ${message.content}`);
        break;

      case 'message':
        if (message.to) {
          console.log(`[PRIVATE from ${message.from}] ${message.content}`);
        } else {
          console.log(`[${message.from}] ${message.content}`);
        }
        break;

      case 'error':
        console.error(`[ERROR] ${message.content}`);
        break;
    }
  }
}

// 使用
const room = new ChatRoom('General');

const alice = new User('Alice');
const bob = new User('Bob');
const charlie = new User('Charlie');

room.join(alice);
room.join(bob);
room.join(charlie);

// 群聊
alice.send('Hello everyone!');
// 输出:
// [Alice] Hello everyone!  (Bob看到)
// [Alice] Hello everyone!  (Charlie看到)

// 私聊
bob.send('Hi Alice, how are you?', 'Alice');
// 输出:
// [PRIVATE from Bob] Hi Alice, how are you?  (Alice看到)
// [PRIVATE from Bob] Hi Alice, how are you?  (Bob自己也看到)

// 离开
charlie.leave();
// 输出:
// [SYSTEM] Charlie left the room
```

### 案例2：飞机塔台控制

```javascript
// 飞机塔台控制系统
class AirTrafficControl {
  constructor() {
    this.airplanes = new Map();
    this.runways = new Map([
      ['Runway-1', { available: true, airplane: null }],
      ['Runway-2', { available: true, airplane: null }],
      ['Runway-3', { available: true, airplane: null }]
    ]);
    this.waitingQueue = [];
  }

  // 注册飞机
  register(airplane) {
    this.airplanes.set(airplane.id, airplane);
    airplane.setControl(this);
    console.log(`[ATC] ${airplane.id} registered`);
  }

  // 请求降落
  requestLanding(airplane) {
    console.log(`[ATC] ${airplane.id} requests landing`);

    // 查找可用跑道
    const runway = this._findAvailableRunway();

    if (runway) {
      this._assignRunway(airplane, runway);
    } else {
      // 加入等待队列
      this.waitingQueue.push(airplane);
      airplane.notify(`Please hold. Current position: ${this.waitingQueue.length}`);
    }
  }

  // 请求起飞
  requestTakeoff(airplane) {
    console.log(`[ATC] ${airplane.id} requests takeoff`);

    const runway = this._findAvailableRunway();

    if (runway) {
      this._assignRunway(airplane, runway);
    } else {
      airplane.notify('All runways busy. Please wait.');
    }
  }

  // 释放跑道
  releaseRunway(airplane) {
    // 查找飞机占用的跑道
    for (const [name, runway] of this.runways) {
      if (runway.airplane === airplane) {
        runway.available = true;
        runway.airplane = null;

        console.log(`[ATC] ${name} released by ${airplane.id}`);

        // 处理等待队列
        if (this.waitingQueue.length > 0) {
          const waiting = this.waitingQueue.shift();
          this._assignRunway(waiting, runway);
        }

        break;
      }
    }
  }

  // 查找可用跑道
  _findAvailableRunway() {
    for (const [name, runway] of this.runways) {
      if (runway.available) {
        return { name, runway };
      }
    }
    return null;
  }

  // 分配跑道
  _assignRunway(airplane, { name, runway }) {
    runway.available = false;
    runway.airplane = airplane;

    airplane.notify(`Cleared to use ${name}`);
  }

  // 紧急情况
  emergency(airplane, message) {
    console.log(`[ATC] EMERGENCY from ${airplane.id}: ${message}`);

    // 清空最近的跑道
    const firstRunway = this.runways.entries().next().value;
    const [name, runway] = firstRunway;

    if (runway.airplane) {
      runway.airplane.notify('Emergency! Please hold.');
    }

    runway.available = false;
    runway.airplane = airplane;

    airplane.notify(`Emergency clearance granted. Use ${name} immediately!`);
  }
}

class Airplane {
  constructor(id) {
    this.id = id;
    this.control = null;
  }

  setControl(control) {
    this.control = control;
  }

  // 请求降落
  requestLanding() {
    this.control.requestLanding(this);
  }

  // 请求起飞
  requestTakeoff() {
    this.control.requestTakeoff(this);
  }

  // 降落完成
  landingComplete() {
    console.log(`[${this.id}] Landing complete`);
    this.control.releaseRunway(this);
  }

  // 起飞完成
  takeoffComplete() {
    console.log(`[${this.id}] Takeoff complete`);
    this.control.releaseRunway(this);
  }

  // 紧急情况
  emergency(message) {
    this.control.emergency(this, message);
  }

  // 接收通知
  notify(message) {
    console.log(`[${this.id}] Received: ${message}`);
  }
}

// 使用
const atc = new AirTrafficControl();

const flight1 = new Airplane('Flight-001');
const flight2 = new Airplane('Flight-002');
const flight3 = new Airplane('Flight-003');
const flight4 = new Airplane('Flight-004');

atc.register(flight1);
atc.register(flight2);
atc.register(flight3);
atc.register(flight4);

// 请求降落
flight1.requestLanding();
// 输出:
// [ATC] Flight-001 requests landing
// [Flight-001] Received: Cleared to use Runway-1

flight2.requestLanding();
// 输出:
// [ATC] Flight-002 requests landing
// [Flight-002] Received: Cleared to use Runway-2

flight3.requestLanding();
// 输出:
// [ATC] Flight-003 requests landing
// [Flight-003] Received: Cleared to use Runway-3

flight4.requestLanding();
// 输出:
// [ATC] Flight-004 requests landing
// [Flight-004] Received: Please hold. Current position: 1

// 飞机1降落完成
flight1.landingComplete();
// 输出:
// [Flight-001] Landing complete
// [ATC] Runway-1 released by Flight-001
// [Flight-004] Received: Cleared to use Runway-1

// 紧急情况
const emergency = new Airplane('Emergency-999');
atc.register(emergency);
emergency.emergency('Engine failure!');
// 输出:
// [ATC] EMERGENCY from Emergency-999: Engine failure!
// [Flight-002] Received: Emergency! Please hold.
// [Emergency-999] Received: Emergency clearance granted. Use Runway-1 immediately!
```

## 7. 两种模式结合使用

```javascript
// 在实际项目中，观察者模式和中介者模式经常结合使用

// 示例：前端组件通信系统
class ComponentMediator {
  constructor() {
    this.components = new Map();
    this.eventBus = new EventEmitter();  // 观察者模式
  }

  // 注册组件
  register(name, component) {
    this.components.set(name, component);
    component.setMediator(this);
  }

  // 通过中介者发送消息
  send(message, from, to) {
    const component = this.components.get(to);
    if (component) {
      component.receive(message, from);
    }
  }

  // 通过事件总线广播事件（观察者模式）
  emit(event, data) {
    this.eventBus.emit(event, data);
  }

  // 监听事件
  on(event, handler) {
    this.eventBus.on(event, handler);
  }
}

// 使用
const mediator = new ComponentMediator();

class Component {
  constructor(name) {
    this.name = name;
    this.mediator = null;
  }

  setMediator(mediator) {
    this.mediator = mediator;

    // 订阅全局事件
    this.mediator.on('global:update', data => {
      console.log(`[${this.name}] received global update:`, data);
    });
  }

  // 发送点对点消息（中介者模式）
  sendTo(message, target) {
    this.mediator.send(message, this.name, target);
  }

  // 广播事件（观察者模式）
  broadcast(event, data) {
    this.mediator.emit(event, data);
  }

  receive(message, from) {
    console.log(`[${this.name}] received from ${from}:`, message);
  }
}

const header = new Component('Header');
const sidebar = new Component('Sidebar');
const content = new Component('Content');

mediator.register('Header', header);
mediator.register('Sidebar', sidebar);
mediator.register('Content', content);

// 点对点通信（中介者模式）
header.sendTo('Navigate to /about', 'Content');

// 全局广播（观察者模式）
sidebar.broadcast('global:update', { theme: 'dark' });
// 所有组件都会收到
```

观察者模式和中介者模式是前端架构设计的核心模式，深入理解它们对于构建可维护的大型应用至关重要！
