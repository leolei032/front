# 前端性能优化全面分析

## 1. 性能指标（Web Vitals）

```javascript
// Core Web Vitals - Google的核心性能指标

// 1. LCP (Largest Contentful Paint) - 最大内容绘制
// 衡量：页面主要内容加载时间
// 标准：< 2.5s (Good), 2.5-4s (Needs Improvement), > 4s (Poor)

// 2. FID (First Input Delay) - 首次输入延迟
// 衡量：用户首次交互到浏览器响应的时间
// 标准：< 100ms (Good), 100-300ms (Needs Improvement), > 300ms (Poor)

// 3. CLS (Cumulative Layout Shift) - 累积布局偏移
// 衡量：页面视觉稳定性
// 标准：< 0.1 (Good), 0.1-0.25 (Needs Improvement), > 0.25 (Poor)

// 监控性能指标
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics({ name, value, id }) {
  // 发送到分析服务
  ga('send', 'event', {
    eventCategory: 'Web Vitals',
    eventAction: name,
    eventValue: Math.round(value),
    eventLabel: id
  });
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getLCP(sendToAnalytics);

// Performance API
const perfEntries = performance.getEntriesByType('navigation')[0];
console.log('DNS:', perfEntries.domainLookupEnd - perfEntries.domainLookupStart);
console.log('TCP:', perfEntries.connectEnd - perfEntries.connectStart);
console.log('Request:', perfEntries.responseStart - perfEntries.requestStart);
console.log('Response:', perfEntries.responseEnd - perfEntries.responseStart);
console.log('DOM Parse:', perfEntries.domContentLoadedEventEnd - perfEntries.domContentLoadedEventStart);
console.log('Load:', perfEntries.loadEventEnd - perfEntries.loadEventStart);
```

## 2. 加载性能优化

### 资源优化

```javascript
// 1. 代码分割 (Code Splitting)
// React Lazy + Suspense
const Home = React.lazy(() => import('./Home'));
const About = React.lazy(() => import('./About'));

<Suspense fallback={<Loading />}>
  <Route path="/" component={Home} />
  <Route path="/about" component={About} />
</Suspense>

// 2. Tree Shaking
// package.json
{
  "sideEffects": false  // 启用tree shaking
}

// 3. 压缩
// 使用 terser/uglify 压缩JS
// 使用 cssnano 压缩CSS
// 使用 imagemin 压缩图片

// 4. Gzip/Brotli压缩
// Nginx配置
gzip on;
gzip_types text/plain text/css application/json application/javascript;
brotli on;
brotli_types text/plain text/css application/json;

// 5. CDN加速
<script src="https://cdn.example.com/react.min.js"></script>

// 6. 预加载关键资源
<link rel="preload" href="/critical.css" as="style">
<link rel="preload" href="/critical.js" as="script">
<link rel="prefetch" href="/next-page.js">  // 空闲时预加载
<link rel="preconnect" href="https://api.example.com">  // 预连接

// 7. 懒加载图片
<img loading="lazy" src="image.jpg" alt="Description">

// Intersection Observer实现
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      observer.unobserve(img);
    }
  });
});

document.querySelectorAll('img[data-src]').forEach(img => {
  observer.observe(img);
});
```

### 网络优化

```javascript
// 1. HTTP/2多路复用
// 配置服务器支持HTTP/2

// 2. Service Worker缓存
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(response => {
      return response || fetch(event.request);
    })
  );
});

// 3. 资源提示
<link rel="dns-prefetch" href="//example.com">
<link rel="preconnect" href="//example.com">
<link rel="prefetch" href="/future-page.html">
<link rel="prerender" href="/next-page.html">

// 4. 减少请求数
// - 合并小文件
// - 使用CSS Sprites
// - 内联关键CSS
<style>
  /* Critical CSS */
  .above-fold { ... }
</style>
```

## 3. 渲染性能优化

### React优化

```javascript
// 1. React.memo - 避免不必要的重渲染
const MemoizedComponent = React.memo(({ data }) => {
  return <div>{data}</div>;
}, (prevProps, nextProps) => {
  return prevProps.data === nextProps.data;
});

// 2. useMemo - 缓存计算结果
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(a, b);
}, [a, b]);

// 3. useCallback - 缓存函数引用
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);

// 4. 虚拟列表
import { FixedSizeList } from 'react-window';

<FixedSizeList
  height={400}
  itemCount={1000}
  itemSize={35}
  width={300}
>
  {({ index, style }) => (
    <div style={style}>Row {index}</div>
  )}
</FixedSizeList>

// 5. 防抖节流
const debouncedSearch = useMemo(
  () => debounce((value) => {
    searchAPI(value);
  }, 300),
  []
);
```

### DOM优化

```javascript
// 1. 减少DOM操作
// ✗ 差
for (let i = 0; i < 1000; i++) {
  document.body.appendChild(createDiv());
}

// ✓ 好
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  fragment.appendChild(createDiv());
}
document.body.appendChild(fragment);

// 2. 避免强制同步布局
// ✗ 差
divs.forEach(div => {
  div.style.width = div.offsetWidth + 10 + 'px';  // 读写交替
});

// ✓ 好
const widths = divs.map(div => div.offsetWidth);  // 批量读
divs.forEach((div, i) => {
  div.style.width = widths[i] + 10 + 'px';  // 批量写
});

// 3. 使用requestAnimationFrame
function animate() {
  // 动画逻辑
  element.style.transform = `translateX(${position}px)`;

  requestAnimationFrame(animate);
}

// 4. CSS containment
.container {
  contain: layout style paint;  // 隔离渲染
}

// 5. will-change提示
.element {
  will-change: transform;  // 提前告知浏览器
}
```

## 4. JavaScript优化

```javascript
// 1. 避免长任务
// 使用Web Workers处理计算密集型任务
const worker = new Worker('worker.js');
worker.postMessage({ data: largeDataset });
worker.onmessage = (e) => {
  console.log('Result:', e.data);
};

// 2. 时间切片
function processLargeArray(array) {
  const chunk = 100;
  let index = 0;

  function processChunk() {
    const end = Math.min(index + chunk, array.length);

    for (let i = index; i < end; i++) {
      // 处理数组项
      process(array[i]);
    }

    index = end;

    if (index < array.length) {
      requestIdleCallback(processChunk);
    }
  }

  processChunk();
}

// 3. 避免内存泄漏
// ✓ 清理定时器
useEffect(() => {
  const timer = setInterval(() => {}, 1000);
  return () => clearInterval(timer);
}, []);

// ✓ 清理事件监听
useEffect(() => {
  const handler = () => {};
  window.addEventListener('resize', handler);
  return () => window.removeEventListener('resize', handler);
}, []);

// ✓ 清理DOM引用
useEffect(() => {
  const element = document.getElementById('my-element');
  // ...
  return () => {
    // 清理引用
    element = null;
  };
}, []);

// 4. 优化循环
// ✗ 差
for (let i = 0; i < arr.length; i++) {  // 每次都读length
  process(arr[i]);
}

// ✓ 好
const len = arr.length;
for (let i = 0; i < len; i++) {
  process(arr[i]);
}
```

## 5. 资源加载策略

```javascript
// 1. 关键渲染路径优化
// HTML结构
<head>
  <!-- 1. 关键CSS内联 -->
  <style>/* Critical CSS */</style>

  <!-- 2. 预连接到外部资源 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">

  <!-- 3. 异步加载字体 -->
  <link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>
</head>
<body>
  <!-- 内容 -->

  <!-- 4. 脚本放底部或使用defer/async -->
  <script defer src="/main.js"></script>
</body>

// 2. 字体优化
// CSS
@font-face {
  font-family: 'MyFont';
  src: url('/fonts/myfont.woff2') format('woff2');
  font-display: swap;  // 使用系统字体直到自定义字体加载完成
}

// 3. 图片优化策略
// 响应式图片
<picture>
  <source srcset="image-large.webp" media="(min-width: 1200px)" type="image/webp">
  <source srcset="image-medium.webp" media="(min-width: 768px)" type="image/webp">
  <img src="image-small.jpg" alt="Description">
</picture>

// 渐进式图片加载
<img
  src="thumbnail.jpg"
  data-src="full-size.jpg"
  class="lazy-load"
  alt="Description"
>

// 4. 视频优化
<video preload="metadata" poster="poster.jpg">
  <source src="video.webm" type="video/webm">
  <source src="video.mp4" type="video/mp4">
</video>
```

## 6. 构建优化

```javascript
// Webpack配置优化

module.exports = {
  mode: 'production',

  // 1. 代码分割
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10
        },
        common: {
          minChunks: 2,
          name: 'common',
          priority: 5
        }
      }
    },
    // 运行时代码单独打包
    runtimeChunk: 'single'
  },

  // 2. Tree Shaking
  optimization: {
    usedExports: true,
    sideEffects: false
  },

  // 3. 压缩
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true  // 删除console
          }
        }
      })
    ]
  },

  // 4. 长期缓存
  output: {
    filename: '[name].[contenthash].js',
    chunkFilename: '[name].[contenthash].chunk.js'
  },

  // 5. 模块解析优化
  resolve: {
    extensions: ['.js', '.jsx'],
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  },

  // 6. 构建性能
  cache: {
    type: 'filesystem'  // 使用文件系统缓存
  }
};
```

## 7. 监控和分析

```javascript
// 1. Performance Observer
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    console.log(`${entry.name}: ${entry.duration}ms`);
  }
});

observer.observe({ entryTypes: ['measure', 'navigation', 'resource'] });

// 2. 自定义性能标记
performance.mark('start-render');
// ... 渲染逻辑
performance.mark('end-render');
performance.measure('render-time', 'start-render', 'end-render');

// 3. 长任务检测
const longTaskObserver = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    console.warn('Long task detected:', entry.duration);
  }
});

longTaskObserver.observe({ entryTypes: ['longtask'] });

// 4. 错误监控
window.addEventListener('error', (event) => {
  sendToAnalytics({
    type: 'error',
    message: event.message,
    stack: event.error.stack
  });
});

window.addEventListener('unhandledrejection', (event) => {
  sendToAnalytics({
    type: 'promise-rejection',
    reason: event.reason
  });
});

// 5. 资源加载监控
const resourceObserver = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.duration > 1000) {
      console.warn('Slow resource:', entry.name, entry.duration);
    }
  }
});

resourceObserver.observe({ entryTypes: ['resource'] });
```

## 8. 性能优化清单

```javascript
/**
 * 前端性能优化清单
 *
 * 【加载优化】
 * ✓ 启用HTTP/2
 * ✓ 启用Gzip/Brotli压缩
 * ✓ 使用CDN
 * ✓ 代码分割（路由级别）
 * ✓ Tree Shaking
 * ✓ 压缩资源（JS/CSS/图片）
 * ✓ 懒加载图片和组件
 * ✓ 预加载关键资源
 * ✓ 使用Service Worker缓存
 *
 * 【渲染优化】
 * ✓ 使用React.memo避免重渲染
 * ✓ 使用useMemo缓存计算结果
 * ✓ 使用useCallback缓存函数
 * ✓ 虚拟列表处理大数据
 * ✓ 防抖节流用户输入
 * ✓ 批量更新DOM
 * ✓ 避免强制同步布局
 * ✓ 使用CSS contain
 *
 * 【JavaScript优化】
 * ✓ 使用Web Workers处理密集计算
 * ✓ 时间切片处理大任务
 * ✓ 避免内存泄漏
 * ✓ 优化循环和条件判断
 *
 * 【资源优化】
 * ✓ 内联关键CSS
 * ✓ 异步加载字体（font-display: swap）
 * ✓ 响应式图片
 * ✓ WebP格式图片
 * ✓ 视频懒加载
 *
 * 【监控】
 * ✓ 监控Core Web Vitals
 * ✓ 性能标记和测量
 * ✓ 错误监控
 * ✓ 资源加载监控
 */
```

前端性能优化是一个系统工程，需要从加载、渲染、JavaScript执行、资源管理等多个维度综合考虑和实施！
