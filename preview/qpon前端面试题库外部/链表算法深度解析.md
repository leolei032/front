# 链表算法深度解析

> 链表是前端面试中常考的数据结构题目，主要考察对数据结构的理解和算法实现能力

---

## 目录

1. [链表基础知识](#1-链表基础知识)
2. [判断链表是否有环](#2-判断链表是否有环)
3. [链表反转](#3-链表反转)
4. [其他常见链表问题](#4-其他常见链表问题)
5. [实战应用](#5-实战应用)

---

## 1. 链表基础知识

### 1.1 什么是链表

链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。

```javascript
// 链表节点定义
class ListNode {
    constructor(val, next = null) {
        this.val = val;      // 节点值
        this.next = next;    // 指向下一个节点的指针
    }
}

// 创建链表示例
const node1 = new ListNode(1);
const node2 = new ListNode(2);
const node3 = new ListNode(3);
node1.next = node2;
node2.next = node3;

// 链表结构: 1 -> 2 -> 3 -> null
```

### 1.2 链表 vs 数组

| 特性 | 数组 | 链表 |
|------|------|------|
| 存储方式 | 连续内存空间 | 非连续内存空间 |
| 访问元素 | O(1) 随机访问 | O(n) 顺序访问 |
| 插入/删除 | O(n) 需要移动元素 | O(1) 只需改变指针 |
| 内存利用 | 需要预分配或扩容 | 动态分配，灵活 |
| 缓存友好 | 是 | 否 |

### 1.3 链表的类型

```javascript
// 1. 单向链表
class SinglyListNode {
    constructor(val) {
        this.val = val;
        this.next = null;
    }
}

// 2. 双向链表
class DoublyListNode {
    constructor(val) {
        this.val = val;
        this.prev = null;  // 前驱节点
        this.next = null;  // 后继节点
    }
}

// 3. 循环链表（最后一个节点指向第一个节点）
function createCircularList(values) {
    if (!values.length) return null;

    const head = new ListNode(values[0]);
    let current = head;

    for (let i = 1; i < values.length; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }

    // 形成环
    current.next = head;
    return head;
}
```

---

## 2. 判断链表是否有环

### 2.1 问题描述

给定一个链表，判断链表中是否有环。

**什么是环？**
- 链表中某个节点的 next 指针指向了之前出现过的节点
- 导致链表形成闭环，无法到达 null

```
示例1：有环
1 -> 2 -> 3 -> 4
     ↑         ↓
     ←---------←

示例2：无环
1 -> 2 -> 3 -> 4 -> null
```

### 2.2 解法一：哈希表法

**思路**：
- 遍历链表，用 Set 记录访问过的节点
- 如果遇到已访问过的节点，说明有环
- 如果遍历到 null，说明无环

```javascript
/**
 * 判断链表是否有环 - 哈希表法
 * @param {ListNode} head - 链表头节点
 * @return {boolean}
 *
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 */
function hasCycle_HashSet(head) {
    // 空链表无环
    if (!head) return false;

    const visited = new Set();
    let current = head;

    while (current) {
        // 如果当前节点已访问过，说明有环
        if (visited.has(current)) {
            return true;
        }

        // 记录已访问节点
        visited.add(current);
        current = current.next;
    }

    // 遍历到 null，无环
    return false;
}

// 测试
function createCycleList() {
    const node1 = new ListNode(1);
    const node2 = new ListNode(2);
    const node3 = new ListNode(3);
    const node4 = new ListNode(4);

    node1.next = node2;
    node2.next = node3;
    node3.next = node4;
    node4.next = node2; // 形成环

    return node1;
}

console.log(hasCycle_HashSet(createCycleList())); // true
```

**优缺点**：
- ✅ 思路简单，容易理解
- ✅ 一定能检测出环
- ❌ 需要额外 O(n) 空间存储访问过的节点

### 2.3 解法二：快慢指针法（Floyd判圈算法）⭐⭐⭐

**思路**：
- 使用两个指针，一快一慢
- 慢指针每次走一步，快指针每次走两步
- 如果有环，快指针最终会追上慢指针
- 如果无环，快指针会先到达 null

**为什么快指针一定能追上慢指针？**
- 假设慢指针在环内，快指针也在环内
- 每次循环，快指针和慢指针的距离减少1
- 最终距离会减少到0，即相遇

```javascript
/**
 * 判断链表是否有环 - 快慢指针法（最优解）
 * @param {ListNode} head
 * @return {boolean}
 *
 * 时间复杂度：O(n)
 * 空间复杂度：O(1) ✅
 */
function hasCycle(head) {
    // 空链表或只有一个节点无环
    if (!head || !head.next) {
        return false;
    }

    // 初始化快慢指针
    let slow = head;
    let fast = head;

    // 快指针能继续走两步
    while (fast && fast.next) {
        slow = slow.next;           // 慢指针走一步
        fast = fast.next.next;      // 快指针走两步

        // 快慢指针相遇，说明有环
        if (slow === fast) {
            return true;
        }
    }

    // 快指针到达末尾，无环
    return false;
}

// 测试用例
function test_hasCycle() {
    // 测试1：有环链表
    const list1 = createCycleList();
    console.log('有环链表:', hasCycle(list1)); // true

    // 测试2：无环链表
    const list2 = new ListNode(1);
    list2.next = new ListNode(2);
    list2.next.next = new ListNode(3);
    console.log('无环链表:', hasCycle(list2)); // false

    // 测试3：空链表
    console.log('空链表:', hasCycle(null)); // false

    // 测试4：单节点链表
    const list3 = new ListNode(1);
    console.log('单节点:', hasCycle(list3)); // false

    // 测试5：单节点自环
    const list4 = new ListNode(1);
    list4.next = list4;
    console.log('单节点自环:', hasCycle(list4)); // true
}

test_hasCycle();
```

### 2.4 进阶：找到环的入口节点

如果链表有环，如何找到环的入口节点？

```javascript
/**
 * 找到环的入口节点
 * @param {ListNode} head
 * @return {ListNode}
 *
 * 原理：
 * 1. 快慢指针相遇后，让一个指针从head开始
 * 2. 两个指针都每次走一步
 * 3. 再次相遇的地方就是环的入口
 *
 * 数学证明：
 * 设：head到环入口距离为a，环入口到相遇点距离为b，环长为c
 * 快指针走的距离：a + b + n*c (n为快指针在环内转的圈数)
 * 慢指针走的距离：a + b
 * 因为快指针速度是慢指针2倍：2(a+b) = a + b + n*c
 * 化简得：a = n*c - b = (n-1)*c + (c-b)
 * 意味着从head到入口的距离 = 从相遇点再走(c-b)的距离
 */
function detectCycle(head) {
    if (!head || !head.next) return null;

    // 第一步：判断是否有环
    let slow = head;
    let fast = head;
    let hasCycleFlag = false;

    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;

        if (slow === fast) {
            hasCycleFlag = true;
            break;
        }
    }

    // 无环
    if (!hasCycleFlag) return null;

    // 第二步：找环的入口
    // 让一个指针从head开始，另一个从相遇点开始
    // 都每次走一步，相遇点就是环入口
    let ptr1 = head;
    let ptr2 = slow; // 或者 fast，都在相遇点

    while (ptr1 !== ptr2) {
        ptr1 = ptr1.next;
        ptr2 = ptr2.next;
    }

    return ptr1; // 环的入口节点
}

// 测试
function test_detectCycle() {
    const node1 = new ListNode(1);
    const node2 = new ListNode(2);
    const node3 = new ListNode(3);
    const node4 = new ListNode(4);
    const node5 = new ListNode(5);

    node1.next = node2;
    node2.next = node3;
    node3.next = node4;
    node4.next = node5;
    node5.next = node3; // 环入口是node3

    const entry = detectCycle(node1);
    console.log('环入口节点值:', entry ? entry.val : null); // 3
}

test_detectCycle();
```

---

## 3. 链表反转

### 3.1 问题描述

给定一个单链表，将其反转。

```
输入：1 -> 2 -> 3 -> 4 -> 5 -> null
输出：5 -> 4 -> 3 -> 2 -> 1 -> null
```

### 3.2 解法一：迭代法（最常用）⭐⭐⭐

**思路**：
- 使用三个指针：prev（前一个节点）、current（当前节点）、next（下一个节点）
- 遍历链表，逐个反转节点的指针方向

```javascript
/**
 * 反转链表 - 迭代法
 * @param {ListNode} head
 * @return {ListNode}
 *
 * 时间复杂度：O(n)
 * 空间复杂度：O(1)
 */
function reverseList(head) {
    // 空链表或单节点，直接返回
    if (!head || !head.next) {
        return head;
    }

    let prev = null;        // 前一个节点
    let current = head;     // 当前节点

    while (current) {
        // 1. 保存下一个节点
        const next = current.next;

        // 2. 反转当前节点的指针
        current.next = prev;

        // 3. 移动指针
        prev = current;
        current = next;
    }

    // prev现在指向原链表的最后一个节点，即新链表的头节点
    return prev;
}

// 详细图解过程
function reverseList_Detailed(head) {
    console.log('=== 链表反转详细过程 ===');

    let prev = null;
    let current = head;
    let step = 0;

    // 打印初始状态
    console.log(`初始: ${listToString(head)}`);

    while (current) {
        step++;
        const next = current.next;

        console.log(`\n步骤${step}:`);
        console.log(`  当前节点: ${current.val}`);
        console.log(`  下一个节点: ${next ? next.val : 'null'}`);

        // 反转指针
        current.next = prev;
        console.log(`  反转后: ${current.val}.next = ${prev ? prev.val : 'null'}`);

        // 移动指针
        prev = current;
        current = next;

        console.log(`  已反转部分: ${listToString(prev)}`);
    }

    console.log(`\n最终结果: ${listToString(prev)}`);
    return prev;
}

// 辅助函数：链表转字符串
function listToString(head) {
    const values = [];
    let current = head;
    let count = 0;

    while (current && count < 10) { // 防止环形链表无限循环
        values.push(current.val);
        current = current.next;
        count++;
    }

    return values.join(' -> ') + ' -> null';
}

// 测试
function test_reverseList() {
    // 创建测试链表: 1 -> 2 -> 3 -> 4 -> 5
    const head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);

    console.log('原链表:', listToString(head));

    const reversed = reverseList_Detailed(head);
    console.log('\n反转后:', listToString(reversed));
}

test_reverseList();
```

**执行过程图解**：

```
初始状态：
prev = null
current = 1 -> 2 -> 3 -> 4 -> 5 -> null

步骤1：
next = 2
1.next = null
prev = 1, current = 2
结果: null <- 1    2 -> 3 -> 4 -> 5 -> null

步骤2：
next = 3
2.next = 1
prev = 2, current = 3
结果: null <- 1 <- 2    3 -> 4 -> 5 -> null

步骤3：
next = 4
3.next = 2
prev = 3, current = 4
结果: null <- 1 <- 2 <- 3    4 -> 5 -> null

步骤4：
next = 5
4.next = 3
prev = 4, current = 5
结果: null <- 1 <- 2 <- 3 <- 4    5 -> null

步骤5：
next = null
5.next = 4
prev = 5, current = null
结果: null <- 1 <- 2 <- 3 <- 4 <- 5
```

### 3.3 解法二：递归法

**思路**：
- 递归到链表末尾
- 从后往前反转指针

```javascript
/**
 * 反转链表 - 递归法
 * @param {ListNode} head
 * @return {ListNode}
 *
 * 时间复杂度：O(n)
 * 空间复杂度：O(n) - 递归调用栈
 */
function reverseList_Recursive(head) {
    // 递归终止条件
    // 1. 空链表
    // 2. 只有一个节点
    // 3. 当前节点是最后一个节点
    if (!head || !head.next) {
        return head;
    }

    // 递归反转后面的链表
    // newHead是反转后的新头节点（原链表的最后一个节点）
    const newHead = reverseList_Recursive(head.next);

    // 反转当前节点
    // head.next是当前节点的下一个节点
    // 让下一个节点指向当前节点
    head.next.next = head;

    // 当前节点的next置为null
    head.next = null;

    return newHead;
}

// 递归过程详解
function reverseList_RecursiveDetailed(head, depth = 0) {
    const indent = '  '.repeat(depth);

    console.log(`${indent}进入递归 depth=${depth}, node=${head ? head.val : 'null'}`);

    if (!head || !head.next) {
        console.log(`${indent}到达末尾，返回 ${head ? head.val : 'null'}`);
        return head;
    }

    console.log(`${indent}递归处理 ${head.val} 的后续节点`);
    const newHead = reverseList_RecursiveDetailed(head.next, depth + 1);

    console.log(`${indent}反转节点 ${head.val}:`);
    console.log(`${indent}  ${head.next.val}.next = ${head.val}`);
    head.next.next = head;
    head.next = null;
    console.log(`${indent}  ${head.val}.next = null`);

    return newHead;
}

// 测试
function test_reverseList_Recursive() {
    const head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);

    console.log('原链表:', listToString(head));
    console.log('\n=== 递归反转过程 ===');
    const reversed = reverseList_RecursiveDetailed(head);
    console.log('\n反转后:', listToString(reversed));
}

test_reverseList_Recursive();
```

**递归调用栈图解**：

```
reverseList(1)
  ├─> reverseList(2)
  │     ├─> reverseList(3)
  │     │     ├─> reverseList(4)
  │     │     │     └─> return 4 (到达末尾)
  │     │     └─> 反转3: 4.next=3, 3.next=null, return 4
  │     └─> 反转2: 3.next=2, 2.next=null, return 4
  └─> 反转1: 2.next=1, 1.next=null, return 4

结果: 4 -> 3 -> 2 -> 1 -> null
```

### 3.4 解法三：使用栈

```javascript
/**
 * 反转链表 - 栈法
 * @param {ListNode} head
 * @return {ListNode}
 *
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 */
function reverseList_Stack(head) {
    if (!head) return null;

    // 1. 将所有节点压入栈
    const stack = [];
    let current = head;

    while (current) {
        stack.push(current);
        current = current.next;
    }

    // 2. 从栈中弹出节点，重新连接
    const newHead = stack.pop();
    current = newHead;

    while (stack.length > 0) {
        const node = stack.pop();
        current.next = node;
        current = node;
    }

    // 最后一个节点的next要置为null
    current.next = null;

    return newHead;
}
```

### 3.5 三种方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|-----------|-----------|------|------|
| 迭代法 | O(n) | O(1) | 空间最优，逻辑清晰 | 需要理解指针操作 |
| 递归法 | O(n) | O(n) | 代码简洁优雅 | 栈溢出风险，空间开销大 |
| 栈法 | O(n) | O(n) | 思路简单直观 | 空间开销大，实际不用 |

**面试推荐**：迭代法（最优解）

---

## 4. 其他常见链表问题

### 4.1 删除链表节点

```javascript
/**
 * 删除链表中指定值的所有节点
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
function deleteNode(head, val) {
    // 创建虚拟头节点，简化边界处理
    const dummy = new ListNode(0);
    dummy.next = head;

    let current = dummy;

    while (current.next) {
        if (current.next.val === val) {
            // 删除节点
            current.next = current.next.next;
        } else {
            current = current.next;
        }
    }

    return dummy.next;
}
```

### 4.2 合并两个有序链表

```javascript
/**
 * 合并两个有序链表
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
function mergeTwoLists(l1, l2) {
    const dummy = new ListNode(0);
    let current = dummy;

    while (l1 && l2) {
        if (l1.val <= l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }

    // 连接剩余节点
    current.next = l1 || l2;

    return dummy.next;
}
```

### 4.3 找链表的中间节点

```javascript
/**
 * 找链表的中间节点
 * @param {ListNode} head
 * @return {ListNode}
 *
 * 使用快慢指针
 * 慢指针每次走一步，快指针每次走两步
 * 快指针到末尾时，慢指针在中间
 */
function findMiddle(head) {
    if (!head) return null;

    let slow = head;
    let fast = head;

    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }

    return slow;
}
```

### 4.4 判断回文链表

```javascript
/**
 * 判断链表是否是回文
 * @param {ListNode} head
 * @return {boolean}
 *
 * 思路：
 * 1. 找到中间节点
 * 2. 反转后半部分
 * 3. 比较前后两部分
 */
function isPalindrome(head) {
    if (!head || !head.next) return true;

    // 1. 找中间节点
    let slow = head;
    let fast = head;

    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }

    // 2. 反转后半部分
    let secondHalf = reverseList(slow);

    // 3. 比较
    let p1 = head;
    let p2 = secondHalf;

    while (p2) {
        if (p1.val !== p2.val) {
            return false;
        }
        p1 = p1.next;
        p2 = p2.next;
    }

    return true;
}
```

---

## 5. 实战应用

### 5.1 LRU缓存实现

```javascript
/**
 * LRU (Least Recently Used) 缓存
 * 使用双向链表 + 哈希表实现
 */
class LRUCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.cache = new Map();

        // 创建虚拟头尾节点
        this.head = new DoublyListNode(0, 0);
        this.tail = new DoublyListNode(0, 0);
        this.head.next = this.tail;
        this.tail.prev = this.head;
    }

    get(key) {
        if (!this.cache.has(key)) {
            return -1;
        }

        const node = this.cache.get(key);
        // 移动到头部（最近使用）
        this.moveToHead(node);
        return node.val;
    }

    put(key, value) {
        if (this.cache.has(key)) {
            // 更新现有节点
            const node = this.cache.get(key);
            node.val = value;
            this.moveToHead(node);
        } else {
            // 添加新节点
            const newNode = new DoublyListNode(key, value);
            this.cache.set(key, newNode);
            this.addToHead(newNode);

            // 检查容量
            if (this.cache.size > this.capacity) {
                // 删除尾部节点（最少使用）
                const tail = this.removeTail();
                this.cache.delete(tail.key);
            }
        }
    }

    addToHead(node) {
        node.prev = this.head;
        node.next = this.head.next;
        this.head.next.prev = node;
        this.head.next = node;
    }

    removeNode(node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    moveToHead(node) {
        this.removeNode(node);
        this.addToHead(node);
    }

    removeTail() {
        const node = this.tail.prev;
        this.removeNode(node);
        return node;
    }
}

// 测试
const lru = new LRUCache(2);
lru.put(1, 1);
lru.put(2, 2);
console.log(lru.get(1));    // 1
lru.put(3, 3);              // 删除key 2
console.log(lru.get(2));    // -1 (未找到)
lru.put(4, 4);              // 删除key 1
console.log(lru.get(1));    // -1 (未找到)
console.log(lru.get(3));    // 3
console.log(lru.get(4));    // 4
```

### 5.2 浏览器历史记录

```javascript
/**
 * 浏览器历史记录
 * 使用双向链表实现前进/后退功能
 */
class BrowserHistory {
    constructor(homepage) {
        this.current = new DoublyListNode(homepage);
        this.head = this.current;
    }

    visit(url) {
        const newPage = new DoublyListNode(url);
        this.current.next = newPage;
        newPage.prev = this.current;
        this.current = newPage;
    }

    back(steps) {
        while (steps > 0 && this.current.prev) {
            this.current = this.current.prev;
            steps--;
        }
        return this.current.val;
    }

    forward(steps) {
        while (steps > 0 && this.current.next) {
            this.current = this.current.next;
            steps--;
        }
        return this.current.val;
    }
}
```

---

## 总结

### 核心要点

1. **判断链表是否有环**
   - 最优解：快慢指针法（Floyd判圈算法）
   - 时间O(n)，空间O(1)
   - 快指针每次走两步，慢指针每次走一步

2. **链表反转**
   - 最优解：迭代法
   - 时间O(n)，空间O(1)
   - 使用prev、current、next三个指针

3. **链表常用技巧**
   - 虚拟头节点（dummy node）- 简化边界处理
   - 快慢指针 - 找中间节点、判断环
   - 双指针 - 合并、删除、反转

4. **时间空间复杂度**
   - 链表遍历：O(n)
   - 随机访问：O(n)
   - 插入删除：O(1)

### 面试建议

1. **清楚表达思路** - 先说思路再写代码
2. **注意边界条件** - 空链表、单节点、环形链表
3. **优先选择最优解** - 迭代优于递归（空间复杂度）
4. **代码规范** - 变量命名清晰，逻辑分明
5. **准备手写实现** - 链表反转和环检测是必考题

### 练习建议

- LeetCode 141: 环形链表
- LeetCode 142: 环形链表 II
- LeetCode 206: 反转链表
- LeetCode 92: 反转链表 II
- LeetCode 234: 回文链表
- LeetCode 146: LRU缓存

**最后更新**: 2025-12-09
