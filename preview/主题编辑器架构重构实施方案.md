# HEYTAP 主题编辑器 - 架构重构实施方案

## 目标概述

本文档详细说明如何实现以下两个核心目标：

1. **应用架构重构**：对原有架构进行分层设计（主进程、子进程、通信层、渲染层），提升系统的可扩展性与可维护性，以支持多产品线（主题、锁屏、天气）的制作和扩展能力。

2. **复杂任务解耦与稳定性提升**：将主题导出等高耗时任务重构至独立子进程，并设计带优先级管理的任务队列，彻底解决界面卡顿与崩溃问题，应用稳定性显著提升。

---

## 目录

- [一、架构重构方案](#一架构重构方案)
  - [1.1 当前架构分析](#11-当前架构分析)
  - [1.2 目标架构设计](#12-目标架构设计)
  - [1.3 分层设计详解](#13-分层设计详解)
  - [1.4 实施步骤](#14-实施步骤)
- [二、子进程与任务队列方案](#二子进程与任务队列方案)
  - [2.1 当前问题分析](#21-当前问题分析)
  - [2.2 子进程架构设计](#22-子进程架构设计)
  - [2.3 任务队列设计](#23-任务队列设计)
  - [2.4 实施步骤](#24-实施步骤)
- [三、技术实施细节](#三技术实施细节)
- [四、风险评估与应对](#四风险评估与应对)
- [五、实施时间表](#五实施时间表)

---

## 一、架构重构方案

### 1.1 当前架构分析

#### 现状

当前项目采用 Electron + Vue 2.7 架构，已有一定的分层设计：

```
当前架构层次：
├── 主进程 (src/background.js)
│   ├── 窗口管理
│   ├── IPC 通信
│   ├── 文件系统操作
│   └── 业务模块
│       ├── themeNew/     (主题模块)
│       ├── lockscreenNew/ (锁屏模块)
│       └── widget/       (小组件模块)
├── 渲染进程 (src/renderer/)
│   ├── 业务页面
│   ├── Vuex 状态管理
│   └── UI 组件
├── 通用层 (src/universal/)
│   ├── middle/          (中间层业务逻辑)
│   └── datastore/       (数据存储)
└── Preload 脚本 (preload/)
    ├── lockscreen/
    ├── widget/
    └── event.js
```

#### 存在的问题

1. **耦合度较高**：主进程直接处理所有业务逻辑，导出、压缩等耗时操作在主进程执行
2. **扩展性不足**：新增产品线（如天气小组件）需要修改多处代码
3. **稳定性问题**：高耗时任务（主题导出、批量图片处理）会阻塞主进程，导致界面卡顿甚至崩溃
4. **通信层不够统一**：IPC 通信分散在各个模块，缺乏统一的通信抽象层

### 1.2 目标架构设计

#### 理想架构

```
目标架构（四层设计）：

┌─────────────────────────────────────────────────────────────┐
│                    渲染层 (Renderer Layer)                   │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  UI 组件层 (Vue Components)                             │ │
│  │  - 主题编辑器 UI                                         │ │
│  │  - 锁屏编辑器 UI                                         │ │
│  │  - 小组件编辑器 UI                                       │ │
│  │  - 天气编辑器 UI (扩展)                                  │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  状态管理层 (Vuex / Custom Stores)                      │ │
│  │  - 主题 Store                                           │ │
│  │  - 锁屏 Store                                           │ │
│  │  - 小组件 Store                                         │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            ↕ (IPC Bridge)
┌─────────────────────────────────────────────────────────────┐
│                    通信层 (Communication Layer)              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  统一 IPC 通信管理器 (IPCManager)                        │ │
│  │  - 请求/响应模式                                         │ │
│  │  - 事件订阅/发布                                         │ │
│  │  - 错误处理与重试                                        │ │
│  │  - 超时控制                                             │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  API 抽象层 (API Facade)                                │ │
│  │  - ThemeAPI                                             │ │
│  │  - LockscreenAPI                                        │ │
│  │  - WidgetAPI                                            │ │
│  │  - WeatherAPI (扩展)                                    │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                    主进程层 (Main Process Layer)             │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  应用生命周期管理 (App Lifecycle Manager)                │ │
│  │  - 窗口管理                                             │ │
│  │  - 进程协调                                             │ │
│  │  - 资源管理                                             │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  业务协调层 (Business Coordinator)                       │ │
│  │  - 任务分发                                             │ │
│  │  - 状态同步                                             │ │
│  │  - 缓存管理                                             │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  轻量级业务逻辑 (Light Business Logic)                   │ │
│  │  - 文件读写（小文件）                                    │ │
│  │  - 数据库操作 (LowDB)                                   │ │
│  │  - 配置管理                                             │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                    子进程层 (Worker Process Layer)           │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  任务队列管理器 (Task Queue Manager)                     │ │
│  │  - 优先级队列                                           │ │
│  │  - 任务调度                                             │ │
│  │  - 负载均衡                                             │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  Worker Pool (工作进程池)                               │ │
│  │  ├── ThemeWorker (主题导出/打包)                         │ │
│  │  ├── ImageWorker (图片处理/压缩)                         │ │
│  │  ├── LockscreenWorker (锁屏导出)                        │ │
│  │  ├── WidgetWorker (小组件打包)                          │ │
│  │  └── WeatherWorker (天气数据处理) [扩展]                 │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  重量级业务逻辑 (Heavy Business Logic)                   │ │
│  │  - 主题打包 (packTheme)                                 │ │
│  │  - 文件压缩 (compress)                                  │ │
│  │  - 图片批处理 (batch image processing)                  │ │
│  │  - XML 生成与解析                                       │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 1.3 分层设计详解

#### 1.3.1 渲染层 (Renderer Layer)

**职责**：

- 用户界面展示
- 用户交互处理
- 状态管理（Vuex / Custom Stores）
- 本地缓存（IndexedDB）

**实施要点**：

1. **统一状态管理**：

   ```javascript
   // src/renderer/store/modules/product.js
   // 抽象产品线通用状态管理模式

   export const createProductStore = productType => ({
   	namespaced: true,
   	state: {
   		list: [], // 产品列表
   		current: null, // 当前编辑的产品
   		editedData: {}, // 已编辑数据
   		isLoading: false, // 加载状态
   		error: null // 错误信息
   	},
   	mutations: {
   		SET_LIST(state, list) {
   			state.list = list
   		},
   		SET_CURRENT(state, product) {
   			state.current = product
   		},
   		UPDATE_EDITED_DATA(state, { key, value }) {
   			state.editedData[key] = value
   		},
   		SET_LOADING(state, isLoading) {
   			state.isLoading = isLoading
   		},
   		SET_ERROR(state, error) {
   			state.error = error
   		}
   	},
   	actions: {
   		async loadList({ commit }) {
   			commit('SET_LOADING', true)
   			try {
   				const res = await window.electron.callMain(`get${productType}List`)
   				commit('SET_LIST', res.data)
   			} catch (error) {
   				commit('SET_ERROR', error)
   			} finally {
   				commit('SET_LOADING', false)
   			}
   		},
   		async export({ state, commit }, options) {
   			commit('SET_LOADING', true)
   			try {
   				// 通过统一 API 调用导出
   				const res = await window.electron.callMain(`export${productType}`, {
   					id: state.current.id,
   					...options
   				})
   				return res
   			} catch (error) {
   				commit('SET_ERROR', error)
   				throw error
   			} finally {
   				commit('SET_LOADING', false)
   			}
   		}
   	}
   })

   // 使用
   export const themeStore = createProductStore('Theme')
   export const lockscreenStore = createProductStore('Lockscreen')
   export const widgetStore = createProductStore('Widget')
   export const weatherStore = createProductStore('Weather') // 扩展
   ```

2. **UI 组件抽象**：

   ```vue
   <!-- src/renderer/components/ProductEditor/index.vue -->
   <!-- 抽象产品编辑器通用组件 -->
   <template>
   	<div class="product-editor">
   		<ProductToolbar :product-type="productType" />
   		<div class="editor-content">
   			<LeftPanel :product-type="productType" />
   			<Canvas :product-type="productType" />
   			<RightPanel :product-type="productType" />
   		</div>
   		<StatusBar :product-type="productType" />
   	</div>
   </template>

   <script>
   export default {
   	name: 'ProductEditor',
   	props: {
   		productType: {
   			type: String,
   			required: true,
   			validator: val => ['theme', 'lockscreen', 'widget', 'weather'].includes(val)
   		}
   	}
   }
   </script>
   ```

#### 1.3.2 通信层 (Communication Layer)

**职责**：

- 统一 IPC 通信接口
- 请求/响应管理
- 错误处理与重试
- 超时控制
- 事件订阅/发布

**实施要点**：

1. **创建统一的 IPC 管理器**：

   ```javascript
   // src/universal/communication/IPCManager.js

   class IPCManager {
   	constructor() {
   		this.pendingRequests = new Map()
   		this.eventHandlers = new Map()
   		this.requestId = 0
   		this.defaultTimeout = 30000 // 30秒超时
   	}

   	/**
   	 * 发送请求到主进程
   	 * @param {string} channel - 通道名
   	 * @param {object} data - 请求数据
   	 * @param {object} options - 选项（timeout, retry等）
   	 */
   	async request(channel, data = {}, options = {}) {
   		const requestId = ++this.requestId
   		const timeout = options.timeout || this.defaultTimeout
   		const retry = options.retry || 0

   		return new Promise((resolve, reject) => {
   			const timer = setTimeout(() => {
   				this.pendingRequests.delete(requestId)
   				reject(new Error(`Request timeout: ${channel}`))
   			}, timeout)

   			this.pendingRequests.set(requestId, { resolve, reject, timer })

   			// 发送到主进程
   			window.electron.ipcRenderer.send('ipc-request', {
   				requestId,
   				channel,
   				data,
   				retry
   			})
   		})
   	}

   	/**
   	 * 处理主进程响应
   	 */
   	handleResponse(response) {
   		const { requestId, data, error } = response
   		const pending = this.pendingRequests.get(requestId)

   		if (pending) {
   			clearTimeout(pending.timer)
   			this.pendingRequests.delete(requestId)

   			if (error) {
   				pending.reject(new Error(error))
   			} else {
   				pending.resolve(data)
   			}
   		}
   	}

   	/**
   	 * 订阅事件
   	 */
   	on(event, handler) {
   		if (!this.eventHandlers.has(event)) {
   			this.eventHandlers.set(event, [])
   		}
   		this.eventHandlers.get(event).push(handler)
   	}

   	/**
   	 * 取消订阅
   	 */
   	off(event, handler) {
   		const handlers = this.eventHandlers.get(event)
   		if (handlers) {
   			const index = handlers.indexOf(handler)
   			if (index > -1) {
   				handlers.splice(index, 1)
   			}
   		}
   	}

   	/**
   	 * 触发事件
   	 */
   	emit(event, data) {
   		const handlers = this.eventHandlers.get(event) || []
   		handlers.forEach(handler => handler(data))
   	}
   }

   export const ipcManager = new IPCManager()

   // 监听主进程响应
   window.electron.ipcRenderer.on('ipc-response', (event, response) => {
   	ipcManager.handleResponse(response)
   })

   // 监听主进程事件
   window.electron.ipcRenderer.on('ipc-event', (event, { eventName, data }) => {
   	ipcManager.emit(eventName, data)
   })
   ```

2. **创建 API 抽象层**：

   ```javascript
   // src/universal/communication/ProductAPI.js

   import { ipcManager } from './IPCManager'

   /**
    * 产品线 API 基类
    */
   class ProductAPI {
   	constructor(productType) {
   		this.productType = productType
   	}

   	async getList() {
   		return ipcManager.request(`${this.productType}:getList`)
   	}

   	async create(data) {
   		return ipcManager.request(`${this.productType}:create`, data)
   	}

   	async update(id, data) {
   		return ipcManager.request(`${this.productType}:update`, { id, data })
   	}

   	async delete(id) {
   		return ipcManager.request(`${this.productType}:delete`, { id })
   	}

   	async export(id, options) {
   		// 导出操作设置更长的超时时间
   		return ipcManager.request(
   			`${this.productType}:export`,
   			{ id, options },
   			{ timeout: 300000 } // 5分钟
   		)
   	}

   	async import(file) {
   		return ipcManager.request(`${this.productType}:import`, { file })
   	}

   	// 监听导出进度
   	onExportProgress(callback) {
   		ipcManager.on(`${this.productType}:exportProgress`, callback)
   	}

   	offExportProgress(callback) {
   		ipcManager.off(`${this.productType}:exportProgress`, callback)
   	}
   }

   // 各产品线 API
   export const ThemeAPI = new ProductAPI('theme')
   export const LockscreenAPI = new ProductAPI('lockscreen')
   export const WidgetAPI = new ProductAPI('widget')
   export const WeatherAPI = new ProductAPI('weather') // 扩展
   ```

3. **在 Preload 中实现通信桥接**：

   ```javascript
   // preload/communication-bridge.js

   const { contextBridge, ipcRenderer } = require('electron')

   contextBridge.exposeInMainWorld('electron', {
   	ipcRenderer: {
   		send: (channel, data) => {
   			// 白名单验证
   			const validChannels = ['ipc-request']
   			if (validChannels.includes(channel)) {
   				ipcRenderer.send(channel, data)
   			}
   		},
   		on: (channel, func) => {
   			const validChannels = ['ipc-response', 'ipc-event']
   			if (validChannels.includes(channel)) {
   				ipcRenderer.on(channel, (event, ...args) => func(event, ...args))
   			}
   		},
   		removeListener: (channel, func) => {
   			ipcRenderer.removeListener(channel, func)
   		}
   	}
   })
   ```

#### 1.3.3 主进程层 (Main Process Layer)

**职责**：

- 应用生命周期管理
- 窗口管理
- 任务分发与协调
- 轻量级业务逻辑
- 数据库操作

**实施要点**：

1. **重构主进程入口**：

   ```javascript
   // src/electron/main.js (重构后的 background.js)

   const { app, BrowserWindow } = require('electron')
   const { AppLifecycleManager } = require('./core/AppLifecycleManager')
   const { IPCRouter } = require('./core/IPCRouter')
   const { TaskDispatcher } = require('./core/TaskDispatcher')

   class Application {
   	constructor() {
   		this.lifecycleManager = new AppLifecycleManager()
   		this.ipcRouter = new IPCRouter()
   		this.taskDispatcher = new TaskDispatcher()
   	}

   	async initialize() {
   		// 初始化应用
   		await this.lifecycleManager.initialize()

   		// 注册 IPC 路由
   		this.registerRoutes()

   		// 启动任务调度器
   		await this.taskDispatcher.start()
   	}

   	registerRoutes() {
   		// 主题相关路由
   		this.ipcRouter.register('theme', require('./modules/theme'))

   		// 锁屏相关路由
   		this.ipcRouter.register('lockscreen', require('./modules/lockscreen'))

   		// 小组件相关路由
   		this.ipcRouter.register('widget', require('./modules/widget'))

   		// 天气相关路由（扩展）
   		this.ipcRouter.register('weather', require('./modules/weather'))
   	}

   	async start() {
   		await this.initialize()
   		await this.lifecycleManager.createMainWindow()
   	}
   }

   const application = new Application()

   app.whenReady().then(() => {
   	application.start()
   })
   ```

2. **创建 IPC 路由器**：

   ```javascript
   // src/electron/core/IPCRouter.js

   const { ipcMain } = require('electron')
   const log = require('electron-log')

   class IPCRouter {
   	constructor() {
   		this.routes = new Map()
   		this.setupListener()
   	}

   	setupListener() {
   		ipcMain.on('ipc-request', async (event, request) => {
   			const { requestId, channel, data, retry } = request

   			try {
   				// 解析路由：theme:export -> module=theme, action=export
   				const [module, action] = channel.split(':')

   				const handler = this.routes.get(module)
   				if (!handler || !handler[action]) {
   					throw new Error(`No handler for ${channel}`)
   				}

   				// 执行处理器
   				const result = await handler[action](data)

   				// 返回响应
   				event.reply('ipc-response', {
   					requestId,
   					data: result
   				})
   			} catch (error) {
   				log.error(`IPC Error: ${channel}`, error)

   				// 返回错误
   				event.reply('ipc-response', {
   					requestId,
   					error: error.message
   				})
   			}
   		})
   	}

   	register(module, handler) {
   		this.routes.set(module, handler)
   	}
   }

   module.exports = { IPCRouter }
   ```

3. **创建任务分发器**：

   ```javascript
   // src/electron/core/TaskDispatcher.js

   const { fork } = require('child_process')
   const path = require('path')
   const log = require('electron-log')

   class TaskDispatcher {
   	constructor() {
   		this.workerPool = new Map()
   		this.taskQueue = []
   		this.maxWorkers = require('os').cpus().length
   	}

   	async start() {
   		// 创建 Worker Pool
   		this.createWorkerPool()
   	}

   	createWorkerPool() {
   		const workerTypes = ['theme', 'image', 'lockscreen', 'widget']

   		workerTypes.forEach(type => {
   			const workerPath = path.resolve(__dirname, '../workers', `${type}-worker.js`)
   			const worker = fork(workerPath)

   			worker.on('message', message => {
   				this.handleWorkerMessage(type, message)
   			})

   			worker.on('error', error => {
   				log.error(`Worker ${type} error:`, error)
   			})

   			worker.on('exit', code => {
   				log.info(`Worker ${type} exited with code ${code}`)
   				// 重启 worker
   				this.restartWorker(type)
   			})

   			this.workerPool.set(type, {
   				process: worker,
   				busy: false,
   				tasks: []
   			})
   		})
   	}

   	/**
   	 * 分发任务到子进程
   	 * @param {string} workerType - worker 类型
   	 * @param {string} taskType - 任务类型
   	 * @param {object} data - 任务数据
   	 * @param {number} priority - 优先级 (1-10, 10最高)
   	 */
   	async dispatch(workerType, taskType, data, priority = 5) {
   		return new Promise((resolve, reject) => {
   			const task = {
   				id: Date.now() + Math.random(),
   				workerType,
   				taskType,
   				data,
   				priority,
   				resolve,
   				reject,
   				createdAt: Date.now()
   			}

   			// 加入任务队列
   			this.taskQueue.push(task)

   			// 按优先级排序
   			this.taskQueue.sort((a, b) => b.priority - a.priority)

   			// 尝试执行任务
   			this.executeNext()
   		})
   	}

   	executeNext() {
   		if (this.taskQueue.length === 0) return

   		// 找到空闲的 worker
   		for (const [type, worker] of this.workerPool) {
   			if (!worker.busy && this.taskQueue.length > 0) {
   				// 找到匹配的任务
   				const taskIndex = this.taskQueue.findIndex(t => t.workerType === type)
   				if (taskIndex > -1) {
   					const task = this.taskQueue.splice(taskIndex, 1)[0]
   					this.executeTask(worker, task)
   				}
   			}
   		}
   	}

   	executeTask(worker, task) {
   		worker.busy = true
   		worker.tasks.push(task)

   		// 发送任务到 worker
   		worker.process.send({
   			taskId: task.id,
   			type: task.taskType,
   			data: task.data
   		})
   	}

   	handleWorkerMessage(workerType, message) {
   		const worker = this.workerPool.get(workerType)
   		if (!worker) return

   		const { taskId, result, error, progress } = message

   		// 查找任务
   		const taskIndex = worker.tasks.findIndex(t => t.id === taskId)
   		if (taskIndex === -1) return

   		const task = worker.tasks[taskIndex]

   		if (progress !== undefined) {
   			// 进度更新
   			this.notifyProgress(task, progress)
   		} else if (error) {
   			// 任务失败
   			worker.tasks.splice(taskIndex, 1)
   			worker.busy = false
   			task.reject(new Error(error))
   			this.executeNext()
   		} else {
   			// 任务成功
   			worker.tasks.splice(taskIndex, 1)
   			worker.busy = false
   			task.resolve(result)
   			this.executeNext()
   		}
   	}

   	notifyProgress(task, progress) {
   		// 通知渲染进程进度更新
   		const mainWindow = require('./AppLifecycleManager').getMainWindow()
   		if (mainWindow) {
   			mainWindow.webContents.send('ipc-event', {
   				eventName: `${task.workerType}:${task.taskType}:progress`,
   				data: {
   					taskId: task.id,
   					progress
   				}
   			})
   		}
   	}

   	restartWorker(type) {
   		const worker = this.workerPool.get(type)
   		if (worker) {
   			worker.process.kill()
   		}

   		// 重新创建
   		setTimeout(() => {
   			this.createWorkerPool()
   		}, 1000)
   	}
   }

   module.exports = { TaskDispatcher }
   ```

4. **重构业务模块**：

   ```javascript
   // src/electron/modules/theme/index.js

   const { TaskDispatcher } = require('../../core/TaskDispatcher')
   const utils = require('../../utils')
   const log = require('electron-log')

   class ThemeModule {
   	constructor() {
   		this.dispatcher = new TaskDispatcher()
   	}

   	/**
   	 * 获取主题列表（轻量级操作，主进程处理）
   	 */
   	async getList() {
   		const themes = utils.getLocalData('themes', null) || []
   		return {
   			code: 0,
   			data: themes
   		}
   	}

   	/**
   	 * 创建主题（轻量级操作，主进程处理）
   	 */
   	async create(data) {
   		const { createTheme } = require('./create')
   		return await createTheme(data)
   	}

   	/**
   	 * 导出主题（重量级操作，分发到子进程）
   	 */
   	async export(data) {
   		const { themeID, osVersions, settingsIcons } = data

   		try {
   			// 分发到 theme worker，优先级为 8（高优先级）
   			const result = await this.dispatcher.dispatch('theme', 'export', { themeID, osVersions, settingsIcons }, 8)

   			return {
   				code: 0,
   				data: result
   			}
   		} catch (error) {
   			log.error('Theme export failed:', error)
   			return {
   				code: 9999,
   				message: error.message
   			}
   		}
   	}

   	/**
   	 * 批量导入主题（重量级操作，分发到子进程）
   	 */
   	async import(data) {
   		const { files } = data

   		try {
   			const result = await this.dispatcher.dispatch(
   				'theme',
   				'import',
   				{ files },
   				5 // 中等优先级
   			)

   			return {
   				code: 0,
   				data: result
   			}
   		} catch (error) {
   			return {
   				code: 9999,
   				message: error.message
   			}
   		}
   	}
   }

   module.exports = new ThemeModule()
   ```

#### 1.3.4 子进程层 (Worker Process Layer)

**职责**：

- 执行重量级任务
- 文件压缩/解压
- 图片批处理
- 主题/锁屏打包
- 复杂计算

**实施要点**：

1. **创建 Worker 基类**：

   ```javascript
   // src/electron/workers/BaseWorker.js

   const log = require('electron-log')

   class BaseWorker {
   	constructor(workerName) {
   		this.workerName = workerName
   		this.setupMessageHandler()
   	}

   	setupMessageHandler() {
   		process.on('message', async message => {
   			const { taskId, type, data } = message

   			try {
   				// 执行任务
   				const result = await this.handleTask(type, data, progress => {
   					// 发送进度
   					this.sendProgress(taskId, progress)
   				})

   				// 发送结果
   				this.sendResult(taskId, result)
   			} catch (error) {
   				log.error(`${this.workerName} task failed:`, error)
   				this.sendError(taskId, error.message)
   			}
   		})
   	}

   	/**
   	 * 子类需要实现此方法
   	 * @param {string} type - 任务类型
   	 * @param {object} data - 任务数据
   	 * @param {function} onProgress - 进度回调
   	 */
   	async handleTask(type, data, onProgress) {
   		throw new Error('handleTask must be implemented')
   	}

   	sendProgress(taskId, progress) {
   		process.send({
   			taskId,
   			progress
   		})
   	}

   	sendResult(taskId, result) {
   		process.send({
   			taskId,
   			result
   		})
   	}

   	sendError(taskId, error) {
   		process.send({
   			taskId,
   			error
   		})
   	}
   }

   module.exports = { BaseWorker }
   ```

2. **创建主题 Worker**：

   ```javascript
   // src/electron/workers/theme-worker.js

   const { BaseWorker } = require('./BaseWorker')
   const { packTheme, outputTheme } = require('../themeNew/output')
   const utils = require('../utils')
   const path = require('path')
   const log = require('electron-log')

   class ThemeWorker extends BaseWorker {
   	constructor() {
   		super('ThemeWorker')
   	}

   	async handleTask(type, data, onProgress) {
   		switch (type) {
   			case 'export':
   				return await this.handleExport(data, onProgress)
   			case 'import':
   				return await this.handleImport(data, onProgress)
   			case 'pack':
   				return await this.handlePack(data, onProgress)
   			default:
   				throw new Error(`Unknown task type: ${type}`)
   		}
   	}

   	async handleExport(data, onProgress) {
   		const { themeID, osVersions, settingsIcons } = data

   		onProgress(0)

   		// 执行导出
   		const result = await outputTheme({
   			themeID,
   			osVersions,
   			settingsIcons
   		})

   		onProgress(100)

   		return result
   	}

   	async handleImport(data, onProgress) {
   		const { files } = data
   		const results = []

   		for (let i = 0; i < files.length; i++) {
   			const file = files[i]

   			// 更新进度
   			onProgress(Math.floor((i / files.length) * 100))

   			// 导入主题
   			const result = await this.importSingleTheme(file)
   			results.push(result)
   		}

   		onProgress(100)

   		return results
   	}

   	async handlePack(data, onProgress) {
   		const { source, target, osVersion } = data

   		onProgress(0)

   		const result = await packTheme(target, source, osVersion)

   		onProgress(100)

   		return result
   	}

   	async importSingleTheme(file) {
   		// 实现单个主题导入逻辑
   		const { input } = require('../themeNew/input')
   		return await input(file)
   	}
   }

   // 启动 worker
   new ThemeWorker()

   log.info('ThemeWorker started')
   ```

3. **创建图片处理 Worker**：

   ```javascript
   // src/electron/workers/image-worker.js

   const { BaseWorker } = require('./BaseWorker')
   const sharp = require('sharp') // 使用 sharp 库进行图片处理
   const fs = require('fs-extra')
   const path = require('path')

   class ImageWorker extends BaseWorker {
   	constructor() {
   		super('ImageWorker')
   	}

   	async handleTask(type, data, onProgress) {
   		switch (type) {
   			case 'compress':
   				return await this.handleCompress(data, onProgress)
   			case 'resize':
   				return await this.handleResize(data, onProgress)
   			case 'batch':
   				return await this.handleBatch(data, onProgress)
   			default:
   				throw new Error(`Unknown task type: ${type}`)
   		}
   	}

   	async handleCompress(data, onProgress) {
   		const { source, target, quality = 80 } = data

   		onProgress(0)

   		await sharp(source).jpeg({ quality }).toFile(target)

   		onProgress(100)

   		return { success: true, file: target }
   	}

   	async handleResize(data, onProgress) {
   		const { source, target, width, height } = data

   		onProgress(0)

   		await sharp(source).resize(width, height).toFile(target)

   		onProgress(100)

   		return { success: true, file: target }
   	}

   	async handleBatch(data, onProgress) {
   		const { files, operation } = data
   		const results = []

   		for (let i = 0; i < files.length; i++) {
   			const file = files[i]

   			onProgress(Math.floor((i / files.length) * 100))

   			const result = await this.processSingleFile(file, operation)
   			results.push(result)
   		}

   		onProgress(100)

   		return results
   	}

   	async processSingleFile(file, operation) {
   		// 根据操作类型处理单个文件
   		switch (operation.type) {
   			case 'compress':
   				return await this.handleCompress(
   					{
   						source: file.source,
   						target: file.target,
   						quality: operation.quality
   					},
   					() => {}
   				)
   			case 'resize':
   				return await this.handleResize(
   					{
   						source: file.source,
   						target: file.target,
   						width: operation.width,
   						height: operation.height
   					},
   					() => {}
   				)
   			default:
   				throw new Error(`Unknown operation: ${operation.type}`)
   		}
   	}
   }

   new ImageWorker()
   ```

### 1.4 实施步骤

#### 阶段一：基础架构搭建（2 周）

**目标**：建立通信层和主进程协调层

1. **第 1-3 天**：创建 IPC 管理器和 API 抽象层

   - 实现 `IPCManager` 类
   - 实现 `ProductAPI` 基类
   - 更新 preload 脚本

2. **第 4-7 天**：重构主进程

   - 创建 `IPCRouter`
   - 创建 `AppLifecycleManager`
   - 创建 `TaskDispatcher`
   - 重构 `background.js` 为 `main.js`

3. **第 8-10 天**：创建 Worker 基础设施

   - 实现 `BaseWorker` 类
   - 创建 Worker Pool 管理
   - 实现任务队列

4. **第 11-14 天**：测试与调试
   - 单元测试
   - 集成测试
   - 性能测试

#### 阶段二：业务模块迁移（3 周）

**目标**：将现有业务逻辑迁移到新架构

1. **第 1 周**：主题模块迁移

   - 创建 `ThemeWorker`
   - 迁移导出逻辑到子进程
   - 迁移导入逻辑到子进程
   - 更新渲染层调用

2. **第 2 周**：锁屏模块迁移

   - 创建 `LockscreenWorker`
   - 迁移导出逻辑
   - 迁移导入逻辑

3. **第 3 周**：小组件模块迁移
   - 创建 `WidgetWorker`
   - 迁移相关逻辑

#### 阶段三：优化与扩展（2 周）

**目标**：性能优化和扩展能力验证

1. **第 1 周**：性能优化

   - Worker Pool 调优
   - 任务队列优化
   - 内存管理优化

2. **第 2 周**：扩展验证
   - 添加天气模块（作为扩展能力验证）
   - 文档完善
   - 培训开发团队

---

## 二、子进程与任务队列方案

### 2.1 当前问题分析

#### 问题表现

1. **界面卡顿**：

   - 主题导出时，主进程执行大量文件操作（压缩、XML 生成）
   - 批量图片处理时，主进程被阻塞
   - 用户无法进行其他操作

2. **应用崩溃**：

   - 大型主题包导出时，内存占用过高
   - 主进程超时导致渲染进程失去响应
   - 错误处理不当导致进程崩溃

3. **无优先级管理**：
   - 所有任务按顺序执行
   - 用户交互任务与后台任务无区分
   - 无法中断低优先级任务

#### 根本原因

```javascript
// 当前实现 (src/electron/themeNew/output.js)
// 所有操作都在主进程同步执行

const outputTheme = async({ themeID, osVersions = [], settingsIcons = [] }) => {
  // 1. 文件操作（阻塞主进程）
  await utils.copyPro(path.resolve(dir_themes, themeID), themeTempDir)

  // 2. 清理主题包（阻塞主进程）
  const cleanRes = await cleanTheme(themeTempDir, osVersion, needRename, selfOsVersion, settingsIcons)

  // 3. 处理资源（阻塞主进程）
  await dealItems(themeTempDir, mergeData(...))

  // 4. 压缩打包（阻塞主进程）
  await utils.compress(themeTempDir, tgt, osVersion)

  // 主进程被完全阻塞，无法响应用户交互
}
```

### 2.2 子进程架构设计

#### 设计原则

1. **进程隔离**：重量级任务在独立子进程执行，崩溃不影响主进程
2. **资源限制**：每个子进程有内存和 CPU 限制
3. **任务分片**：大任务拆分为小任务，支持中断和恢复
4. **进度反馈**：实时向主进程报告进度

#### Worker 类型划分

```
Worker Pool:
├── ThemeWorker (主题相关)
│   ├── 导出主题
│   ├── 导入主题
│   ├── 打包主题
│   └── 校验主题
├── ImageWorker (图片处理)
│   ├── 图片压缩
│   ├── 图片缩放
│   ├── 批量处理
│   └── 格式转换
├── LockscreenWorker (锁屏相关)
│   ├── 导出锁屏
│   ├── 导入锁屏
│   └── 生成预览
├── WidgetWorker (小组件相关)
│   ├── 导出小组件
│   ├── 导入小组件
│   └── 打包小组件
└── WeatherWorker (天气相关，扩展)
    ├── 数据处理
    └── 资源打包
```

### 2.3 任务队列设计

#### 优先级定义

```javascript
// src/electron/core/TaskPriority.js

const TaskPriority = {
	CRITICAL: 10, // 关键任务（用户等待的导出）
	HIGH: 8, // 高优先级（用户触发的操作）
	NORMAL: 5, // 普通优先级（后台任务）
	LOW: 3, // 低优先级（预加载、缓存）
	IDLE: 1 // 空闲任务（清理、统计）
}

module.exports = { TaskPriority }
```

#### 任务队列实现

```javascript
// src/electron/core/TaskQueue.js

const { EventEmitter } = require('events')
const log = require('electron-log')

class TaskQueue extends EventEmitter {
	constructor(options = {}) {
		super()
		this.maxConcurrent = options.maxConcurrent || 4
		this.tasks = []
		this.running = []
		this.paused = false
	}

	/**
	 * 添加任务
	 * @param {object} task - 任务对象
	 * @param {number} task.priority - 优先级 (1-10)
	 * @param {string} task.type - 任务类型
	 * @param {function} task.execute - 执行函数
	 * @param {boolean} task.cancellable - 是否可取消
	 */
	add(task) {
		task.id = Date.now() + Math.random()
		task.status = 'pending'
		task.createdAt = Date.now()

		// 插入队列（按优先级排序）
		this.tasks.push(task)
		this.tasks.sort((a, b) => b.priority - a.priority)

		this.emit('taskAdded', task)

		// 尝试执行
		this.processNext()

		return task.id
	}

	/**
	 * 处理下一个任务
	 */
	async processNext() {
		if (this.paused) return
		if (this.running.length >= this.maxConcurrent) return
		if (this.tasks.length === 0) return

		const task = this.tasks.shift()
		task.status = 'running'
		task.startedAt = Date.now()

		this.running.push(task)
		this.emit('taskStarted', task)

		try {
			const result = await task.execute()

			task.status = 'completed'
			task.completedAt = Date.now()
			task.result = result

			this.emit('taskCompleted', task)
		} catch (error) {
			task.status = 'failed'
			task.error = error

			this.emit('taskFailed', task, error)

			// 重试逻辑
			if (task.retry && task.retryCount < task.retry) {
				task.retryCount = (task.retryCount || 0) + 1
				task.status = 'pending'
				this.tasks.unshift(task) // 重新加入队列头部
			}
		} finally {
			// 从运行列表移除
			const index = this.running.findIndex(t => t.id === task.id)
			if (index > -1) {
				this.running.splice(index, 1)
			}

			// 处理下一个任务
			this.processNext()
		}
	}

	/**
	 * 取消任务
	 */
	cancel(taskId) {
		// 从待执行队列中移除
		const pendingIndex = this.tasks.findIndex(t => t.id === taskId)
		if (pendingIndex > -1) {
			const task = this.tasks.splice(pendingIndex, 1)[0]
			task.status = 'cancelled'
			this.emit('taskCancelled', task)
			return true
		}

		// 尝试取消正在运行的任务
		const runningTask = this.running.find(t => t.id === taskId)
		if (runningTask && runningTask.cancellable && runningTask.cancel) {
			runningTask.cancel()
			runningTask.status = 'cancelled'
			this.emit('taskCancelled', runningTask)
			return true
		}

		return false
	}

	/**
	 * 暂停队列
	 */
	pause() {
		this.paused = true
		this.emit('queuePaused')
	}

	/**
	 * 恢复队列
	 */
	resume() {
		this.paused = false
		this.emit('queueResumed')
		this.processNext()
	}

	/**
	 * 清空队列
	 */
	clear() {
		this.tasks.forEach(task => {
			task.status = 'cancelled'
			this.emit('taskCancelled', task)
		})
		this.tasks = []
	}

	/**
	 * 获取队列状态
	 */
	getStatus() {
		return {
			pending: this.tasks.length,
			running: this.running.length,
			paused: this.paused
		}
	}
}

module.exports = { TaskQueue }
```

#### 任务调度器增强版

```javascript
// src/electron/core/TaskDispatcher.js (增强版)

const { fork } = require('child_process')
const { TaskQueue } = require('./TaskQueue')
const { TaskPriority } = require('./TaskPriority')
const path = require('path')
const log = require('electron-log')
const os = require('os')

class TaskDispatcher {
	constructor() {
		this.workerPool = new Map()
		this.taskQueue = new TaskQueue({
			maxConcurrent: os.cpus().length
		})

		// 监听队列事件
		this.setupQueueListeners()
	}

	async start() {
		this.createWorkerPool()
	}

	createWorkerPool() {
		const workerTypes = ['theme', 'image', 'lockscreen', 'widget']

		workerTypes.forEach(type => {
			const workerPath = path.resolve(__dirname, '../workers', `${type}-worker.js`)
			const worker = fork(workerPath, [], {
				// 设置子进程环境
				env: {
					...process.env,
					WORKER_TYPE: type
				},
				// 限制内存（可选）
				execArgv: ['--max-old-space-size=2048']
			})

			worker.on('message', message => {
				this.handleWorkerMessage(type, message)
			})

			worker.on('error', error => {
				log.error(`Worker ${type} error:`, error)
				this.notifyError(type, error)
			})

			worker.on('exit', code => {
				log.info(`Worker ${type} exited with code ${code}`)
				if (code !== 0) {
					// 非正常退出，重启 worker
					this.restartWorker(type)
				}
			})

			this.workerPool.set(type, {
				process: worker,
				busy: false,
				currentTask: null,
				stats: {
					tasksCompleted: 0,
					tasksFailed: 0,
					totalTime: 0
				}
			})
		})
	}

	setupQueueListeners() {
		this.taskQueue.on('taskStarted', task => {
			log.info(`Task started: ${task.type}`, task.id)
			this.notifyTaskStatus(task, 'started')
		})

		this.taskQueue.on('taskCompleted', task => {
			log.info(`Task completed: ${task.type}`, task.id)
			this.notifyTaskStatus(task, 'completed')

			// 更新 worker 统计
			const worker = this.workerPool.get(task.workerType)
			if (worker) {
				worker.stats.tasksCompleted++
				worker.stats.totalTime += task.completedAt - task.startedAt
			}
		})

		this.taskQueue.on('taskFailed', (task, error) => {
			log.error(`Task failed: ${task.type}`, task.id, error)
			this.notifyTaskStatus(task, 'failed', error)

			// 更新 worker 统计
			const worker = this.workerPool.get(task.workerType)
			if (worker) {
				worker.stats.tasksFailed++
			}
		})

		this.taskQueue.on('taskCancelled', task => {
			log.info(`Task cancelled: ${task.type}`, task.id)
			this.notifyTaskStatus(task, 'cancelled')
		})
	}

	/**
	 * 分发任务（增强版）
	 * @param {string} workerType - worker 类型
	 * @param {string} taskType - 任务类型
	 * @param {object} data - 任务数据
	 * @param {object} options - 选项
	 * @param {number} options.priority - 优先级
	 * @param {boolean} options.cancellable - 是否可取消
	 * @param {number} options.retry - 重试次数
	 * @param {number} options.timeout - 超时时间（毫秒）
	 */
	async dispatch(workerType, taskType, data, options = {}) {
		const {
			priority = TaskPriority.NORMAL,
			cancellable = true,
			retry = 0,
			timeout = 300000 // 默认5分钟
		} = options

		return new Promise((resolve, reject) => {
			const worker = this.workerPool.get(workerType)
			if (!worker) {
				reject(new Error(`Worker ${workerType} not found`))
				return
			}

			let timeoutTimer = null
			let cancelled = false

			const task = {
				workerType,
				taskType,
				data,
				priority,
				cancellable,
				retry,
				execute: async () => {
					return new Promise((resolveTask, rejectTask) => {
						// 设置超时
						if (timeout > 0) {
							timeoutTimer = setTimeout(() => {
								if (!cancelled) {
									rejectTask(new Error(`Task timeout: ${taskType}`))
								}
							}, timeout)
						}

						// 标记 worker 为忙碌
						worker.busy = true
						worker.currentTask = task

						// 发送任务到 worker
						worker.process.send({
							taskId: task.id,
							type: taskType,
							data
						})

						// 保存回调
						task.resolveTask = resolveTask
						task.rejectTask = rejectTask
					})
				},
				cancel: () => {
					cancelled = true
					if (timeoutTimer) {
						clearTimeout(timeoutTimer)
					}
					// 通知 worker 取消任务
					worker.process.send({
						taskId: task.id,
						type: 'cancel'
					})
				}
			}

			// 添加到队列
			const taskId = this.taskQueue.add(task)

			// 返回 Promise
			task
				.execute()
				.then(result => {
					if (timeoutTimer) {
						clearTimeout(timeoutTimer)
					}
					resolve(result)
				})
				.catch(error => {
					if (timeoutTimer) {
						clearTimeout(timeoutTimer)
					}
					reject(error)
				})
		})
	}

	handleWorkerMessage(workerType, message) {
		const worker = this.workerPool.get(workerType)
		if (!worker || !worker.currentTask) return

		const { taskId, result, error, progress } = message
		const task = worker.currentTask

		if (task.id !== taskId) return

		if (progress !== undefined) {
			// 进度更新
			this.notifyProgress(task, progress)
		} else if (error) {
			// 任务失败
			worker.busy = false
			worker.currentTask = null
			if (task.rejectTask) {
				task.rejectTask(new Error(error))
			}
		} else {
			// 任务成功
			worker.busy = false
			worker.currentTask = null
			if (task.resolveTask) {
				task.resolveTask(result)
			}
		}
	}

	notifyTaskStatus(task, status, error = null) {
		const mainWindow = require('./AppLifecycleManager').getMainWindow()
		if (mainWindow) {
			mainWindow.webContents.send('ipc-event', {
				eventName: 'task:status',
				data: {
					taskId: task.id,
					workerType: task.workerType,
					taskType: task.taskType,
					status,
					error: error ? error.message : null
				}
			})
		}
	}

	notifyProgress(task, progress) {
		const mainWindow = require('./AppLifecycleManager').getMainWindow()
		if (mainWindow) {
			mainWindow.webContents.send('ipc-event', {
				eventName: `${task.workerType}:${task.taskType}:progress`,
				data: {
					taskId: task.id,
					progress
				}
			})
		}
	}

	notifyError(workerType, error) {
		const mainWindow = require('./AppLifecycleManager').getMainWindow()
		if (mainWindow) {
			mainWindow.webContents.send('ipc-event', {
				eventName: 'worker:error',
				data: {
					workerType,
					error: error.message
				}
			})
		}
	}

	restartWorker(type) {
		const worker = this.workerPool.get(type)
		if (worker) {
			try {
				worker.process.kill()
			} catch (e) {
				log.error(`Failed to kill worker ${type}:`, e)
			}
		}

		// 延迟重启
		setTimeout(() => {
			log.info(`Restarting worker: ${type}`)
			const workerPath = path.resolve(__dirname, '../workers', `${type}-worker.js`)
			const newWorker = fork(workerPath, [], {
				env: {
					...process.env,
					WORKER_TYPE: type
				},
				execArgv: ['--max-old-space-size=2048']
			})

			newWorker.on('message', message => {
				this.handleWorkerMessage(type, message)
			})

			newWorker.on('error', error => {
				log.error(`Worker ${type} error:`, error)
				this.notifyError(type, error)
			})

			newWorker.on('exit', code => {
				log.info(`Worker ${type} exited with code ${code}`)
				if (code !== 0) {
					this.restartWorker(type)
				}
			})

			this.workerPool.set(type, {
				process: newWorker,
				busy: false,
				currentTask: null,
				stats: {
					tasksCompleted: 0,
					tasksFailed: 0,
					totalTime: 0
				}
			})
		}, 2000)
	}

	/**
	 * 获取调度器状态
	 */
	getStatus() {
		const workers = {}
		this.workerPool.forEach((worker, type) => {
			workers[type] = {
				busy: worker.busy,
				stats: worker.stats
			}
		})

		return {
			queue: this.taskQueue.getStatus(),
			workers
		}
	}

	/**
	 * 暂停所有任务
	 */
	pause() {
		this.taskQueue.pause()
	}

	/**
	 * 恢复所有任务
	 */
	resume() {
		this.taskQueue.resume()
	}

	/**
	 * 取消任务
	 */
	cancelTask(taskId) {
		return this.taskQueue.cancel(taskId)
	}
}

module.exports = { TaskDispatcher }
```

### 2.4 实施步骤

#### 阶段一：子进程基础设施（1 周）

1. **第 1-2 天**：创建 Worker 基类和通信机制

   - 实现 `BaseWorker`
   - 实现进程间通信协议
   - 实现进度报告机制

2. **第 3-4 天**：创建任务队列

   - 实现 `TaskQueue` 类
   - 实现优先级管理
   - 实现任务取消机制

3. **第 5-7 天**：集成到主进程
   - 实现 `TaskDispatcher`
   - 创建 Worker Pool
   - 测试基础功能

#### 阶段二：迁移重量级任务（2 周）

1. **第 1 周**：主题导出迁移

   - 创建 `ThemeWorker`
   - 迁移 `outputTheme` 到子进程
   - 迁移 `packTheme` 到子进程
   - 实现进度反馈

2. **第 2 周**：其他任务迁移
   - 创建 `ImageWorker`（图片处理）
   - 创建 `LockscreenWorker`
   - 创建 `WidgetWorker`
   - 批量操作优化

#### 阶段三：优化与测试（1 周）

1. **第 1-3 天**：性能优化

   - Worker Pool 大小调优
   - 任务队列算法优化
   - 内存管理优化

2. **第 4-5 天**：稳定性测试

   - 压力测试（大量任务）
   - 崩溃恢复测试
   - 内存泄漏检测

3. **第 6-7 天**：用户体验优化
   - 进度展示优化
   - 错误提示优化
   - 取消操作优化

---

## 三、技术实施细节

### 3.1 进程间通信优化

#### 大数据传输优化

对于大文件或大数据，避免通过 IPC 直接传输，改用文件路径传递：

```javascript
// 不推荐：直接传输大数据
worker.send({
	type: 'processImage',
	data: largeImageBuffer // 可能导致性能问题
})

// 推荐：传递文件路径
worker.send({
	type: 'processImage',
	filePath: '/path/to/image.jpg'
})
```

#### 使用 SharedArrayBuffer（可选）

对于需要共享的大数据，可以使用 `SharedArrayBuffer`：

```javascript
// 主进程
const sharedBuffer = new SharedArrayBuffer(1024 * 1024) // 1MB
worker.postMessage({ sharedBuffer })

// Worker
self.onmessage = event => {
	const { sharedBuffer } = event.data
	const view = new Uint8Array(sharedBuffer)
	// 直接操作共享内存
}
```

### 3.2 错误处理与恢复

#### Worker 崩溃恢复

```javascript
// src/electron/core/WorkerRecovery.js

class WorkerRecovery {
	constructor(dispatcher) {
		this.dispatcher = dispatcher
		this.crashLog = []
	}

	handleWorkerCrash(workerType, error) {
		this.crashLog.push({
			workerType,
			error,
			timestamp: Date.now()
		})

		// 检查崩溃频率
		const recentCrashes = this.crashLog.filter(
			log => log.workerType === workerType && Date.now() - log.timestamp < 60000 // 1分钟内
		)

		if (recentCrashes.length > 3) {
			// 频繁崩溃，不再重启
			log.error(`Worker ${workerType} crashed too frequently, not restarting`)
			this.notifyFatalError(workerType)
			return false
		}

		// 重启 worker
		this.dispatcher.restartWorker(workerType)
		return true
	}

	notifyFatalError(workerType) {
		// 通知用户
		const { dialog } = require('electron')
		dialog.showErrorBox('严重错误', `${workerType} 模块出现严重错误，请重启应用`)
	}
}

module.exports = { WorkerRecovery }
```

#### 任务失败重试

```javascript
// 在 TaskQueue 中已实现重试机制
// 使用示例：

await dispatcher.dispatch(
	'theme',
	'export',
	{ themeID: '123' },
	{
		priority: TaskPriority.HIGH,
		retry: 3, // 失败后重试3次
		timeout: 300000
	}
)
```

### 3.3 性能监控

#### 创建性能监控模块

```javascript
// src/electron/core/PerformanceMonitor.js

class PerformanceMonitor {
	constructor() {
		this.metrics = {
			tasks: [],
			workers: new Map()
		}
	}

	recordTaskStart(task) {
		this.metrics.tasks.push({
			id: task.id,
			type: task.taskType,
			workerType: task.workerType,
			priority: task.priority,
			startTime: Date.now()
		})
	}

	recordTaskEnd(task, success) {
		const metric = this.metrics.tasks.find(m => m.id === task.id)
		if (metric) {
			metric.endTime = Date.now()
			metric.duration = metric.endTime - metric.startTime
			metric.success = success
		}
	}

	getAverageTaskTime(taskType) {
		const tasks = this.metrics.tasks.filter(t => t.type === taskType && t.duration)

		if (tasks.length === 0) return 0

		const total = tasks.reduce((sum, t) => sum + t.duration, 0)
		return total / tasks.length
	}

	getWorkerStats(workerType) {
		return this.metrics.workers.get(workerType) || {}
	}

	generateReport() {
		return {
			totalTasks: this.metrics.tasks.length,
			successRate: this.calculateSuccessRate(),
			averageTimes: this.calculateAverageTimes(),
			workerStats: this.getWorkerStats()
		}
	}

	calculateSuccessRate() {
		const completed = this.metrics.tasks.filter(t => t.success)
		return (completed.length / this.metrics.tasks.length) * 100
	}

	calculateAverageTimes() {
		const types = [...new Set(this.metrics.tasks.map(t => t.type))]
		const times = {}

		types.forEach(type => {
			times[type] = this.getAverageTaskTime(type)
		})

		return times
	}
}

module.exports = { PerformanceMonitor }
```

### 3.4 内存管理

#### Worker 内存限制

```javascript
// 启动 Worker 时设置内存限制
const worker = fork(workerPath, [], {
	execArgv: [
		'--max-old-space-size=2048', // 最大堆内存 2GB
		'--max-semi-space-size=128' // 最大半空间 128MB
	]
})
```

#### 主进程内存监控

```javascript
// src/electron/core/MemoryMonitor.js

class MemoryMonitor {
	constructor() {
		this.threshold = 0.8 // 80% 内存使用率
		this.checkInterval = 30000 // 30秒检查一次
		this.start()
	}

	start() {
		setInterval(() => {
			this.checkMemory()
		}, this.checkInterval)
	}

	checkMemory() {
		const usage = process.memoryUsage()
		const totalMemory = require('os').totalmem()
		const usagePercent = usage.heapUsed / totalMemory

		if (usagePercent > this.threshold) {
			log.warn('High memory usage:', {
				heapUsed: Math.round(usage.heapUsed / 1024 / 1024) + 'MB',
				heapTotal: Math.round(usage.heapTotal / 1024 / 1024) + 'MB',
				external: Math.round(usage.external / 1024 / 1024) + 'MB'
			})

			// 触发垃圾回收（如果可用）
			if (global.gc) {
				global.gc()
			}

			// 通知用户
			this.notifyHighMemory()
		}
	}

	notifyHighMemory() {
		const mainWindow = require('./AppLifecycleManager').getMainWindow()
		if (mainWindow) {
			mainWindow.webContents.send('ipc-event', {
				eventName: 'system:highMemory',
				data: {
					message: '内存使用率较高，建议关闭一些编辑器窗口'
				}
			})
		}
	}
}

module.exports = { MemoryMonitor }
```

---

## 四、风险评估与应对

### 4.1 技术风险

| 风险               | 影响 | 概率 | 应对措施                                                                          |
| ------------------ | ---- | ---- | --------------------------------------------------------------------------------- |
| 子进程通信性能问题 | 中   | 低   | 1. 使用文件路径传递大数据<br>2. 批量操作减少通信次数<br>3. 使用 SharedArrayBuffer |
| Worker 频繁崩溃    | 高   | 中   | 1. 实现崩溃恢复机制<br>2. 限制 Worker 内存<br>3. 任务分片避免大任务               |
| 任务队列死锁       | 高   | 低   | 1. 实现超时机制<br>2. 任务优先级管理<br>3. 可取消任务                             |
| 内存泄漏           | 中   | 中   | 1. 定期内存检查<br>2. Worker 定期重启<br>3. 资源及时释放                          |
| 兼容性问题         | 低   | 低   | 1. 充分测试<br>2. 渐进式迁移<br>3. 保留降级方案                                   |

### 4.2 业务风险

| 风险         | 影响 | 概率 | 应对措施                                                |
| ------------ | ---- | ---- | ------------------------------------------------------- |
| 现有功能回归 | 高   | 中   | 1. 完整的回归测试<br>2. 灰度发布<br>3. 快速回滚机制     |
| 用户体验下降 | 中   | 低   | 1. 充分的用户测试<br>2. 进度反馈优化<br>3. 错误提示优化 |
| 开发周期延长 | 中   | 中   | 1. 分阶段实施<br>2. 并行开发<br>3. 及时调整计划         |
| 团队学习成本 | 低   | 高   | 1. 详细文档<br>2. 代码示例<br>3. 团队培训               |

### 4.3 应对策略

#### 渐进式迁移

```
阶段1: 基础设施 (不影响现有功能)
  ↓
阶段2: 迁移非关键功能 (如图片处理)
  ↓
阶段3: 迁移关键功能 (如主题导出)
  ↓
阶段4: 全面优化
```

#### 降级方案

```javascript
// 保留原有实现作为降级方案
const USE_WORKER = process.env.USE_WORKER !== 'false'

async function exportTheme(data) {
	if (USE_WORKER) {
		try {
			// 使用新的 Worker 实现
			return await dispatcher.dispatch('theme', 'export', data)
		} catch (error) {
			log.error('Worker failed, fallback to legacy:', error)
			// 降级到原有实现
			return await legacyExportTheme(data)
		}
	} else {
		// 直接使用原有实现
		return await legacyExportTheme(data)
	}
}
```

---

## 五、实施时间表

### 总体时间：7-8 周

```
Week 1-2: 基础架构搭建
├── 通信层实现
├── 主进程重构
└── Worker 基础设施

Week 3-5: 业务模块迁移
├── 主题模块迁移
├── 锁屏模块迁移
└── 小组件模块迁移

Week 6-7: 优化与测试
├── 性能优化
├── 稳定性测试
└── 用户体验优化

Week 8: 上线准备
├── 文档完善
├── 团队培训
└── 灰度发布
```

### 详细时间表

| 周次   | 任务           | 产出                      | 负责人   |
| ------ | -------------- | ------------------------- | -------- |
| Week 1 | 通信层实现     | IPCManager, ProductAPI    | 架构师   |
| Week 2 | 主进程重构     | IPCRouter, TaskDispatcher | 架构师   |
| Week 3 | 主题模块迁移   | ThemeWorker, ThemeModule  | 主题组   |
| Week 4 | 锁屏模块迁移   | LockscreenWorker          | 锁屏组   |
| Week 5 | 小组件模块迁移 | WidgetWorker              | 小组件组 |
| Week 6 | 性能优化       | 优化报告                  | 全员     |
| Week 7 | 稳定性测试     | 测试报告                  | 测试组   |
| Week 8 | 上线准备       | 文档、培训                | 全员     |

---

## 六、验收标准

### 6.1 功能验收

- [ ] 所有现有功能正常工作
- [ ] 主题导出在子进程执行
- [ ] 锁屏导出在子进程执行
- [ ] 小组件导出在子进程执行
- [ ] 任务队列正常工作
- [ ] 优先级管理正常
- [ ] 任务取消功能正常
- [ ] 进度反馈正常
- [ ] 错误处理正常

### 6.2 性能验收

- [ ] 主题导出时主进程 CPU 占用 < 20%
- [ ] 主题导出时界面无卡顿（60fps）
- [ ] 大型主题包导出不崩溃
- [ ] 批量操作不阻塞界面
- [ ] 内存占用合理（< 2GB）

### 6.3 稳定性验收

- [ ] 连续导出 100 个主题包无崩溃
- [ ] Worker 崩溃后能自动恢复
- [ ] 任务失败后能正确重试
- [ ] 长时间运行无内存泄漏
- [ ] 异常情况下数据不丢失

### 6.4 扩展性验收

- [ ] 能快速添加新产品线（如天气）
- [ ] 新增 Worker 类型简单
- [ ] 新增任务类型简单
- [ ] API 接口统一清晰
- [ ] 文档完整易懂

---

## 七、总结

### 核心价值

1. **架构清晰**：四层架构（渲染层、通信层、主进程层、子进程层）职责明确
2. **扩展性强**：新增产品线只需实现统一接口
3. **稳定性高**：子进程隔离，崩溃不影响主进程
4. **性能优异**：重量级任务不阻塞界面
5. **可维护性好**：代码结构清晰，易于理解和修改

### 关键技术点

1. **统一 IPC 通信**：IPCManager + ProductAPI
2. **任务队列**：优先级管理 + 任务取消
3. **Worker Pool**：进程池 + 负载均衡
4. **错误恢复**：崩溃恢复 + 任务重试
5. **性能监控**：实时监控 + 性能报告

### 后续优化方向

1. **分布式任务**：支持多机器协同处理
2. **智能调度**：基于机器学习的任务调度
3. **云端处理**：部分重量级任务云端处理
4. **实时协作**：多人协同编辑
5. **插件系统**：支持第三方扩展

---

**文档版本**：v1.0
**生成时间**：2025-12-16
**作者**：AI Assistant
**状态**：待审核
