# HEYTAP 主题编辑器 - 架构重构实施方案

## 目标概述

本文档详细说明如何实现以下两个核心目标：

1. **应用架构重构**：对原有架构进行分层设计（主进程、子进程、通信层、渲染层），提升系统的可扩展性与可维护性，以支持多产品线（主题、锁屏、天气）的制作和扩展能力。

2. **复杂任务解耦与稳定性提升**：将主题导出等高耗时任务重构至独立子进程，并设计带优先级管理的任务队列，彻底解决界面卡顿与崩溃问题，应用稳定性显著提升。

---

## 目录

- [一、架构重构方案](#一架构重构方案)
  - [1.1 当前架构分析](#11-当前架构分析)
  - [1.2 目标架构设计](#12-目标架构设计)
  - [1.3 分层设计详解](#13-分层设计详解)
  - [1.4 实施步骤](#14-实施步骤)
- [二、子进程与任务队列方案](#二子进程与任务队列方案)
  - [2.1 当前问题分析](#21-当前问题分析)
  - [2.2 子进程架构设计](#22-子进程架构设计)
  - [2.3 任务队列设计](#23-任务队列设计)
  - [2.4 实施步骤](#24-实施步骤)
  - [2.5 任务取消机制详解](#25-任务取消机制详解)
  - [2.6 完整数据流程详解](#26-完整数据流程详解)
- [三、技术实施细节](#三技术实施细节)
- [四、风险评估与应对](#四风险评估与应对)
- [五、实施时间表](#五实施时间表)

---

## 一、架构重构方案

### 1.1 当前架构分析

#### 现状

当前项目采用 Electron + Vue 2.7 架构，已有一定的分层设计：

```
当前架构层次：
├── 主进程 (src/background.js)
│   ├── 窗口管理
│   ├── IPC 通信
│   ├── 文件系统操作
│   └── 业务模块
│       ├── themeNew/     (主题模块)
│       ├── lockscreenNew/ (锁屏模块)
│       └── widget/       (小组件模块)
├── 渲染进程 (src/renderer/)
│   ├── 业务页面
│   ├── Vuex 状态管理
│   └── UI 组件
├── 通用层 (src/universal/)
│   ├── middle/          (中间层业务逻辑)
│   └── datastore/       (数据存储)
└── Preload 脚本 (preload/)
    ├── lockscreen/
    ├── widget/
    └── event.js
```

#### 存在的问题

1. **耦合度较高**：主进程直接处理所有业务逻辑，导出、压缩等耗时操作在主进程执行
2. **扩展性不足**：新增产品线（如天气小组件）需要修改多处代码
3. **稳定性问题**：高耗时任务（主题导出、批量图片处理）会阻塞主进程，导致界面卡顿甚至崩溃
4. **通信层不够统一**：IPC 通信分散在各个模块，缺乏统一的通信抽象层

### 1.2 目标架构设计

#### 理想架构

```
目标架构（四层设计）：

┌─────────────────────────────────────────────────────────────┐
│                    渲染层 (Renderer Layer)                   │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  UI 组件层 (Vue Components)                             │ │
│  │  - 主题编辑器 UI                                         │ │
│  │  - 锁屏编辑器 UI                                         │ │
│  │  - 小组件编辑器 UI                                       │ │
│  │  - 天气编辑器 UI (扩展)                                  │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  状态管理层 (Vuex / Custom Stores)                      │ │
│  │  - 主题 Store                                           │ │
│  │  - 锁屏 Store                                           │ │
│  │  - 小组件 Store                                         │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            ↕ (IPC Bridge)
┌─────────────────────────────────────────────────────────────┐
│                    通信层 (Communication Layer)              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  统一 IPC 通信管理器 (IPCManager)                        │ │
│  │  - 请求/响应模式                                         │ │
│  │  - 事件订阅/发布                                         │ │
│  │  - 错误处理与重试                                        │ │
│  │  - 超时控制                                             │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  API 抽象层 (API Facade)                                │ │
│  │  - ThemeAPI                                             │ │
│  │  - LockscreenAPI                                        │ │
│  │  - WidgetAPI                                            │ │
│  │  - WeatherAPI (扩展)                                    │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                    主进程层 (Main Process Layer)             │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  应用生命周期管理 (App Lifecycle Manager)                │ │
│  │  - 窗口管理                                             │ │
│  │  - 进程协调                                             │ │
│  │  - 资源管理                                             │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  业务协调层 (Business Coordinator)                       │ │
│  │  - 任务分发                                             │ │
│  │  - 状态同步                                             │ │
│  │  - 缓存管理                                             │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  轻量级业务逻辑 (Light Business Logic)                   │ │
│  │  - 文件读写（小文件）                                    │ │
│  │  - 数据库操作 (LowDB)                                   │ │
│  │  - 配置管理                                             │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                    子进程层 (Worker Process Layer)           │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  任务队列管理器 (Task Queue Manager)                     │ │
│  │  - 优先级队列                                           │ │
│  │  - 任务调度                                             │ │
│  │  - 负载均衡                                             │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  Worker Pool (工作进程池)                               │ │
│  │  ├── ThemeWorker (主题导出/打包)                         │ │
│  │  ├── ImageWorker (图片处理/压缩)                         │ │
│  │  ├── LockscreenWorker (锁屏导出)                        │ │
│  │  ├── WidgetWorker (小组件打包)                          │ │
│  │  └── WeatherWorker (天气数据处理) [扩展]                 │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  重量级业务逻辑 (Heavy Business Logic)                   │ │
│  │  - 主题打包 (packTheme)                                 │ │
│  │  - 文件压缩 (compress)                                  │ │
│  │  - 图片批处理 (batch image processing)                  │ │
│  │  - XML 生成与解析                                       │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 1.3 分层设计详解

#### 1.3.1 渲染层 (Renderer Layer)

**职责**：

- 用户界面展示
- 用户交互处理
- 状态管理（Vuex / Custom Stores）
- 本地缓存（IndexedDB）

**实施要点**：

1. **统一状态管理**：

   ```javascript
   // src/renderer/store/modules/product.js
   // 抽象产品线通用状态管理模式

   export const createProductStore = productType => ({
   	namespaced: true,
   	state: {
   		list: [], // 产品列表
   		current: null, // 当前编辑的产品
   		editedData: {}, // 已编辑数据
   		isLoading: false, // 加载状态
   		error: null // 错误信息
   	},
   	mutations: {
   		SET_LIST(state, list) {
   			state.list = list
   		},
   		SET_CURRENT(state, product) {
   			state.current = product
   		},
   		UPDATE_EDITED_DATA(state, { key, value }) {
   			state.editedData[key] = value
   		},
   		SET_LOADING(state, isLoading) {
   			state.isLoading = isLoading
   		},
   		SET_ERROR(state, error) {
   			state.error = error
   		}
   	},
   	actions: {
   		async loadList({ commit }) {
   			commit('SET_LOADING', true)
   			try {
   				const res = await window.electron.callMain(`get${productType}List`)
   				commit('SET_LIST', res.data)
   			} catch (error) {
   				commit('SET_ERROR', error)
   			} finally {
   				commit('SET_LOADING', false)
   			}
   		},
   		async export({ state, commit }, options) {
   			commit('SET_LOADING', true)
   			try {
   				// 通过统一 API 调用导出
   				const res = await window.electron.callMain(`export${productType}`, {
   					id: state.current.id,
   					...options
   				})
   				return res
   			} catch (error) {
   				commit('SET_ERROR', error)
   				throw error
   			} finally {
   				commit('SET_LOADING', false)
   			}
   		}
   	}
   })

   // 使用
   export const themeStore = createProductStore('Theme')
   export const lockscreenStore = createProductStore('Lockscreen')
   export const widgetStore = createProductStore('Widget')
   export const weatherStore = createProductStore('Weather') // 扩展
   ```

2. **UI 组件抽象**：

   ```vue
   <!-- src/renderer/components/ProductEditor/index.vue -->
   <!-- 抽象产品编辑器通用组件 -->
   <template>
   	<div class="product-editor">
   		<ProductToolbar :product-type="productType" />
   		<div class="editor-content">
   			<LeftPanel :product-type="productType" />
   			<Canvas :product-type="productType" />
   			<RightPanel :product-type="productType" />
   		</div>
   		<StatusBar :product-type="productType" />
   	</div>
   </template>

   <script>
   export default {
   	name: 'ProductEditor',
   	props: {
   		productType: {
   			type: String,
   			required: true,
   			validator: val => ['theme', 'lockscreen', 'widget', 'weather'].includes(val)
   		}
   	}
   }
   </script>
   ```

#### 1.3.2 通信层 (Communication Layer)

**职责**：

- 统一 IPC 通信接口
- 请求/响应管理
- 错误处理与重试
- 超时控制
- 事件订阅/发布

**实施要点**：

1. **创建统一的 IPC 管理器**：

   ```javascript
   // src/universal/communication/IPCManager.js

   class IPCManager {
   	constructor() {
   		this.pendingRequests = new Map()
   		this.eventHandlers = new Map()
   		this.requestId = 0
   		this.defaultTimeout = 30000 // 30秒超时
   	}

   	/**
   	 * 发送请求到主进程
   	 * @param {string} channel - 通道名
   	 * @param {object} data - 请求数据
   	 * @param {object} options - 选项（timeout, retry等）
   	 */
   	async request(channel, data = {}, options = {}) {
   		const requestId = ++this.requestId
   		const timeout = options.timeout || this.defaultTimeout
   		const retry = options.retry || 0

   		return new Promise((resolve, reject) => {
   			const timer = setTimeout(() => {
   				this.pendingRequests.delete(requestId)
   				reject(new Error(`Request timeout: ${channel}`))
   			}, timeout)

   			this.pendingRequests.set(requestId, { resolve, reject, timer })

   			// 发送到主进程
   			window.electron.ipcRenderer.send('ipc-request', {
   				requestId,
   				channel,
   				data,
   				retry
   			})
   		})
   	}

   	/**
   	 * 处理主进程响应
   	 */
   	handleResponse(response) {
   		const { requestId, data, error } = response
   		const pending = this.pendingRequests.get(requestId)

   		if (pending) {
   			clearTimeout(pending.timer)
   			this.pendingRequests.delete(requestId)

   			if (error) {
   				pending.reject(new Error(error))
   			} else {
   				pending.resolve(data)
   			}
   		}
   	}

   	/**
   	 * 订阅事件
   	 */
   	on(event, handler) {
   		if (!this.eventHandlers.has(event)) {
   			this.eventHandlers.set(event, [])
   		}
   		this.eventHandlers.get(event).push(handler)
   	}

   	/**
   	 * 取消订阅
   	 */
   	off(event, handler) {
   		const handlers = this.eventHandlers.get(event)
   		if (handlers) {
   			const index = handlers.indexOf(handler)
   			if (index > -1) {
   				handlers.splice(index, 1)
   			}
   		}
   	}

   	/**
   	 * 触发事件
   	 */
   	emit(event, data) {
   		const handlers = this.eventHandlers.get(event) || []
   		handlers.forEach(handler => handler(data))
   	}
   }

   export const ipcManager = new IPCManager()

   // 监听主进程响应
   window.electron.ipcRenderer.on('ipc-response', (event, response) => {
   	ipcManager.handleResponse(response)
   })

   // 监听主进程事件
   window.electron.ipcRenderer.on('ipc-event', (event, { eventName, data }) => {
   	ipcManager.emit(eventName, data)
   })
   ```

2. **创建 API 抽象层**：

   ```javascript
   // src/universal/communication/ProductAPI.js

   import { ipcManager } from './IPCManager'

   /**
    * 产品线 API 基类
    */
   class ProductAPI {
   	constructor(productType) {
   		this.productType = productType
   	}

   	async getList() {
   		return ipcManager.request(`${this.productType}:getList`)
   	}

   	async create(data) {
   		return ipcManager.request(`${this.productType}:create`, data)
   	}

   	async update(id, data) {
   		return ipcManager.request(`${this.productType}:update`, { id, data })
   	}

   	async delete(id) {
   		return ipcManager.request(`${this.productType}:delete`, { id })
   	}

   	async export(id, options) {
   		// 导出操作设置更长的超时时间
   		return ipcManager.request(
   			`${this.productType}:export`,
   			{ id, options },
   			{ timeout: 300000 } // 5分钟
   		)
   	}

   	async import(file) {
   		return ipcManager.request(`${this.productType}:import`, { file })
   	}

   	// 监听导出进度
   	onExportProgress(callback) {
   		ipcManager.on(`${this.productType}:exportProgress`, callback)
   	}

   	offExportProgress(callback) {
   		ipcManager.off(`${this.productType}:exportProgress`, callback)
   	}
   }

   // 各产品线 API
   export const ThemeAPI = new ProductAPI('theme')
   export const LockscreenAPI = new ProductAPI('lockscreen')
   export const WidgetAPI = new ProductAPI('widget')
   export const WeatherAPI = new ProductAPI('weather') // 扩展
   ```

3. **在 Preload 中实现通信桥接**：

   ```javascript
   // preload/communication-bridge.js

   const { contextBridge, ipcRenderer } = require('electron')

   contextBridge.exposeInMainWorld('electron', {
   	ipcRenderer: {
   		send: (channel, data) => {
   			// 白名单验证
   			const validChannels = ['ipc-request']
   			if (validChannels.includes(channel)) {
   				ipcRenderer.send(channel, data)
   			}
   		},
   		on: (channel, func) => {
   			const validChannels = ['ipc-response', 'ipc-event']
   			if (validChannels.includes(channel)) {
   				ipcRenderer.on(channel, (event, ...args) => func(event, ...args))
   			}
   		},
   		removeListener: (channel, func) => {
   			ipcRenderer.removeListener(channel, func)
   		}
   	}
   })
   ```

#### 1.3.3 主进程层 (Main Process Layer)

**职责**：

- 应用生命周期管理
- 窗口管理
- 任务分发与协调
- 轻量级业务逻辑
- 数据库操作

**实施要点**：

1. **重构主进程入口**：

   ```javascript
   // src/electron/main.js (重构后的 background.js)

   const { app, BrowserWindow } = require('electron')
   const { AppLifecycleManager } = require('./core/AppLifecycleManager')
   const { IPCRouter } = require('./core/IPCRouter')
   const { TaskDispatcher } = require('./core/TaskDispatcher')

   class Application {
   	constructor() {
   		this.lifecycleManager = new AppLifecycleManager()
   		this.ipcRouter = new IPCRouter()
   		this.taskDispatcher = new TaskDispatcher()
   	}

   	async initialize() {
   		// 初始化应用
   		await this.lifecycleManager.initialize()

   		// 注册 IPC 路由
   		this.registerRoutes()

   		// 启动任务调度器
   		await this.taskDispatcher.start()
   	}

   	registerRoutes() {
   		// 主题相关路由
   		this.ipcRouter.register('theme', require('./modules/theme'))

   		// 锁屏相关路由
   		this.ipcRouter.register('lockscreen', require('./modules/lockscreen'))

   		// 小组件相关路由
   		this.ipcRouter.register('widget', require('./modules/widget'))

   		// 天气相关路由（扩展）
   		this.ipcRouter.register('weather', require('./modules/weather'))
   	}

   	async start() {
   		await this.initialize()
   		await this.lifecycleManager.createMainWindow()
   	}
   }

   const application = new Application()

   app.whenReady().then(() => {
   	application.start()
   })
   ```

2. **创建 IPC 路由器**：

   ```javascript
   // src/electron/core/IPCRouter.js

   const { ipcMain } = require('electron')
   const log = require('electron-log')

   class IPCRouter {
   	constructor() {
   		this.routes = new Map()
   		this.setupListener()
   	}

   	setupListener() {
   		ipcMain.on('ipc-request', async (event, request) => {
   			const { requestId, channel, data, retry } = request

   			try {
   				// 解析路由：theme:export -> module=theme, action=export
   				const [module, action] = channel.split(':')

   				const handler = this.routes.get(module)
   				if (!handler || !handler[action]) {
   					throw new Error(`No handler for ${channel}`)
   				}

   				// 执行处理器
   				const result = await handler[action](data)

   				// 返回响应
   				event.reply('ipc-response', {
   					requestId,
   					data: result
   				})
   			} catch (error) {
   				log.error(`IPC Error: ${channel}`, error)

   				// 返回错误
   				event.reply('ipc-response', {
   					requestId,
   					error: error.message
   				})
   			}
   		})
   	}

   	register(module, handler) {
   		this.routes.set(module, handler)
   	}
   }

   module.exports = { IPCRouter }
   ```

3. **创建任务分发器**：

   ```javascript
   // src/electron/core/TaskDispatcher.js

   const { fork } = require('child_process')
   const path = require('path')
   const log = require('electron-log')

   class TaskDispatcher {
   	constructor() {
   		this.workerPool = new Map()
   		this.taskQueue = []
   		this.maxWorkers = require('os').cpus().length
   	}

   	async start() {
   		// 创建 Worker Pool
   		this.createWorkerPool()
   	}

   	createWorkerPool() {
   		const workerTypes = ['theme', 'image', 'lockscreen', 'widget']

   		workerTypes.forEach(type => {
   			const workerPath = path.resolve(__dirname, '../workers', `${type}-worker.js`)
   			const worker = fork(workerPath)

   			worker.on('message', message => {
   				this.handleWorkerMessage(type, message)
   			})

   			worker.on('error', error => {
   				log.error(`Worker ${type} error:`, error)
   			})

   			worker.on('exit', code => {
   				log.info(`Worker ${type} exited with code ${code}`)
   				// 重启 worker
   				this.restartWorker(type)
   			})

   			this.workerPool.set(type, {
   				process: worker,
   				busy: false,
   				tasks: []
   			})
   		})
   	}

   	/**
   	 * 分发任务到子进程
   	 * @param {string} workerType - worker 类型
   	 * @param {string} taskType - 任务类型
   	 * @param {object} data - 任务数据
   	 * @param {number} priority - 优先级 (1-10, 10最高)
   	 */
   	async dispatch(workerType, taskType, data, priority = 5) {
   		return new Promise((resolve, reject) => {
   			const task = {
   				id: Date.now() + Math.random(),
   				workerType,
   				taskType,
   				data,
   				priority,
   				resolve,
   				reject,
   				createdAt: Date.now()
   			}

   			// 加入任务队列
   			this.taskQueue.push(task)

   			// 按优先级排序
   			this.taskQueue.sort((a, b) => b.priority - a.priority)

   			// 尝试执行任务
   			this.executeNext()
   		})
   	}

   	executeNext() {
   		if (this.taskQueue.length === 0) return

   		// 找到空闲的 worker
   		for (const [type, worker] of this.workerPool) {
   			if (!worker.busy && this.taskQueue.length > 0) {
   				// 找到匹配的任务
   				const taskIndex = this.taskQueue.findIndex(t => t.workerType === type)
   				if (taskIndex > -1) {
   					const task = this.taskQueue.splice(taskIndex, 1)[0]
   					this.executeTask(worker, task)
   				}
   			}
   		}
   	}

   	executeTask(worker, task) {
   		worker.busy = true
   		worker.tasks.push(task)

   		// 发送任务到 worker
   		worker.process.send({
   			taskId: task.id,
   			type: task.taskType,
   			data: task.data
   		})
   	}

   	handleWorkerMessage(workerType, message) {
   		const worker = this.workerPool.get(workerType)
   		if (!worker) return

   		const { taskId, result, error, progress } = message

   		// 查找任务
   		const taskIndex = worker.tasks.findIndex(t => t.id === taskId)
   		if (taskIndex === -1) return

   		const task = worker.tasks[taskIndex]

   		if (progress !== undefined) {
   			// 进度更新
   			this.notifyProgress(task, progress)
   		} else if (error) {
   			// 任务失败
   			worker.tasks.splice(taskIndex, 1)
   			worker.busy = false
   			task.reject(new Error(error))
   			this.executeNext()
   		} else {
   			// 任务成功
   			worker.tasks.splice(taskIndex, 1)
   			worker.busy = false
   			task.resolve(result)
   			this.executeNext()
   		}
   	}

   	notifyProgress(task, progress) {
   		// 通知渲染进程进度更新
   		const mainWindow = require('./AppLifecycleManager').getMainWindow()
   		if (mainWindow) {
   			mainWindow.webContents.send('ipc-event', {
   				eventName: `${task.workerType}:${task.taskType}:progress`,
   				data: {
   					taskId: task.id,
   					progress
   				}
   			})
   		}
   	}

   	restartWorker(type) {
   		const worker = this.workerPool.get(type)
   		if (worker) {
   			worker.process.kill()
   		}

   		// 重新创建
   		setTimeout(() => {
   			this.createWorkerPool()
   		}, 1000)
   	}
   }

   module.exports = { TaskDispatcher }
   ```

4. **重构业务模块**：

   ```javascript
   // src/electron/modules/theme/index.js

   const { TaskDispatcher } = require('../../core/TaskDispatcher')
   const utils = require('../../utils')
   const log = require('electron-log')

   class ThemeModule {
   	constructor() {
   		this.dispatcher = new TaskDispatcher()
   	}

   	/**
   	 * 获取主题列表（轻量级操作，主进程处理）
   	 */
   	async getList() {
   		const themes = utils.getLocalData('themes', null) || []
   		return {
   			code: 0,
   			data: themes
   		}
   	}

   	/**
   	 * 创建主题（轻量级操作，主进程处理）
   	 */
   	async create(data) {
   		const { createTheme } = require('./create')
   		return await createTheme(data)
   	}

   	/**
   	 * 导出主题（重量级操作，分发到子进程）
   	 */
   	async export(data) {
   		const { themeID, osVersions, settingsIcons } = data

   		try {
   			// 分发到 theme worker，优先级为 8（高优先级）
   			const result = await this.dispatcher.dispatch('theme', 'export', { themeID, osVersions, settingsIcons }, 8)

   			return {
   				code: 0,
   				data: result
   			}
   		} catch (error) {
   			log.error('Theme export failed:', error)
   			return {
   				code: 9999,
   				message: error.message
   			}
   		}
   	}

   	/**
   	 * 批量导入主题（重量级操作，分发到子进程）
   	 */
   	async import(data) {
   		const { files } = data

   		try {
   			const result = await this.dispatcher.dispatch(
   				'theme',
   				'import',
   				{ files },
   				5 // 中等优先级
   			)

   			return {
   				code: 0,
   				data: result
   			}
   		} catch (error) {
   			return {
   				code: 9999,
   				message: error.message
   			}
   		}
   	}
   }

   module.exports = new ThemeModule()
   ```

#### 1.3.4 子进程层 (Worker Process Layer)

**职责**：

- 执行重量级任务
- 文件压缩/解压
- 图片批处理
- 主题/锁屏打包
- 复杂计算

**实施要点**：

1. **创建 Worker 基类**：

   ```javascript
   // src/electron/workers/BaseWorker.js

   const log = require('electron-log')

   class BaseWorker {
   	constructor(workerName) {
   		this.workerName = workerName
   		this.setupMessageHandler()
   	}

   	setupMessageHandler() {
   		process.on('message', async message => {
   			const { taskId, type, data } = message

   			try {
   				// 执行任务
   				const result = await this.handleTask(type, data, progress => {
   					// 发送进度
   					this.sendProgress(taskId, progress)
   				})

   				// 发送结果
   				this.sendResult(taskId, result)
   			} catch (error) {
   				log.error(`${this.workerName} task failed:`, error)
   				this.sendError(taskId, error.message)
   			}
   		})
   	}

   	/**
   	 * 子类需要实现此方法
   	 * @param {string} type - 任务类型
   	 * @param {object} data - 任务数据
   	 * @param {function} onProgress - 进度回调
   	 */
   	async handleTask(type, data, onProgress) {
   		throw new Error('handleTask must be implemented')
   	}

   	sendProgress(taskId, progress) {
   		process.send({
   			taskId,
   			progress
   		})
   	}

   	sendResult(taskId, result) {
   		process.send({
   			taskId,
   			result
   		})
   	}

   	sendError(taskId, error) {
   		process.send({
   			taskId,
   			error
   		})
   	}
   }

   module.exports = { BaseWorker }
   ```

2. **创建主题 Worker**：

   ```javascript
   // src/electron/workers/theme-worker.js

   const { BaseWorker } = require('./BaseWorker')
   const { packTheme, outputTheme } = require('../themeNew/output')
   const utils = require('../utils')
   const path = require('path')
   const log = require('electron-log')

   class ThemeWorker extends BaseWorker {
   	constructor() {
   		super('ThemeWorker')
   	}

   	async handleTask(type, data, onProgress) {
   		switch (type) {
   			case 'export':
   				return await this.handleExport(data, onProgress)
   			case 'import':
   				return await this.handleImport(data, onProgress)
   			case 'pack':
   				return await this.handlePack(data, onProgress)
   			default:
   				throw new Error(`Unknown task type: ${type}`)
   		}
   	}

   	async handleExport(data, onProgress) {
   		const { themeID, osVersions, settingsIcons } = data

   		onProgress(0)

   		// 执行导出
   		const result = await outputTheme({
   			themeID,
   			osVersions,
   			settingsIcons
   		})

   		onProgress(100)

   		return result
   	}

   	async handleImport(data, onProgress) {
   		const { files } = data
   		const results = []

   		for (let i = 0; i < files.length; i++) {
   			const file = files[i]

   			// 更新进度
   			onProgress(Math.floor((i / files.length) * 100))

   			// 导入主题
   			const result = await this.importSingleTheme(file)
   			results.push(result)
   		}

   		onProgress(100)

   		return results
   	}

   	async handlePack(data, onProgress) {
   		const { source, target, osVersion } = data

   		onProgress(0)

   		const result = await packTheme(target, source, osVersion)

   		onProgress(100)

   		return result
   	}

   	async importSingleTheme(file) {
   		// 实现单个主题导入逻辑
   		const { input } = require('../themeNew/input')
   		return await input(file)
   	}
   }

   // 启动 worker
   new ThemeWorker()

   log.info('ThemeWorker started')
   ```

3. **创建图片处理 Worker**：

   ```javascript
   // src/electron/workers/image-worker.js

   const { BaseWorker } = require('./BaseWorker')
   const sharp = require('sharp') // 使用 sharp 库进行图片处理
   const fs = require('fs-extra')
   const path = require('path')

   class ImageWorker extends BaseWorker {
   	constructor() {
   		super('ImageWorker')
   	}

   	async handleTask(type, data, onProgress) {
   		switch (type) {
   			case 'compress':
   				return await this.handleCompress(data, onProgress)
   			case 'resize':
   				return await this.handleResize(data, onProgress)
   			case 'batch':
   				return await this.handleBatch(data, onProgress)
   			default:
   				throw new Error(`Unknown task type: ${type}`)
   		}
   	}

   	async handleCompress(data, onProgress) {
   		const { source, target, quality = 80 } = data

   		onProgress(0)

   		await sharp(source).jpeg({ quality }).toFile(target)

   		onProgress(100)

   		return { success: true, file: target }
   	}

   	async handleResize(data, onProgress) {
   		const { source, target, width, height } = data

   		onProgress(0)

   		await sharp(source).resize(width, height).toFile(target)

   		onProgress(100)

   		return { success: true, file: target }
   	}

   	async handleBatch(data, onProgress) {
   		const { files, operation } = data
   		const results = []

   		for (let i = 0; i < files.length; i++) {
   			const file = files[i]

   			onProgress(Math.floor((i / files.length) * 100))

   			const result = await this.processSingleFile(file, operation)
   			results.push(result)
   		}

   		onProgress(100)

   		return results
   	}

   	async processSingleFile(file, operation) {
   		// 根据操作类型处理单个文件
   		switch (operation.type) {
   			case 'compress':
   				return await this.handleCompress(
   					{
   						source: file.source,
   						target: file.target,
   						quality: operation.quality
   					},
   					() => {}
   				)
   			case 'resize':
   				return await this.handleResize(
   					{
   						source: file.source,
   						target: file.target,
   						width: operation.width,
   						height: operation.height
   					},
   					() => {}
   				)
   			default:
   				throw new Error(`Unknown operation: ${operation.type}`)
   		}
   	}
   }

   new ImageWorker()
   ```

### 1.4 实施步骤

#### 阶段一：基础架构搭建（2 周）

**目标**：建立通信层和主进程协调层

1. **第 1-3 天**：创建 IPC 管理器和 API 抽象层

   - 实现 `IPCManager` 类
   - 实现 `ProductAPI` 基类
   - 更新 preload 脚本

2. **第 4-7 天**：重构主进程

   - 创建 `IPCRouter`
   - 创建 `AppLifecycleManager`
   - 创建 `TaskDispatcher`
   - 重构 `background.js` 为 `main.js`

3. **第 8-10 天**：创建 Worker 基础设施

   - 实现 `BaseWorker` 类
   - 创建 Worker Pool 管理
   - 实现任务队列

4. **第 11-14 天**：测试与调试
   - 单元测试
   - 集成测试
   - 性能测试

#### 阶段二：业务模块迁移（3 周）

**目标**：将现有业务逻辑迁移到新架构

1. **第 1 周**：主题模块迁移

   - 创建 `ThemeWorker`
   - 迁移导出逻辑到子进程
   - 迁移导入逻辑到子进程
   - 更新渲染层调用

2. **第 2 周**：锁屏模块迁移

   - 创建 `LockscreenWorker`
   - 迁移导出逻辑
   - 迁移导入逻辑

3. **第 3 周**：小组件模块迁移
   - 创建 `WidgetWorker`
   - 迁移相关逻辑

#### 阶段三：优化与扩展（2 周）

**目标**：性能优化和扩展能力验证

1. **第 1 周**：性能优化

   - Worker Pool 调优
   - 任务队列优化
   - 内存管理优化

2. **第 2 周**：扩展验证
   - 添加天气模块（作为扩展能力验证）
   - 文档完善
   - 培训开发团队

---

## 二、子进程与任务队列方案

### 2.1 当前问题分析

#### 问题表现

1. **界面卡顿**：

   - 主题导出时，主进程执行大量文件操作（压缩、XML 生成）
   - 批量图片处理时，主进程被阻塞
   - 用户无法进行其他操作

2. **应用崩溃**：

   - 大型主题包导出时，内存占用过高
   - 主进程超时导致渲染进程失去响应
   - 错误处理不当导致进程崩溃

3. **无优先级管理**：
   - 所有任务按顺序执行
   - 用户交互任务与后台任务无区分
   - 无法中断低优先级任务

#### 根本原因

```javascript
// 当前实现 (src/electron/themeNew/output.js)
// 所有操作都在主进程同步执行

const outputTheme = async({ themeID, osVersions = [], settingsIcons = [] }) => {
  // 1. 文件操作（阻塞主进程）
  await utils.copyPro(path.resolve(dir_themes, themeID), themeTempDir)

  // 2. 清理主题包（阻塞主进程）
  const cleanRes = await cleanTheme(themeTempDir, osVersion, needRename, selfOsVersion, settingsIcons)

  // 3. 处理资源（阻塞主进程）
  await dealItems(themeTempDir, mergeData(...))

  // 4. 压缩打包（阻塞主进程）
  await utils.compress(themeTempDir, tgt, osVersion)

  // 主进程被完全阻塞，无法响应用户交互
}
```

### 2.2 子进程架构设计

#### 设计原则

1. **进程隔离**：重量级任务在独立子进程执行，崩溃不影响主进程
2. **资源限制**：每个子进程有内存和 CPU 限制
3. **任务分片**：大任务拆分为小任务，支持中断和恢复
4. **进度反馈**：实时向主进程报告进度

#### Worker 类型划分

```
Worker Pool:
├── ThemeWorker (主题相关)
│   ├── 导出主题
│   ├── 导入主题
│   ├── 打包主题
│   └── 校验主题
├── ImageWorker (图片处理)
│   ├── 图片压缩
│   ├── 图片缩放
│   ├── 批量处理
│   └── 格式转换
├── LockscreenWorker (锁屏相关)
│   ├── 导出锁屏
│   ├── 导入锁屏
│   └── 生成预览
├── WidgetWorker (小组件相关)
│   ├── 导出小组件
│   ├── 导入小组件
│   └── 打包小组件
└── WeatherWorker (天气相关，扩展)
    ├── 数据处理
    └── 资源打包
```

### 2.3 任务队列设计

#### 优先级定义

```javascript
// src/electron/core/TaskPriority.js

const TaskPriority = {
	CRITICAL: 10, // 关键任务（用户等待的导出）
	HIGH: 8, // 高优先级（用户触发的操作）
	NORMAL: 5, // 普通优先级（后台任务）
	LOW: 3, // 低优先级（预加载、缓存）
	IDLE: 1 // 空闲任务（清理、统计）
}

module.exports = { TaskPriority }
```

#### 任务队列实现

```javascript
// src/electron/core/TaskQueue.js

const { EventEmitter } = require('events')
const log = require('electron-log')

class TaskQueue extends EventEmitter {
	constructor(options = {}) {
		super()
		this.maxConcurrent = options.maxConcurrent || 4
		this.tasks = []
		this.running = []
		this.paused = false
	}

	/**
	 * 添加任务
	 * @param {object} task - 任务对象
	 * @param {number} task.priority - 优先级 (1-10)
	 * @param {string} task.type - 任务类型
	 * @param {function} task.execute - 执行函数
	 * @param {boolean} task.cancellable - 是否可取消
	 */
	add(task) {
		task.id = Date.now() + Math.random()
		task.status = 'pending'
		task.createdAt = Date.now()

		// 插入队列（按优先级排序）
		this.tasks.push(task)
		this.tasks.sort((a, b) => b.priority - a.priority)

		this.emit('taskAdded', task)

		// 尝试执行
		this.processNext()

		return task.id
	}

	/**
	 * 处理下一个任务
	 */
	async processNext() {
		if (this.paused) return
		if (this.running.length >= this.maxConcurrent) return
		if (this.tasks.length === 0) return

		const task = this.tasks.shift()
		task.status = 'running'
		task.startedAt = Date.now()

		this.running.push(task)
		this.emit('taskStarted', task)

		try {
			const result = await task.execute()

			task.status = 'completed'
			task.completedAt = Date.now()
			task.result = result

			this.emit('taskCompleted', task)
		} catch (error) {
			task.status = 'failed'
			task.error = error

			this.emit('taskFailed', task, error)

			// 重试逻辑
			if (task.retry && task.retryCount < task.retry) {
				task.retryCount = (task.retryCount || 0) + 1
				task.status = 'pending'
				this.tasks.unshift(task) // 重新加入队列头部
			}
		} finally {
			// 从运行列表移除
			const index = this.running.findIndex(t => t.id === task.id)
			if (index > -1) {
				this.running.splice(index, 1)
			}

			// 处理下一个任务
			this.processNext()
		}
	}

	/**
	 * 取消任务
	 */
	cancel(taskId) {
		// 从待执行队列中移除
		const pendingIndex = this.tasks.findIndex(t => t.id === taskId)
		if (pendingIndex > -1) {
			const task = this.tasks.splice(pendingIndex, 1)[0]
			task.status = 'cancelled'
			this.emit('taskCancelled', task)
			return true
		}

		// 尝试取消正在运行的任务
		const runningTask = this.running.find(t => t.id === taskId)
		if (runningTask && runningTask.cancellable && runningTask.cancel) {
			runningTask.cancel()
			runningTask.status = 'cancelled'
			this.emit('taskCancelled', runningTask)
			return true
		}

		return false
	}

	/**
	 * 暂停队列
	 */
	pause() {
		this.paused = true
		this.emit('queuePaused')
	}

	/**
	 * 恢复队列
	 */
	resume() {
		this.paused = false
		this.emit('queueResumed')
		this.processNext()
	}

	/**
	 * 清空队列
	 */
	clear() {
		this.tasks.forEach(task => {
			task.status = 'cancelled'
			this.emit('taskCancelled', task)
		})
		this.tasks = []
	}

	/**
	 * 获取队列状态
	 */
	getStatus() {
		return {
			pending: this.tasks.length,
			running: this.running.length,
			paused: this.paused
		}
	}
}

module.exports = { TaskQueue }
```

#### 任务调度器增强版

```javascript
// src/electron/core/TaskDispatcher.js (增强版)

const { fork } = require('child_process')
const { TaskQueue } = require('./TaskQueue')
const { TaskPriority } = require('./TaskPriority')
const path = require('path')
const log = require('electron-log')
const os = require('os')

class TaskDispatcher {
	constructor() {
		this.workerPool = new Map()
		this.taskQueue = new TaskQueue({
			maxConcurrent: os.cpus().length
		})

		// 监听队列事件
		this.setupQueueListeners()
	}

	async start() {
		this.createWorkerPool()
	}

	createWorkerPool() {
		const workerTypes = ['theme', 'image', 'lockscreen', 'widget']

		workerTypes.forEach(type => {
			const workerPath = path.resolve(__dirname, '../workers', `${type}-worker.js`)
			const worker = fork(workerPath, [], {
				// 设置子进程环境
				env: {
					...process.env,
					WORKER_TYPE: type
				},
				// 限制内存（可选）
				execArgv: ['--max-old-space-size=2048']
			})

			worker.on('message', message => {
				this.handleWorkerMessage(type, message)
			})

			worker.on('error', error => {
				log.error(`Worker ${type} error:`, error)
				this.notifyError(type, error)
			})

			worker.on('exit', code => {
				log.info(`Worker ${type} exited with code ${code}`)
				if (code !== 0) {
					// 非正常退出，重启 worker
					this.restartWorker(type)
				}
			})

			this.workerPool.set(type, {
				process: worker,
				busy: false,
				currentTask: null,
				stats: {
					tasksCompleted: 0,
					tasksFailed: 0,
					totalTime: 0
				}
			})
		})
	}

	setupQueueListeners() {
		this.taskQueue.on('taskStarted', task => {
			log.info(`Task started: ${task.type}`, task.id)
			this.notifyTaskStatus(task, 'started')
		})

		this.taskQueue.on('taskCompleted', task => {
			log.info(`Task completed: ${task.type}`, task.id)
			this.notifyTaskStatus(task, 'completed')

			// 更新 worker 统计
			const worker = this.workerPool.get(task.workerType)
			if (worker) {
				worker.stats.tasksCompleted++
				worker.stats.totalTime += task.completedAt - task.startedAt
			}
		})

		this.taskQueue.on('taskFailed', (task, error) => {
			log.error(`Task failed: ${task.type}`, task.id, error)
			this.notifyTaskStatus(task, 'failed', error)

			// 更新 worker 统计
			const worker = this.workerPool.get(task.workerType)
			if (worker) {
				worker.stats.tasksFailed++
			}
		})

		this.taskQueue.on('taskCancelled', task => {
			log.info(`Task cancelled: ${task.type}`, task.id)
			this.notifyTaskStatus(task, 'cancelled')
		})
	}

	/**
	 * 分发任务（增强版）
	 * @param {string} workerType - worker 类型
	 * @param {string} taskType - 任务类型
	 * @param {object} data - 任务数据
	 * @param {object} options - 选项
	 * @param {number} options.priority - 优先级
	 * @param {boolean} options.cancellable - 是否可取消
	 * @param {number} options.retry - 重试次数
	 * @param {number} options.timeout - 超时时间（毫秒）
	 */
	async dispatch(workerType, taskType, data, options = {}) {
		const {
			priority = TaskPriority.NORMAL,
			cancellable = true,
			retry = 0,
			timeout = 300000 // 默认5分钟
		} = options

		return new Promise((resolve, reject) => {
			const worker = this.workerPool.get(workerType)
			if (!worker) {
				reject(new Error(`Worker ${workerType} not found`))
				return
			}

			let timeoutTimer = null
			let cancelled = false

			const task = {
				workerType,
				taskType,
				data,
				priority,
				cancellable,
				retry,
				execute: async () => {
					return new Promise((resolveTask, rejectTask) => {
						// 设置超时
						if (timeout > 0) {
							timeoutTimer = setTimeout(() => {
								if (!cancelled) {
									rejectTask(new Error(`Task timeout: ${taskType}`))
								}
							}, timeout)
						}

						// 标记 worker 为忙碌
						worker.busy = true
						worker.currentTask = task

						// 发送任务到 worker
						worker.process.send({
							taskId: task.id,
							type: taskType,
							data
						})

						// 保存回调
						task.resolveTask = resolveTask
						task.rejectTask = rejectTask
					})
				},
				cancel: () => {
					cancelled = true
					if (timeoutTimer) {
						clearTimeout(timeoutTimer)
					}
					// 通知 worker 取消任务
					worker.process.send({
						taskId: task.id,
						type: 'cancel'
					})
				}
			}

			// 添加到队列
			const taskId = this.taskQueue.add(task)

			// 返回 Promise
			task
				.execute()
				.then(result => {
					if (timeoutTimer) {
						clearTimeout(timeoutTimer)
					}
					resolve(result)
				})
				.catch(error => {
					if (timeoutTimer) {
						clearTimeout(timeoutTimer)
					}
					reject(error)
				})
		})
	}

	handleWorkerMessage(workerType, message) {
		const worker = this.workerPool.get(workerType)
		if (!worker || !worker.currentTask) return

		const { taskId, result, error, progress } = message
		const task = worker.currentTask

		if (task.id !== taskId) return

		if (progress !== undefined) {
			// 进度更新
			this.notifyProgress(task, progress)
		} else if (error) {
			// 任务失败
			worker.busy = false
			worker.currentTask = null
			if (task.rejectTask) {
				task.rejectTask(new Error(error))
			}
		} else {
			// 任务成功
			worker.busy = false
			worker.currentTask = null
			if (task.resolveTask) {
				task.resolveTask(result)
			}
		}
	}

	notifyTaskStatus(task, status, error = null) {
		const mainWindow = require('./AppLifecycleManager').getMainWindow()
		if (mainWindow) {
			mainWindow.webContents.send('ipc-event', {
				eventName: 'task:status',
				data: {
					taskId: task.id,
					workerType: task.workerType,
					taskType: task.taskType,
					status,
					error: error ? error.message : null
				}
			})
		}
	}

	notifyProgress(task, progress) {
		const mainWindow = require('./AppLifecycleManager').getMainWindow()
		if (mainWindow) {
			mainWindow.webContents.send('ipc-event', {
				eventName: `${task.workerType}:${task.taskType}:progress`,
				data: {
					taskId: task.id,
					progress
				}
			})
		}
	}

	notifyError(workerType, error) {
		const mainWindow = require('./AppLifecycleManager').getMainWindow()
		if (mainWindow) {
			mainWindow.webContents.send('ipc-event', {
				eventName: 'worker:error',
				data: {
					workerType,
					error: error.message
				}
			})
		}
	}

	restartWorker(type) {
		const worker = this.workerPool.get(type)
		if (worker) {
			try {
				worker.process.kill()
			} catch (e) {
				log.error(`Failed to kill worker ${type}:`, e)
			}
		}

		// 延迟重启
		setTimeout(() => {
			log.info(`Restarting worker: ${type}`)
			const workerPath = path.resolve(__dirname, '../workers', `${type}-worker.js`)
			const newWorker = fork(workerPath, [], {
				env: {
					...process.env,
					WORKER_TYPE: type
				},
				execArgv: ['--max-old-space-size=2048']
			})

			newWorker.on('message', message => {
				this.handleWorkerMessage(type, message)
			})

			newWorker.on('error', error => {
				log.error(`Worker ${type} error:`, error)
				this.notifyError(type, error)
			})

			newWorker.on('exit', code => {
				log.info(`Worker ${type} exited with code ${code}`)
				if (code !== 0) {
					this.restartWorker(type)
				}
			})

			this.workerPool.set(type, {
				process: newWorker,
				busy: false,
				currentTask: null,
				stats: {
					tasksCompleted: 0,
					tasksFailed: 0,
					totalTime: 0
				}
			})
		}, 2000)
	}

	/**
	 * 获取调度器状态
	 */
	getStatus() {
		const workers = {}
		this.workerPool.forEach((worker, type) => {
			workers[type] = {
				busy: worker.busy,
				stats: worker.stats
			}
		})

		return {
			queue: this.taskQueue.getStatus(),
			workers
		}
	}

	/**
	 * 暂停所有任务
	 */
	pause() {
		this.taskQueue.pause()
	}

	/**
	 * 恢复所有任务
	 */
	resume() {
		this.taskQueue.resume()
	}

	/**
	 * 取消任务
	 */
	cancelTask(taskId) {
		return this.taskQueue.cancel(taskId)
	}
}

module.exports = { TaskDispatcher }
```

### 2.4 实施步骤

#### 阶段一：子进程基础设施（1 周）

1. **第 1-2 天**：创建 Worker 基类和通信机制

   - 实现 `BaseWorker`
   - 实现进程间通信协议
   - 实现进度报告机制

2. **第 3-4 天**：创建任务队列

   - 实现 `TaskQueue` 类
   - 实现优先级管理
   - 实现任务取消机制

3. **第 5-7 天**：集成到主进程
   - 实现 `TaskDispatcher`
   - 创建 Worker Pool
   - 测试基础功能

#### 阶段二：迁移重量级任务（2 周）

1. **第 1 周**：主题导出迁移

   - 创建 `ThemeWorker`
   - 迁移 `outputTheme` 到子进程
   - 迁移 `packTheme` 到子进程
   - 实现进度反馈

2. **第 2 周**：其他任务迁移
   - 创建 `ImageWorker`（图片处理）
   - 创建 `LockscreenWorker`
   - 创建 `WidgetWorker`
   - 批量操作优化

#### 阶段三：优化与测试（1 周）

1. **第 1-3 天**：性能优化

   - Worker Pool 大小调优
   - 任务队列算法优化
   - 内存管理优化

2. **第 4-5 天**：稳定性测试

   - 压力测试（大量任务）
   - 崩溃恢复测试
   - 内存泄漏检测

3. **第 6-7 天**：用户体验优化
   - 进度展示优化
   - 错误提示优化
   - 取消操作优化

### 2.5 任务取消机制详解

#### 2.5.1 任务取消的三种状态

任务在不同生命周期阶段的可取消性：

| 状态          | 可取消性      | 说明                               |
| ------------- | ------------- | ---------------------------------- |
| **PENDING**   | ✅ 完全可取消 | 任务在队列中等待，可直接从队列移除 |
| **RUNNING**   | ⚠️ 取决于实现 | 任务正在执行，需要任务本身支持取消 |
| **COMPLETED** | ❌ 无法取消   | 任务已完成，无法撤销               |
| **FAILED**    | ❌ 无法取消   | 任务已失败                         |
| **CANCELLED** | ❌ 无法取消   | 任务已被取消                       |

#### 2.5.2 任务取消实现

**改进的 TaskQueue 取消逻辑：**

```javascript
// src/electron/core/TaskQueue.js (改进版)

class TaskQueue {
	/**
	 * 取消任务
	 * @param {string} taskId - 任务 ID
	 * @returns {object} 取消结果
	 */
	cancel(taskId) {
		// 情况1: 任务还在队列中（PENDING）
		const pendingIndex = this.tasks.findIndex(t => t.id === taskId)
		if (pendingIndex > -1) {
			const task = this.tasks.splice(pendingIndex, 1)[0]
			task.status = 'cancelled'
			this.emit('taskCancelled', task)

			log.info(`Task cancelled (from queue): ${taskId}`)
			return {
				success: true,
				reason: 'removed_from_queue',
				message: '任务已从队列中移除'
			}
		}

		// 情况2: 任务正在执行（RUNNING）
		const runningTask = this.running.find(t => t.id === taskId)
		if (runningTask) {
			// ⚠️ 关键点：只有任务本身支持取消才能取消
			if (runningTask.cancellable && typeof runningTask.cancel === 'function') {
				try {
					runningTask.cancel() // 调用任务的取消方法
					runningTask.status = 'cancelling' // 标记为取消中
					this.emit('taskCancelling', runningTask)

					log.info(`Task cancelling (running): ${taskId}`)
					return {
						success: true,
						reason: 'task_cancelling',
						message: '正在取消任务...'
					}
				} catch (error) {
					log.error(`Failed to cancel task: ${taskId}`, error)
					return {
						success: false,
						reason: 'cancel_failed',
						error: error.message,
						message: '取消任务失败'
					}
				}
			} else {
				// ❌ 任务不支持取消，只能等待完成
				log.warn(`Task not cancellable: ${taskId}`)
				return {
					success: false,
					reason: 'not_cancellable',
					message: '该任务不支持取消，请等待完成'
				}
			}
		}

		// 情况3: 任务不存在或已完成
		log.warn(`Task not found: ${taskId}`)
		return {
			success: false,
			reason: 'task_not_found',
			message: '任务不存在或已完成'
		}
	}
}
```

#### 2.5.3 Worker 中实现可取消任务

**支持取消的 ThemeWorker 实现：**

```javascript
// src/electron/workers/theme-worker.js (支持取消版本)

const { BaseWorker } = require('./BaseWorker')
const log = require('electron-log')

class ThemeWorker extends BaseWorker {
	constructor() {
		super('ThemeWorker')
		this.currentTaskId = null
		this.shouldCancel = false
	}

	setupMessageHandler() {
		process.on('message', async message => {
			const { taskId, type, data } = message

			// 处理取消请求
			if (type === 'cancel') {
				if (this.currentTaskId === taskId) {
					log.info(`[ThemeWorker] Cancelling task: ${taskId}`)
					this.shouldCancel = true
					this.sendResult(taskId, { cancelled: true })
				}
				return
			}

			// 执行任务
			this.currentTaskId = taskId
			this.shouldCancel = false

			try {
				const result = await this.handleTask(type, data, progress => {
					// ✅ 关键：在进度回调中检查取消标志
					if (this.shouldCancel) {
						throw new Error('Task cancelled by user')
					}
					this.sendProgress(taskId, progress)
				})

				if (!this.shouldCancel) {
					this.sendResult(taskId, result)
				}
			} catch (error) {
				if (error.message === 'Task cancelled by user') {
					log.info(`[ThemeWorker] Task cancelled: ${taskId}`)
					this.sendResult(taskId, { cancelled: true })
				} else {
					log.error(`[ThemeWorker] Task failed: ${taskId}`, error)
					this.sendError(taskId, error.message)
				}
			} finally {
				this.currentTaskId = null
				this.shouldCancel = false
			}
		})
	}

	async handleExport(data, onProgress) {
		const { themeID, osVersions, settingsIcons } = data
		const steps = [
			{ name: '复制文件', weight: 20 },
			{ name: '清理主题包', weight: 30 },
			{ name: '处理资源', weight: 30 },
			{ name: '压缩打包', weight: 20 }
		]

		let currentProgress = 0

		for (let i = 0; i < steps.length; i++) {
			const step = steps[i]

			// ✅ 关键：在每个步骤前检查取消标志
			if (this.shouldCancel) {
				throw new Error('Task cancelled by user')
			}

			log.info(`[ThemeWorker] 执行步骤: ${step.name}`)

			// 执行步骤
			await this.executeStep(i, data, stepProgress => {
				// 计算总进度
				const totalProgress = currentProgress + (step.weight * stepProgress) / 100
				onProgress(totalProgress)
			})

			currentProgress += step.weight
			onProgress(currentProgress)
		}

		return {
			success: true,
			outputPath: `/path/to/theme/${themeID}.theme`
		}
	}

	async executeStep(stepIndex, data, onProgress) {
		// 模拟长时间操作，支持取消
		const iterations = 100
		for (let i = 0; i < iterations; i++) {
			// ✅ 在循环中检查取消标志
			if (this.shouldCancel) {
				throw new Error('Task cancelled by user')
			}

			// 执行实际操作
			await this.doWork()

			// 报告步骤内进度
			onProgress(((i + 1) / iterations) * 100)
		}
	}

	async doWork() {
		// 模拟工作
		return new Promise(resolve => setTimeout(resolve, 10))
	}
}

new ThemeWorker()
log.info('[ThemeWorker] Started with cancellation support')
```

#### 2.5.4 不同任务类型的可取消性

| 任务类型       | 可取消性      | 实现方式                          | 说明                           |
| -------------- | ------------- | --------------------------------- | ------------------------------ |
| **文件复制**   | ✅ 可取消     | 在每个文件之间检查 `shouldCancel` | 批量复制时，完成当前文件后检查 |
| **压缩打包**   | ⚠️ 部分可取消 | 使用流式压缩，监听 `shouldCancel` | 一次性压缩难以中断             |
| **图片处理**   | ✅ 可取消     | 在每张图片之间检查                | 批量处理时最容易取消           |
| **XML 生成**   | ✅ 可取消     | 在生成各部分之间检查              | 可以分段生成                   |
| **数据库操作** | ❌ 难以取消   | 事务需要完成或回滚                | 建议设计为小事务               |
| **网络请求**   | ✅ 可取消     | 使用 AbortController              | 标准的取消机制                 |

#### 2.5.5 用户界面取消操作

**渲染进程中的取消按钮：**

```vue
<!-- src/renderer/business/theme/pages/ThemeEditor.vue -->
<template>
	<div>
		<el-button v-if="!isExporting" @click="handleExport" type="primary">导出主题</el-button>

		<div v-else class="export-progress">
			<el-progress :percentage="exportProgress" :status="exportStatus"></el-progress>

			<el-button @click="handleCancelExport" type="danger" size="small">取消导出</el-button>
		</div>
	</div>
</template>

<script>
export default {
	data() {
		return {
			currentTaskId: null
		}
	},

	methods: {
		async handleExport() {
			try {
				const result = await this.$store.dispatch('theme/exportTheme', {
					themeID: this.currentTheme.id
				})

				// 保存任务 ID
				this.currentTaskId = result.taskId

				if (result.cancelled) {
					this.$message.warning('导出已取消')
				} else {
					this.$message.success('导出成功！')
				}
			} catch (error) {
				this.$message.error('导出失败: ' + error.message)
			}
		},

		async handleCancelExport() {
			if (!this.currentTaskId) return

			try {
				await this.$confirm('确定要取消导出吗？', '提示', {
					confirmButtonText: '确定',
					cancelButtonText: '继续导出',
					type: 'warning'
				})

				// 调用取消 API
				const result = await this.$store.dispatch('theme/cancelExport', {
					taskId: this.currentTaskId
				})

				if (result.success) {
					this.$message.success(result.message || '已取消导出')
				} else {
					this.$message.warning(result.message || '无法取消该任务')
				}
			} catch (error) {
				// 用户点击了"继续导出"
			}
		}
	}
}
</script>
```

### 2.6 完整数据流程详解

本节详细描述从用户操作到任务执行完成的完整数据流程，帮助开发者理解系统各层之间的交互。

#### 2.6.1 流程架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        渲染进程 (Renderer)                       │
│                                                                  │
│  [用户点击导出按钮]                                               │
│         ↓                                                        │
│  Vue 组件调用 action                                             │
│         ↓                                                        │
│  Vuex Store Action                                               │
│         ↓                                                        │
│  调用 API 层 (ThemeAPI.export)                                   │
│         ↓                                                        │
│  IPCManager.request('theme:export', data)                        │
│         ↓                                                        │
│  通过 IPC 发送到主进程                                            │
└──────────────────────────┬───────────────────────────────────────┘
                           │ IPC Channel: 'ipc-request'
                           │ 耗时: 1-5ms
                           ↓
┌─────────────────────────────────────────────────────────────────┐
│                        主进程 (Main Process)                     │
│                                                                  │
│  IPCRouter 接收请求                                              │
│         ↓                                                        │
│  解析路由: 'theme:export' → ThemeModule.export()                 │
│         ↓                                                        │
│  ThemeModule.export(data)                                        │
│         ↓                                                        │
│  TaskDispatcher.dispatch('theme', 'export', data, options)       │
│         ↓                                                        │
│  创建 Task 对象                                                  │
│         ↓                                                        │
│  TaskQueue.add(task) - 加入队列                                  │
│         ↓                                                        │
│  按优先级排序                                                     │
│         ↓                                                        │
│  TaskQueue.processNext() - 开始执行                              │
│         ↓                                                        │
│  找到空闲的 ThemeWorker                                          │
│         ↓                                                        │
│  worker.process.send({ taskId, type: 'export', data })          │
└──────────────────────────┬───────────────────────────────────────┘
                           │ IPC (child_process)
                           │ 耗时: 1-5ms
                           ↓
┌─────────────────────────────────────────────────────────────────┐
│                     子进程 (Worker Process)                      │
│                                                                  │
│  ThemeWorker 接收消息                                            │
│         ↓                                                        │
│  handleTask('export', data, onProgress)                          │
│         ↓                                                        │
│  handleExport(data, onProgress)                                  │
│         ↓                                                        │
│  执行实际业务逻辑:                                                │
│    1. 复制文件 (20%)                                             │
│    2. 清理主题包 (30%)                                           │
│    3. 处理资源 (30%)                                             │
│    4. 压缩打包 (20%)                                             │
│         ↓ (每个步骤)                                             │
│  onProgress(50) → process.send({ taskId, progress: 50 })        │
│         ↓                                                        │
│  完成后: process.send({ taskId, result: {...} })                │
└──────────────────────────┬───────────────────────────────────────┘
                           │ IPC (child_process)
                           │ 耗时: 1-5ms
                           ↓
┌─────────────────────────────────────────────────────────────────┐
│                        主进程 (Main Process)                     │
│                                                                  │
│  TaskDispatcher.handleWorkerMessage(message)                     │
│         ↓                                                        │
│  找到对应的 task                                                 │
│         ↓                                                        │
│  task.resolve(result) - 完成 Promise                             │
│         ↓                                                        │
│  IPCRouter 返回响应                                              │
│         ↓                                                        │
│  event.reply('ipc-response', { requestId, data: result })       │
└──────────────────────────┬───────────────────────────────────────┘
                           │ IPC Channel: 'ipc-response'
                           │ 耗时: 1-5ms
                           ↓
┌─────────────────────────────────────────────────────────────────┐
│                        渲染进程 (Renderer)                       │
│                                                                  │
│  IPCManager.handleResponse(response)                             │
│         ↓                                                        │
│  找到对应的 pending request                                      │
│         ↓                                                        │
│  resolve(data) - 完成 Promise                                    │
│         ↓                                                        │
│  API 层返回结果                                                  │
│         ↓                                                        │
│  Vuex Action 接收结果                                            │
│         ↓                                                        │
│  更新 Store 状态                                                 │
│         ↓                                                        │
│  Vue 组件响应状态变化                                            │
│         ↓                                                        │
│  [显示成功提示]                                                  │
└─────────────────────────────────────────────────────────────────┘
```

#### 2.6.2 详细代码示例

**Step 1: 用户点击按钮（渲染进程）**

```vue
<!-- src/renderer/business/theme/pages/ThemeEditor.vue -->
<template>
	<div class="theme-editor">
		<el-button @click="handleExport" :disabled="isExporting" type="primary">
			{{ isExporting ? '导出中...' : '导出主题' }}
		</el-button>

		<div v-if="exportProgress > 0" class="progress-container">
			<el-progress :percentage="exportProgress" :status="exportStatus"></el-progress>
			<p>{{ exportMessage }}</p>
		</div>
	</div>
</template>

<script>
import { mapState, mapActions } from 'vuex'

export default {
	name: 'ThemeEditor',

	computed: {
		...mapState('theme', ['isExporting', 'exportProgress', 'exportStatus', 'exportMessage']),

		currentTheme() {
			return this.$store.state.theme.current
		}
	},

	methods: {
		...mapActions('theme', ['exportTheme']),

		async handleExport() {
			console.log('[UI] 用户点击导出按钮')

			try {
				const result = await this.exportTheme({
					themeID: this.currentTheme.id,
					osVersions: ['13', '14'],
					settingsIcons: true
				})

				console.log('[UI] 导出完成', result)

				if (result.cancelled) {
					this.$message.warning('导出已取消')
				} else {
					this.$message.success('导出成功！')
				}
			} catch (error) {
				console.error('[UI] 导出失败', error)
				this.$message.error('导出失败: ' + error.message)
			}
		}
	}
}
</script>
```

**Step 2: Vuex Action（渲染进程）**

```javascript
// src/renderer/store/modules/theme.js

import { ThemeAPI } from '@/universal/communication/ProductAPI'

export default {
	namespaced: true,

	state: {
		isExporting: false,
		exportProgress: 0,
		exportStatus: '',
		exportMessage: '',
		currentTaskId: null
	},

	mutations: {
		SET_EXPORTING(state, isExporting) {
			state.isExporting = isExporting
		},

		SET_EXPORT_PROGRESS(state, progress) {
			state.exportProgress = progress
		},

		SET_EXPORT_STATUS(state, status) {
			state.exportStatus = status
		},

		SET_EXPORT_MESSAGE(state, message) {
			state.exportMessage = message
		},

		SET_TASK_ID(state, taskId) {
			state.currentTaskId = taskId
		}
	},

	actions: {
		async exportTheme({ commit, state }, options) {
			console.log('[Store] 开始导出', options)

			commit('SET_EXPORTING', true)
			commit('SET_EXPORT_PROGRESS', 0)
			commit('SET_EXPORT_STATUS', '')
			commit('SET_EXPORT_MESSAGE', '准备导出...')

			try {
				// 监听进度更新
				const progressHandler = data => {
					if (data.taskId === state.currentTaskId) {
						console.log('[Store] 进度更新', data.progress)
						commit('SET_EXPORT_PROGRESS', data.progress)

						// 根据进度更新消息
						if (data.progress < 20) {
							commit('SET_EXPORT_MESSAGE', '正在复制文件...')
						} else if (data.progress < 50) {
							commit('SET_EXPORT_MESSAGE', '正在清理主题包...')
						} else if (data.progress < 80) {
							commit('SET_EXPORT_MESSAGE', '正在处理资源...')
						} else {
							commit('SET_EXPORT_MESSAGE', '正在压缩打包...')
						}
					}
				}

				ThemeAPI.onExportProgress(progressHandler)

				// 调用 API
				console.log('[Store] 调用 ThemeAPI.export')
				const result = await ThemeAPI.export(options.themeID, options)

				console.log('[Store] API 返回结果', result)

				// 保存任务 ID
				if (result.taskId) {
					commit('SET_TASK_ID', result.taskId)
				}

				commit('SET_EXPORT_PROGRESS', 100)
				commit('SET_EXPORT_STATUS', 'success')
				commit('SET_EXPORT_MESSAGE', '导出完成！')

				// 清理监听
				ThemeAPI.offExportProgress(progressHandler)

				return result
			} catch (error) {
				console.error('[Store] 导出失败', error)

				commit('SET_EXPORT_STATUS', 'exception')
				commit('SET_EXPORT_MESSAGE', '导出失败: ' + error.message)

				throw error
			} finally {
				// 延迟重置状态
				setTimeout(() => {
					commit('SET_EXPORTING', false)
				}, 1000)
			}
		}
	}
}
```

**Step 3: API 层（通用层）**

```javascript
// src/universal/communication/ProductAPI.js

import { ipcManager } from './IPCManager'

class ProductAPI {
	constructor(productType) {
		this.productType = productType
	}

	async export(id, options) {
		console.log(`[API] 调用 ${this.productType}:export`, { id, options })

		const startTime = Date.now()

		try {
			// 通过 IPCManager 发送请求
			const result = await ipcManager.request(
				`${this.productType}:export`,
				{ id, options },
				{ timeout: 300000 } // 5分钟超时
			)

			const duration = Date.now() - startTime
			console.log(`[API] ${this.productType}:export 完成`, { duration, result })

			return result
		} catch (error) {
			const duration = Date.now() - startTime
			console.error(`[API] ${this.productType}:export 失败`, { duration, error })
			throw error
		}
	}

	onExportProgress(callback) {
		ipcManager.on(`${this.productType}:exportProgress`, callback)
	}

	offExportProgress(callback) {
		ipcManager.off(`${this.productType}:exportProgress`, callback)
	}
}

export const ThemeAPI = new ProductAPI('theme')
export const LockscreenAPI = new ProductAPI('lockscreen')
export const WidgetAPI = new ProductAPI('widget')
```

**Step 4: IPC Manager（通用层）**

```javascript
// src/universal/communication/IPCManager.js

class IPCManager {
	constructor() {
		this.pendingRequests = new Map()
		this.eventHandlers = new Map()
		this.requestId = 0
		this.defaultTimeout = 30000

		this.setupListeners()
	}

	setupListeners() {
		// 监听响应
		window.electron.ipcRenderer.on('ipc-response', (event, response) => {
			this.handleResponse(response)
		})

		// 监听事件
		window.electron.ipcRenderer.on('ipc-event', (event, { eventName, data }) => {
			this.emit(eventName, data)
		})
	}

	async request(channel, data = {}, options = {}) {
		const requestId = ++this.requestId
		const timeout = options.timeout || this.defaultTimeout

		console.log(`[IPC] 发送请求 #${requestId}: ${channel}`, data)

		return new Promise((resolve, reject) => {
			const timer = setTimeout(() => {
				this.pendingRequests.delete(requestId)
				console.error(`[IPC] 请求超时 #${requestId}: ${channel}`)
				reject(new Error(`Request timeout: ${channel}`))
			}, timeout)

			this.pendingRequests.set(requestId, {
				resolve,
				reject,
				timer,
				channel,
				startTime: Date.now()
			})

			// 发送到主进程
			window.electron.ipcRenderer.send('ipc-request', {
				requestId,
				channel,
				data
			})
		})
	}

	handleResponse(response) {
		const { requestId, data, error } = response

		const pending = this.pendingRequests.get(requestId)

		if (pending) {
			const duration = Date.now() - pending.startTime

			clearTimeout(pending.timer)
			this.pendingRequests.delete(requestId)

			if (error) {
				console.error(`[IPC] 收到错误响应 #${requestId}:`, { duration, error })
				pending.reject(new Error(error))
			} else {
				console.log(`[IPC] 收到成功响应 #${requestId}:`, { duration, data })
				pending.resolve(data)
			}
		} else {
			console.warn(`[IPC] 收到未知响应 #${requestId}`)
		}
	}

	on(event, handler) {
		if (!this.eventHandlers.has(event)) {
			this.eventHandlers.set(event, [])
		}
		this.eventHandlers.get(event).push(handler)
	}

	off(event, handler) {
		const handlers = this.eventHandlers.get(event)
		if (handlers) {
			const index = handlers.indexOf(handler)
			if (index > -1) {
				handlers.splice(index, 1)
			}
		}
	}

	emit(event, data) {
		const handlers = this.eventHandlers.get(event) || []
		handlers.forEach(handler => {
			try {
				handler(data)
			} catch (error) {
				console.error(`[IPC] Event handler error:`, error)
			}
		})
	}
}

export const ipcManager = new IPCManager()
```

**Step 5-8: 主进程和子进程代码**

（由于篇幅限制，这部分代码已在前面的章节中详细说明）

#### 2.6.3 关键时序点总结

| 阶段             | 位置           | 平均耗时         | 说明                 |
| ---------------- | -------------- | ---------------- | -------------------- |
| 1. 用户点击      | 渲染进程       | <1ms             | 触发事件             |
| 2. Vuex Action   | 渲染进程       | <1ms             | 状态管理             |
| 3. API 调用      | 渲染进程       | <1ms             | 封装请求             |
| 4. IPC 发送      | 渲染 → 主      | 1-5ms            | 进程间通信（序列化） |
| 5. 路由解析      | 主进程         | <1ms             | 找到处理器           |
| 6. 模块处理      | 主进程         | <1ms             | 业务逻辑             |
| 7. 任务分发      | 主进程         | <1ms             | 加入队列             |
| 8. 队列调度      | 主进程         | <1ms             | 找到 Worker          |
| 9. 发送到 Worker | 主 → 子进程    | 1-5ms            | 进程间通信           |
| 10. 业务执行     | 子进程         | **几秒到几分钟** | 实际工作             |
| 11. 进度更新     | 子 → 主 → 渲染 | 2-10ms           | 实时反馈             |
| 12. 结果返回     | 子 → 主进程    | 1-5ms            | 返回结果             |
| 13. IPC 响应     | 主 → 渲染      | 1-5ms            | 返回渲染进程         |
| 14. Promise 完成 | 渲染进程       | <1ms             | 解析 Promise         |
| 15. UI 更新      | 渲染进程       | <16ms            | Vue 响应式更新       |

**总通信开销**：约 10-30ms（不包括实际业务逻辑执行时间）

#### 2.6.4 数据流程优化建议

1. **批量操作优化**

```javascript
// 不推荐：多次调用
for (const theme of themes) {
	await ThemeAPI.export(theme.id, options)
}

// 推荐：批量调用
await ThemeAPI.batchExport(
	themes.map(t => t.id),
	options
)
```

2. **进度更新节流**

```javascript
// Worker 中节流进度更新
let lastProgressTime = 0
const PROGRESS_THROTTLE = 100 // 100ms

function sendProgress(taskId, progress) {
	const now = Date.now()
	if (now - lastProgressTime > PROGRESS_THROTTLE) {
		process.send({ taskId, progress })
		lastProgressTime = now
	}
}
```

3. **大数据传输优化**

```javascript
// 不推荐：传输大数据
worker.send({
	type: 'processImage',
	imageData: largeBuffer // 可能导致性能问题
})

// 推荐：传递文件路径
worker.send({
	type: 'processImage',
	imagePath: '/path/to/image.jpg'
})
```

---

## 三、技术实施细节

### 3.1 进程间通信优化

#### 大数据传输优化

对于大文件或大数据，避免通过 IPC 直接传输，改用文件路径传递：

```javascript
// 不推荐：直接传输大数据
worker.send({
	type: 'processImage',
	data: largeImageBuffer // 可能导致性能问题
})

// 推荐：传递文件路径
worker.send({
	type: 'processImage',
	filePath: '/path/to/image.jpg'
})
```

#### 使用 SharedArrayBuffer（可选）

对于需要共享的大数据，可以使用 `SharedArrayBuffer`：

```javascript
// 主进程
const sharedBuffer = new SharedArrayBuffer(1024 * 1024) // 1MB
worker.postMessage({ sharedBuffer })

// Worker
self.onmessage = event => {
	const { sharedBuffer } = event.data
	const view = new Uint8Array(sharedBuffer)
	// 直接操作共享内存
}
```

### 3.2 错误处理与恢复

#### Worker 崩溃恢复

```javascript
// src/electron/core/WorkerRecovery.js

class WorkerRecovery {
	constructor(dispatcher) {
		this.dispatcher = dispatcher
		this.crashLog = []
	}

	handleWorkerCrash(workerType, error) {
		this.crashLog.push({
			workerType,
			error,
			timestamp: Date.now()
		})

		// 检查崩溃频率
		const recentCrashes = this.crashLog.filter(
			log => log.workerType === workerType && Date.now() - log.timestamp < 60000 // 1分钟内
		)

		if (recentCrashes.length > 3) {
			// 频繁崩溃，不再重启
			log.error(`Worker ${workerType} crashed too frequently, not restarting`)
			this.notifyFatalError(workerType)
			return false
		}

		// 重启 worker
		this.dispatcher.restartWorker(workerType)
		return true
	}

	notifyFatalError(workerType) {
		// 通知用户
		const { dialog } = require('electron')
		dialog.showErrorBox('严重错误', `${workerType} 模块出现严重错误，请重启应用`)
	}
}

module.exports = { WorkerRecovery }
```

#### 任务失败重试

```javascript
// 在 TaskQueue 中已实现重试机制
// 使用示例：

await dispatcher.dispatch(
	'theme',
	'export',
	{ themeID: '123' },
	{
		priority: TaskPriority.HIGH,
		retry: 3, // 失败后重试3次
		timeout: 300000
	}
)
```

### 3.3 性能监控

#### 创建性能监控模块

```javascript
// src/electron/core/PerformanceMonitor.js

class PerformanceMonitor {
	constructor() {
		this.metrics = {
			tasks: [],
			workers: new Map()
		}
	}

	recordTaskStart(task) {
		this.metrics.tasks.push({
			id: task.id,
			type: task.taskType,
			workerType: task.workerType,
			priority: task.priority,
			startTime: Date.now()
		})
	}

	recordTaskEnd(task, success) {
		const metric = this.metrics.tasks.find(m => m.id === task.id)
		if (metric) {
			metric.endTime = Date.now()
			metric.duration = metric.endTime - metric.startTime
			metric.success = success
		}
	}

	getAverageTaskTime(taskType) {
		const tasks = this.metrics.tasks.filter(t => t.type === taskType && t.duration)

		if (tasks.length === 0) return 0

		const total = tasks.reduce((sum, t) => sum + t.duration, 0)
		return total / tasks.length
	}

	getWorkerStats(workerType) {
		return this.metrics.workers.get(workerType) || {}
	}

	generateReport() {
		return {
			totalTasks: this.metrics.tasks.length,
			successRate: this.calculateSuccessRate(),
			averageTimes: this.calculateAverageTimes(),
			workerStats: this.getWorkerStats()
		}
	}

	calculateSuccessRate() {
		const completed = this.metrics.tasks.filter(t => t.success)
		return (completed.length / this.metrics.tasks.length) * 100
	}

	calculateAverageTimes() {
		const types = [...new Set(this.metrics.tasks.map(t => t.type))]
		const times = {}

		types.forEach(type => {
			times[type] = this.getAverageTaskTime(type)
		})

		return times
	}
}

module.exports = { PerformanceMonitor }
```

### 3.4 内存管理

#### Worker 内存限制

```javascript
// 启动 Worker 时设置内存限制
const worker = fork(workerPath, [], {
	execArgv: [
		'--max-old-space-size=2048', // 最大堆内存 2GB
		'--max-semi-space-size=128' // 最大半空间 128MB
	]
})
```

#### 主进程内存监控

```javascript
// src/electron/core/MemoryMonitor.js

class MemoryMonitor {
	constructor() {
		this.threshold = 0.8 // 80% 内存使用率
		this.checkInterval = 30000 // 30秒检查一次
		this.start()
	}

	start() {
		setInterval(() => {
			this.checkMemory()
		}, this.checkInterval)
	}

	checkMemory() {
		const usage = process.memoryUsage()
		const totalMemory = require('os').totalmem()
		const usagePercent = usage.heapUsed / totalMemory

		if (usagePercent > this.threshold) {
			log.warn('High memory usage:', {
				heapUsed: Math.round(usage.heapUsed / 1024 / 1024) + 'MB',
				heapTotal: Math.round(usage.heapTotal / 1024 / 1024) + 'MB',
				external: Math.round(usage.external / 1024 / 1024) + 'MB'
			})

			// 触发垃圾回收（如果可用）
			if (global.gc) {
				global.gc()
			}

			// 通知用户
			this.notifyHighMemory()
		}
	}

	notifyHighMemory() {
		const mainWindow = require('./AppLifecycleManager').getMainWindow()
		if (mainWindow) {
			mainWindow.webContents.send('ipc-event', {
				eventName: 'system:highMemory',
				data: {
					message: '内存使用率较高，建议关闭一些编辑器窗口'
				}
			})
		}
	}
}

module.exports = { MemoryMonitor }
```

---

## 四、风险评估与应对

### 4.1 技术风险

| 风险               | 影响 | 概率 | 应对措施                                                                          |
| ------------------ | ---- | ---- | --------------------------------------------------------------------------------- |
| 子进程通信性能问题 | 中   | 低   | 1. 使用文件路径传递大数据<br>2. 批量操作减少通信次数<br>3. 使用 SharedArrayBuffer |
| Worker 频繁崩溃    | 高   | 中   | 1. 实现崩溃恢复机制<br>2. 限制 Worker 内存<br>3. 任务分片避免大任务               |
| 任务队列死锁       | 高   | 低   | 1. 实现超时机制<br>2. 任务优先级管理<br>3. 可取消任务                             |
| 内存泄漏           | 中   | 中   | 1. 定期内存检查<br>2. Worker 定期重启<br>3. 资源及时释放                          |
| 兼容性问题         | 低   | 低   | 1. 充分测试<br>2. 渐进式迁移<br>3. 保留降级方案                                   |

### 4.2 业务风险

| 风险         | 影响 | 概率 | 应对措施                                                |
| ------------ | ---- | ---- | ------------------------------------------------------- |
| 现有功能回归 | 高   | 中   | 1. 完整的回归测试<br>2. 灰度发布<br>3. 快速回滚机制     |
| 用户体验下降 | 中   | 低   | 1. 充分的用户测试<br>2. 进度反馈优化<br>3. 错误提示优化 |
| 开发周期延长 | 中   | 中   | 1. 分阶段实施<br>2. 并行开发<br>3. 及时调整计划         |
| 团队学习成本 | 低   | 高   | 1. 详细文档<br>2. 代码示例<br>3. 团队培训               |

### 4.3 应对策略

#### 渐进式迁移

```
阶段1: 基础设施 (不影响现有功能)
  ↓
阶段2: 迁移非关键功能 (如图片处理)
  ↓
阶段3: 迁移关键功能 (如主题导出)
  ↓
阶段4: 全面优化
```

#### 降级方案

```javascript
// 保留原有实现作为降级方案
const USE_WORKER = process.env.USE_WORKER !== 'false'

async function exportTheme(data) {
	if (USE_WORKER) {
		try {
			// 使用新的 Worker 实现
			return await dispatcher.dispatch('theme', 'export', data)
		} catch (error) {
			log.error('Worker failed, fallback to legacy:', error)
			// 降级到原有实现
			return await legacyExportTheme(data)
		}
	} else {
		// 直接使用原有实现
		return await legacyExportTheme(data)
	}
}
```

---

## 五、实施时间表

### 总体时间：7-8 周

```
Week 1-2: 基础架构搭建
├── 通信层实现
├── 主进程重构
└── Worker 基础设施

Week 3-5: 业务模块迁移
├── 主题模块迁移
├── 锁屏模块迁移
└── 小组件模块迁移

Week 6-7: 优化与测试
├── 性能优化
├── 稳定性测试
└── 用户体验优化

Week 8: 上线准备
├── 文档完善
├── 团队培训
└── 灰度发布
```

### 详细时间表

| 周次   | 任务           | 产出                      | 负责人   |
| ------ | -------------- | ------------------------- | -------- |
| Week 1 | 通信层实现     | IPCManager, ProductAPI    | 架构师   |
| Week 2 | 主进程重构     | IPCRouter, TaskDispatcher | 架构师   |
| Week 3 | 主题模块迁移   | ThemeWorker, ThemeModule  | 主题组   |
| Week 4 | 锁屏模块迁移   | LockscreenWorker          | 锁屏组   |
| Week 5 | 小组件模块迁移 | WidgetWorker              | 小组件组 |
| Week 6 | 性能优化       | 优化报告                  | 全员     |
| Week 7 | 稳定性测试     | 测试报告                  | 测试组   |
| Week 8 | 上线准备       | 文档、培训                | 全员     |

---

## 六、验收标准

### 6.1 功能验收

- [ ] 所有现有功能正常工作
- [ ] 主题导出在子进程执行
- [ ] 锁屏导出在子进程执行
- [ ] 小组件导出在子进程执行
- [ ] 任务队列正常工作
- [ ] 优先级管理正常
- [ ] 任务取消功能正常
- [ ] 进度反馈正常
- [ ] 错误处理正常

### 6.2 性能验收

- [ ] 主题导出时主进程 CPU 占用 < 20%
- [ ] 主题导出时界面无卡顿（60fps）
- [ ] 大型主题包导出不崩溃
- [ ] 批量操作不阻塞界面
- [ ] 内存占用合理（< 2GB）

### 6.3 稳定性验收

- [ ] 连续导出 100 个主题包无崩溃
- [ ] Worker 崩溃后能自动恢复
- [ ] 任务失败后能正确重试
- [ ] 长时间运行无内存泄漏
- [ ] 异常情况下数据不丢失

### 6.4 扩展性验收

- [ ] 能快速添加新产品线（如天气）
- [ ] 新增 Worker 类型简单
- [ ] 新增任务类型简单
- [ ] API 接口统一清晰
- [ ] 文档完整易懂

---

## 七、总结

### 核心价值

1. **架构清晰**：四层架构（渲染层、通信层、主进程层、子进程层）职责明确
2. **扩展性强**：新增产品线只需实现统一接口
3. **稳定性高**：子进程隔离，崩溃不影响主进程
4. **性能优异**：重量级任务不阻塞界面
5. **可维护性好**：代码结构清晰，易于理解和修改

### 关键技术点

1. **统一 IPC 通信**：IPCManager + ProductAPI
2. **任务队列**：优先级管理 + 任务取消
3. **Worker Pool**：进程池 + 负载均衡
4. **错误恢复**：崩溃恢复 + 任务重试
5. **性能监控**：实时监控 + 性能报告

### 后续优化方向

1. **分布式任务**：支持多机器协同处理
2. **智能调度**：基于机器学习的任务调度
3. **云端处理**：部分重量级任务云端处理
4. **实时协作**：多人协同编辑
5. **插件系统**：支持第三方扩展

---

**文档版本**：v1.0
**生成时间**：2025-12-16
**作者**：AI Assistant
**状态**：待审核
