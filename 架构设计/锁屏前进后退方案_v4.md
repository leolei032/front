# 锁屏编辑器 - 撤销/重做架构设计文档

> **版本**: v4.0 | **更新日期**: 2025-12-10 | **状态**: 技术方案 | **技术栈**: Vue 2 + lockscreen-v2

---

## 📑 文档导读

### 阅读指南

本文档是锁屏编辑器撤销/重做功能的**完整技术方案**，包含架构设计、实现细节和容错策略。

**不同角色的阅读路径**：

| 角色                   | 推荐章节                           | 阅读方式                 | 预计时间 |
| ---------------------- | ---------------------------------- | ------------------------ | -------- |
| **架构师/技术 Leader** | 1-6 章（背景、方案对比、架构设计） | 快速浏览 + 重点章节精读  | 1 小时   |
| **核心开发**           | 全部章节，重点 7-11 章             | 完整阅读，代码示例需理解 | 4-6 小时 |
| **测试工程师**         | 3、12、13 章                       | 重点阅读边界处理相关内容 | 1.5 小时 |
| **新人/维护者**        | 按顺序完整阅读                     | 循序渐进，代码示例可跳过 | 1-2 天   |

### 术语表

| 术语                      | 定义                                                              | 使用场景         |
| ------------------------- | ----------------------------------------------------------------- | ---------------- |
| **runtimeState**          | 单一数据源，所有编辑操作的真实状态                                | 核心数据层       |
| **Patch**                 | Immer.js 生成的 JSON 差异记录（patches/inversePatches）          | 增量存储（核心） |
| **RuntimeStateManager**   | 唯一数据修改入口，通过`produceWithPatches`自动生成 Patch          | 数据层           |
| **HistoryManager**        | 历史栈管理、RAF 批处理、防抖合并的核心控制器                      | 历史管理         |
| **Snapshot**              | 周期性保存的完整状态，用于加速长距离撤销                          | 性能优化         |
| **FilePool**              | 按文件 hash 存储并管理引用计数的文件池                            | 文件管理         |
| **RAF**                   | requestAnimationFrame，浏览器帧同步机制                           | 批处理优化       |
| **Event Sourcing**        | 事件溯源，只存储 Patch 序列而非最终状态                           | 架构模式         |
| **Immer**                 | 基于 Proxy 的不可变数据库，自动生成 Patch                         | 核心技术         |
| **produceWithPatches**    | Immer 核心 API，返回`[nextState, patches, inversePatches]`        | Patch 生成       |
| **sideEffects**           | 文件 IO、引用计数等不能由 Immer 处理的操作                        | 文件操作         |
| **layerTreeManager**      | 左侧图层树的 Vue 2 store                                          | UI 层            |
| **treeStore**             | 中间画布预览的状态管理                                            | UI 层            |
| **currentFormStore**      | 右侧属性表单的状态管理                                            | UI 层            |

### 关键设计决策速览

| 决策点            | 选择方案                                     | 核心优势                         | 章节      |
| ----------------- | -------------------------------------------- | -------------------------------- | --------- |
| **核心架构** ⭐   | RuntimeState + Immer 自动生成 Patch          | 避免重复、保留语义、零手写 Patch | 第 5、7 章 |
| **存储方式**      | Patch（增量）                                | 内存节省 99%（50MB → 50KB）      | 第 5、7 章 |
| **数据修改入口**  | RuntimeStateManager.modify()                 | 统一入口、自动生成 Patch         | 第 7 章   |
| **响应式系统**    | 双层架构（runtimeState + UI Stores）         | 兼容现有 Vue 2 代码              | 第 7 章   |
| **撤销加速**      | 周期快照（每 20 步）                         | 平衡内存与性能                   | 第 7 章   |
| **合并策略** ⭐   | RAF 批处理 + Map 去重 + 防抖                 | 简单高效（97%合并率）            | 第 5、9 章 |
| **文件存储** ⭐   | 内容寻址（hash） + 引用计数 + sideEffects    | 去重 + 可撤销                    | 第 10 章  |
| **性能优化**      | RAF + 防抖 + 批处理                          | 无卡顿、无闪烁、历史简洁         | 第 9 章   |
| **降级方案**      | Immer 失效时切换快照模式                     | 保证稳定性                       | 第 12 章  |

### 文档结构

```
第一部分：背景与决策（1-6章）
├─ 1. 项目背景 - 业务场景和技术栈
├─ 2. 核心诉求 - 功能需求 + 当前问题
├─ 3. 编辑操作类型 - 高中低频操作分析
├─ 4. 设计目标 - 性能指标 + 架构原则
├─ 5. 整体设计思路 - 核心理念 + 方案对比
└─ 6. JSON数据结构设计原则 - Schema约束

第二部分：架构设计与实现（7-11章）
├─ 7. 架构设计与代码实现 - 完整实现细节
├─ 8. UI同步策略 - 双层架构的Patch分发机制
├─ 9. 渲染优化策略 - RAF + 防抖批处理
├─ 10. 操作合并优化 - Map去重算法
└─ 11. 典型业务流程 - 增删改移 + 文件操作

第三部分：容错与边界（12-14章）
├─ 12. 降级与容错策略 - 6个降级方案
├─ 13. 错误处理与边界情况 - 完整异常处理
└─ 14. 技术约束 - 环境和范围限制

第四部分：评估与扩展（15-17章）
├─ 15. 集成与改造任务拆解 - 实施路线图
├─ 16. 验收标准 - 可量化指标
└─ 17. 后续扩展方向 - 可选增强

附录
└─ A. 文档维护 - 版本记录
```

### 重要提示

1. **架构权衡说明**：本方案采用双层架构（runtimeState + UI Stores）以兼容现有代码，理想方案见第7章架构对比
2. **代码示例均为核心实现**：所有代码都是帮助理解方案的关键
3. **章节间有依赖关系**：建议按顺序阅读，后续章节会引用前面的概念
4. **性能数据基于实测**：所有性能指标基于锁屏编辑器的实际场景

---

## 📋 1. 项目背景

### 项目概述

锁屏编辑器（lockscreen-v2）是一个**可视化主题编辑工具**，用于编辑手机锁屏界面的布局和样式。核心特点：

- **技术栈**：Vue 2 + Vuex + Konva（画布渲染）
- **数据规模**：单个锁屏主题 JSON 约 3-8MB，包含 50-200 个图层节点
- **编辑模式**：三栏式布局（左侧图层树、中间画布预览、右侧属性表单）
- **输出格式**：生成符合 Android 锁屏规范的 JSON 配置 + 资源文件

### 技术栈

| 层次         | 技术选型                      | 说明                            |
| ------------ | ----------------------------- | ------------------------------- |
| **前端框架** | Vue 2.x + Vuex                | 响应式 UI 框架                  |
| **画布渲染** | Konva.js                      | 中间预览区域的 Canvas 渲染引擎  |
| **主进程**   | Electron (lockscreenNew)      | 文件 IO、打包等后端操作         |
| **状态管理** | 4 个独立 Store                | layerTreeManager / treeStore 等 |
| **数据结构** | JSON Schema（tree/preview/json/vars） | 分层数据模型                    |

### 现有Store架构

```
┌─────────────────────────────────────────────────────────┐
│                     lockscreen-v2                        │
├─────────────────────────────────────────────────────────┤
│  layerTreeManager (左侧图层树)                           │
│  - layerData: 扁平化的图层数组                           │
│  - 提供：add/delete 方法（缺少 update/move）             │
├─────────────────────────────────────────────────────────┤
│  treeStore (中间画布预览)                                │
│  - nodeMap: Map<id, NodeData>                           │
│  - 提供：add/update/remove/move + 事件总线               │
├─────────────────────────────────────────────────────────┤
│  currentFormStore (右侧属性表单)                         │
│  - formData: 当前选中节点的表单数据                      │
│  - 提供：updateForms 方法                                │
├─────────────────────────────────────────────────────────┤
│  selectionStore (选中状态)                               │
│  - selectedNodeIds: string[]                            │
└─────────────────────────────────────────────────────────┘
```

**现状问题：**
- ✗ 没有统一的数据修改入口
- ✗ 各 Store 独立维护状态，容易不一致
- ✗ 缺少撤销/重做功能
- ✗ 数据修改后需要手动同步多个 Store

---

## 🎯 2. 核心诉求

### 功能需求

**必须实现（MVP）：**
1. ✅ 基础撤销/重做（Ctrl/Cmd+Z、Ctrl/Cmd+Y）
2. ✅ 支持所有编辑操作可撤销：增删改移节点、修改属性、资源替换
3. ✅ 历史深度 ≥100 步
4. ✅ 文件操作可撤销（图片上传、替换、删除）
5. ✅ 性能可接受（单步 undo/redo < 50ms）

**期望实现（优化）：**
1. 🔄 高频操作合并（拖拽、滑块等）
2. 🔄 快照加速长距离撤销
3. 🔄 历史面板（显示操作记录）
4. 🔄 Autosave（崩溃恢复）

**不在范围：**
- ❌ 协同编辑（多人同时编辑）
- ❌ 云端历史记录同步
- ❌ 操作回放（时间旅行调试）

### 当前问题

| 问题类别     | 具体表现                                      | 影响               |
| ------------ | --------------------------------------------- | ------------------ |
| **功能缺失** | 完全没有 undo/redo                             | 误操作无法恢复     |
| **架构问题** | 4 个独立 Store，数据修改分散                   | 难以实现统一历史   |
| **文件管理** | 文件按名称存储，重复复制，无法撤销             | 磁盘浪费 + 操作泄漏 |
| **性能风险** | 完整状态克隆（3-8MB JSON）成本高               | 可能卡顿           |

---

## 🔧 3. 编辑操作类型

### 操作频率分析

| 操作类型     | 频率   | 数据量         | 举例                         | 撤销需求 |
| ------------ | ------ | -------------- | ---------------------------- | -------- |
| **高频操作** | 持续   | 单字段 (< 1KB) | 拖拽节点、滑块调整属性       | 需要合并 |
| **中频操作** | 较多   | 少量字段       | 修改文本、切换可见性、颜色   | 独立记录 |
| **低频操作** | 较少   | 多字段 + 文件  | 增删节点、资源替换、批量操作 | 独立记录 |

### 典型操作场景

**1. 拖拽移动（高频）**
```
操作：鼠标按下 → mousemove × 30 → 松开
期望：30 次位置变化合并为 1 条历史记录
技术：RAF + Map 去重（保留最后一次）
```

**2. 修改属性（中频）**
```
操作：修改颜色 #FF0000 → #00FF00
期望：独立记录，可单独撤销
技术：直接入栈，无需合并
```

**3. 添加组件（低频）**
```
操作：从组件库拖入新节点 + 上传图片资源
期望：节点创建 + 文件添加作为一个原子操作
技术：sideEffects 对称处理文件引用计数
```

**4. 删除节点（低频）**
```
操作：删除节点（可能包含子节点和关联文件）
期望：可完整恢复（包括文件）
技术：延迟 GC（1小时后才删除文件）
```

---

## 💡 4. 设计目标

### 性能指标

| 指标                 | 目标值             | 测量方式                       |
| -------------------- | ------------------ | ------------------------------ |
| **单步撤销/重做**    | < 50ms (P95)       | 浏览器 Performance API         |
| **内存占用**         | < 100MB            | 100 步历史 + 5 个快照          |
| **合并率**           | > 90%              | 拖拽等高频操作的历史记录减少量 |
| **文件去重率**       | > 60%              | 实际文件数 / 理论文件数        |
| **崩溃恢复时间**     | < 2s               | Autosave 加载时间              |

### 架构原则

1. **单一数据源（Single Source of Truth）**：runtimeState 是唯一真相
2. **事件溯源（Event Sourcing）**：存储 Patch 序列而非完整状态
3. **不可变数据（Immutable Data）**：Immer.js 确保安全修改
4. **响应式优先**：利用 Vue 2 响应式系统自动更新 UI
5. **渐进式增强**：先核心功能，再优化和降级方案

---

## 🧠 5. 整体设计思路

### 核心理念

**1. 轻量化历史记录（增量存储）**

传统方案需要保存完整状态快照，单个锁屏 JSON 约 5MB，100 步历史需要 500MB：

```javascript
// ❌ 传统方案：完整克隆（不可接受）
history.push(JSON.parse(JSON.stringify(state))) // 每步 5MB
```

**Patch 方案只存储差异**，单步平均只有 0.5KB：

```javascript
// ✅ Patch 方案：只存储差异
{
  patches: [{ op: "replace", path: ["preview", "node_123", "meta", "x"], value: 150 }],
  inversePatches: [{ op: "replace", path: ["preview", "node_123", "meta", "x"], value: 100 }]
}
// 100步历史 = 50KB（节省 99.99%）
```

**2. Immer 自动生成 Patch**

手写 Patch 容易出错且代码量大，Immer.js 可以自动生成：

```javascript
// ❌ 手写 Patch（50+ 行代码）
function moveNode(nodeId, newX, newY) {
  const patches = [
    { op: 'replace', path: ['preview', nodeId, 'meta', 'x'], value: newX },
    { op: 'replace', path: ['preview', nodeId, 'meta', 'y'], value: newY }
  ]
  // ... 还需要手写 inversePatches
  return { patches, inversePatches }
}

// ✅ Immer 自动生成（5 行代码）
const { patches, inversePatches } = runtimeManager.modify(draft => {
  draft.preview[nodeId].meta.x = newX
  draft.preview[nodeId].meta.y = newY
})
```

**3. RAF + 防抖批处理（实时渲染 + 合并历史）**

```
用户操作：mousemove × 30 次（16ms内）
                ↓
        RAF立即执行30次修改
                ↓
         UI实时更新30帧（流畅）
                ↓
      防抖30ms后触发一次历史记录
                ↓
    30次操作 → 1条历史（Map去重）
```

### 方案对比

| 维度           | 完整快照方案                 | Command模式（重）         | Immer Patch方案（本方案） ⭐ |
| -------------- | ---------------------------- | ------------------------- | ---------------------------- |
| **内存占用**   | 极高（500MB / 100步）        | 中等（Command对象开销）   | 极低（50KB / 100步）         |
| **代码复杂度** | 低（简单克隆）               | 高（每个操作写Command类） | 低（Immer自动生成）          |
| **副作用处理** | 无法处理                     | Command内实现undo/redo    | sideEffects对称处理          |
| **撤销速度**   | 快（直接替换）               | 快（Command.undo()）      | 快（applyPatches）           |
| **合并优化**   | 困难（需比较完整状态）       | 中等（需Command合并逻辑） | 简单（Map去重）              |
| **调试难度**   | 难（看不到操作细节）         | 容易（Command可读）       | 容易（Patch人类可读）        |
| **可扩展性**   | 差（无法分析操作）           | 好（Command可组合）       | 好（Patch可分析/合并）       |

**为什么选择 Immer Patch 方案？**

1. ✅ 内存占用减少 99.99%（5MB → 0.5KB 每步）
2. ✅ 代码量减少 90%（无需手写 Patch/Command）
3. ✅ 支持副作用（通过 sideEffects 机制）
4. ✅ 易于合并（Map 去重 + 路径匹配）
5. ✅ 人类可读（Patch 是 JSON，可调试）

### 双层架构权衡 ⚠️

**理想方案（参考主题编辑器）：**

```
RuntimeState (Vue 2 Reactive) → UI 直接渲染
         ↓
  Immer 修改 → Vue 响应式自动更新
```

**当前方案（兼容现有代码）：**

```
runtimeState (单一数据源) → Patch分发 → 4个UI Stores → UI渲染
         ↓                                    ↓
    Immer生成Patch            layerTreeManager / treeStore /
                             currentFormStore / selectionStore
```

**为什么采用双层架构？**
- 现有代码已有 4 个独立的 Store（layerTreeManager、treeStore、currentFormStore、selectionStore）
- 完全重构成本过高，需要修改大量 UI 组件
- 双层架构可以**渐进式改造**，保持现有 UI 不变

**双层架构的代价：**
- ⚠️ 需要手动实现 Patch 分发器（`applyPatchesToStores`）
- ⚠️ 需要一致性校验机制（定期检查 runtimeState 与 UI Store 一致性）
- ⚠️ 某些复杂场景可能需要从 runtimeState 重建 UI

**未来优化方向：**
- 长期可考虑重构为单层响应式架构（Vue 3 迁移时）
- 见第 17 章"后续扩展方向"

---

## 📐 6. JSON 数据结构设计原则

### 为什么需要设计原则？

Immer 的 Patch 依赖于**稳定的路径**。如果数据结构设计不当，会导致：
- ✗ Patch 路径频繁失效
- ✗ 数组操作产生大量 Patch
- ✗ 无法精确定位修改位置

### 核心原则

#### 1. 使用对象 + 稳定 ID（不用数组索引）

**❌ 错误示例：数组索引不稳定**

```javascript
{
  "layers": [
    { "name": "背景" },   // index 0
    { "name": "时间" },   // index 1
    { "name": "日期" }    // index 2
  ]
}
```

删除 index=1 的节点后，index=2 变成了 index=1：
```javascript
// 删除"时间"后，Patch失效
[{ op: "remove", path: ["layers", 1] }]
// "日期"的路径从 ["layers", 2] 变成了 ["layers", 1]
```

**✅ 正确示例：对象 + 稳定 ID**

```javascript
{
  "tree": {
    "layers": {
      "node_001": { "id": "node_001", "pid": "", "name": "背景" },
      "node_002": { "id": "node_002", "pid": "", "name": "时间" },
      "node_003": { "id": "node_003", "pid": "", "name": "日期" }
    },
    "layerOrder": ["node_001", "node_002", "node_003"]
  }
}
```

删除 node_002 后，其他节点路径不受影响：
```javascript
[
  { op: "remove", path: ["tree", "layers", "node_002"] },
  { op: "replace", path: ["tree", "layerOrder"], value: ["node_001", "node_003"] }
]
```

#### 2. 文件使用 hash 存储（不用文件名）

**❌ 错误示例：文件名不稳定**

```javascript
{
  "image": {
    "src": "icon.png"  // ✗ 同名文件会覆盖
  }
}
```

**✅ 正确示例：内容寻址（hash）**

```javascript
{
  "image": {
    "src": {
      "hash": "a3d2f1e9...",  // SHA256 hash
      "androidPath": "drawable/icon.png"
    }
  }
}
```

优势：
- 相同内容的文件自动去重
- 文件修改不影响其他节点
- 可以安全撤销/重做

#### 3. 避免数据污染（不在 Schema 中存储元数据）

**❌ 错误示例：混合存储**

```javascript
{
  "node_123": {
    "x": 100,
    "y": 200,
    "__isSelected": true,    // ✗ UI状态污染数据
    "__isDirty": true,       // ✗ 元数据污染数据
    "__timestamp": 1234567890 // ✗ 不属于Schema
  }
}
```

**✅ 正确示例：分离存储**

```javascript
// runtimeState.preview（干净的Schema）
{
  "node_123": {
    "x": 100,
    "y": 200
  }
}

// runtimeState.metadata（元数据单独存储）
{
  "node_123": {
    "isSelected": true,
    "lastModified": 1234567890
  }
}
```

#### 4. 不使用软删除（直接删除，靠 Patch 恢复）

**❌ 错误示例：软删除**

```javascript
{
  "node_123": {
    "deleted": true,  // ✗ 节点仍然存在，污染数据
    "x": 100
  }
}
```

**✅ 正确示例：真删除**

```javascript
// 删除前
{ "node_123": { "x": 100 } }

// 删除后（节点完全移除）
{}

// 撤销时通过 inversePatches 恢复
[{ op: "add", path: ["node_123"], value: { "x": 100 } }]
```

### lockscreen-v2 的数据结构

```javascript
{
  "tree": {
    "layers": {
      "node_123": {
        "id": "node_123",
        "pid": "node_parent",  // 父节点ID
        "type": "Image",
        "name": "背景图"
      }
    },
    "layerOrder": ["node_123"]  // 顺序数组
  },
  "preview": {
    "node_123": {
      "id": "node_123",
      "pid": "node_parent",
      "meta": { "x": 0, "y": 0, "w": 1080, "h": 1920, "visible": true },
      "renderType": "image"
    }
  },
  "json": {
    "node_123": {
      "x": "0",
      "y": "0",
      "w": "1080",
      "h": "1920",
      "src": {
        "hash": "a3d2f1e9...",
        "androidPath": "drawable/bg.png"
      }
    }
  },
  "vars": [
    { "name": "#time_format", "value": "HH:mm" }
  ]
}
```

**符合原则：**
- ✅ 使用对象 + 稳定 ID（node_123）
- ✅ 文件使用 hash（src.hash）
- ✅ 数据干净（无 UI 状态污染）
- ✅ 真删除（删除节点会从对象中移除）

---

## 🏗️ 7. 架构设计与代码实现

### 整体架构图（双层架构）

```
┌────────────────────────────────────────────────────────────────┐
│                        编辑器 UI 层                              │
│  (Vue 2 Components + Event Handlers)                           │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 │ 用户操作触发
                 ↓
┌────────────────────────────────────────────────────────────────┐
│                      HistoryManager                            │
│  ┌────────────────┐  ┌────────────────┐  ┌──────────────────┐ │
│  │ Undo Stack     │  │ Redo Stack     │  │ Pending Queue    │ │
│  │ [PatchGroup]   │  │ [PatchGroup]   │  │ Map<key, Group>  │ │
│  └────────────────┘  └────────────────┘  └──────────────────┘ │
│                                                                │
│  - modifyWithHistory(desc, updater, key, sideEffects)         │
│  - undo()  - redo()  - RAF + 防抖批处理                        │
└────────────────┬───────────────────────────────────────────────┘
                 │
          ┌──────┴──────┐
          │             │
          ↓             ↓
    ┌──────────┐   ┌──────────────────────────────┐
    │sideEffects│   │    RuntimeStateManager        │ ← 唯一数据修改入口
    │(可选)     │   │  (基于 Immer.js)              │
    └──────────┘   └──────────────────────────────┘
         │                      │
         │ 文件IO               │ modify(updater)
         │ 引用计数             │ 返回 {patches, inversePatches}
         ↓                      ↓
    ┌────────────────────────────────────────────┐
    │  produceWithPatches(state, draft => {...}) │ ← Immer核心API
    │  自动生成 [nextState, patches, inversePatches] │
    └────────────────────────────────────────────┘
                     │
                     │ Patch 分发
                     ↓
         ┌──────────────────────────────┐
         │  applyPatchesToStores()      │ ← Patch 分发器
         │  (手动分发到 4 个 Store)      │
         └──────────────────────────────┘
                     │
          ┌──────────┼───────────┬──────────┐
          ↓          ↓           ↓          ↓
    ┌──────────┐ ┌─────────┐ ┌──────────┐ ┌──────────┐
    │layerTree │ │treeStore│ │formStore │ │selection │
    │Manager   │ │         │ │          │ │Store     │
    └──────────┘ └─────────┘ └──────────┘ └──────────┘
         │          │           │          │
         └──────────┴───────────┴──────────┘
                     │
                     │ Vue 2 响应式系统
                     ↓
         ┌──────────────────────┐
         │   渲染层 (UI 更新)    │
         └──────────────────────┘
```

**核心数据流**：

```
用户操作（拖拽、修改属性等）
       ↓
history.modifyWithHistory(description, draft => {...}, key, sideEffects)
       ↓
1. 立即执行修改
   runtimeManager.modify(updater)
   → produceWithPatches 生成 patches/inversePatches
       ↓
2. 加入 Map 队列（自动去重）
   pendingPatchGroups.set(key, { patches, inversePatches, ... })
       ↓
3. RAF 批量渲染
   requestAnimationFrame(() => applyPatchesToStores(patches))
   → 分发到 4 个 Store
   → Vue 2 响应式自动更新 UI（实时反馈）
       ↓
4. 防抖记录历史（30ms 后）
   setTimeout(() => recordToHistory())
   → 从 Map 中取出所有 PatchGroup
   → 合并后推入 undoStack
   → 历史记录完成（30 次操作 → 1 条历史）
```

---

### 核心模块设计

#### 1. RuntimeStateManager - 唯一数据修改入口

```javascript
import { produceWithPatches, applyPatches as immerApplyPatches } from 'immer'

/**
 * RuntimeState 管理器 - 唯一数据修改入口
 *
 * 核心职责：
 * 1. 通过 produceWithPatches 自动生成 Patch
 * 2. 管理单一数据源（runtimeState）
 * 3. 不直接操作 UI（通过 Patch 分发到 UI Stores）
 */
class RuntimeStateManager {
  /**
   * @param {Object} initial - 初始状态
   * @param {Object} initial.tree - 图层树数据
   * @param {Object} initial.preview - 预览数据
   * @param {Object} initial.json - JSON Schema
   * @param {Array} initial.vars - 变量数组
   * @param {String} initial.xml - XML字符串
   * @param {Object} initial.meta - 元数据
   */
  constructor(initial) {
    this.state = initial || {
      tree: { layers: {}, layerOrder: [] },
      preview: {},
      json: { elements: [] },
      vars: [],
      xml: '',
      meta: {}
    }
  }

  /**
   * ⭐ 核心方法：修改 Schema 并返回 Patch
   *
   * 这是唯一的数据修改入口！所有修改必须通过此方法。
   *
   * @param {Function} updater - 修改函数，操作 draft 对象
   * @returns {{ patches: Patch[], inversePatches: Patch[] }}
   */
  modify(updater) {
    // 使用 Immer 的 produceWithPatches 自动生成 patch
    const [nextState, patches, inversePatches] = produceWithPatches(
      this.state,
      updater
    )

    // 更新内部状态
    this.state = nextState

    return { patches, inversePatches }
  }

  /**
   * 应用 Patches（用于撤销/重做）
   *
   * @param {Patch[]} patches - Immer 标准 Patch 数组
   */
  applyPatches(patches) {
    this.state = immerApplyPatches(this.state, patches)
    return this.state
  }

  /**
   * 获取当前状态（只读）
   */
  getState() {
    return this.state
  }

  /**
   * 直接设置状态（仅用于快照恢复）
   */
  setState(newState) {
    this.state = newState
  }

  /**
   * 克隆当前状态（用于快照）
   */
  clone() {
    return JSON.parse(JSON.stringify(this.state))
  }
}
```

**使用示例：**

```javascript
// 初始化
const runtimeManager = new RuntimeStateManager({
  tree: { layers: {}, layerOrder: [] },
  preview: {},
  json: { elements: [] },
  vars: [],
  xml: '',
  meta: {}
})

// ✅ 修改单个属性
const { patches, inversePatches } = runtimeManager.modify(draft => {
  draft.preview.node_123.meta.x = 150
})
// patches: [{ op: "replace", path: ["preview", "node_123", "meta", "x"], value: 150 }]

// ✅ 批量修改
const result = runtimeManager.modify(draft => {
  draft.tree.layers.node_456 = { id: 'node_456', pid: '', type: 'Text' }
  draft.preview.node_456 = { id: 'node_456', meta: { x: 0, y: 0 } }
  draft.json.elements.push({ name: 'Text', attributes: { id: 'node_456' } })
})
// Immer 自动生成 3 个 patch

// ✅ 删除节点
runtimeManager.modify(draft => {
  delete draft.tree.layers.node_123
  delete draft.preview.node_123
  draft.json.elements = draft.json.elements.filter(el => el.attributes.id !== 'node_123')
})
```

---

#### 2. HistoryManager - 历史栈管理 + RAF + 防抖批处理

```javascript
/**
 * 历史管理器
 *
 * 核心功能：
 * 1. 管理 undo/redo 双栈
 * 2. RAF 批处理（实时 UI 更新）
 * 3. 防抖合并（历史记录去重）
 * 4. 周期快照（加速长距离撤销）
 * 5. sideEffects 对称处理（文件 IO）
 */
class HistoryManager {
  constructor({
    max = 100,                // 最大历史记录数
    snapshotInterval = 20,    // 快照间隔（每 N 步）
    debounceDelay = 30        // 防抖延迟（ms）
  }) {
    // 双栈
    this.undoStack = []       // PatchGroup[]
    this.redoStack = []       // PatchGroup[]

    // 快照
    this.snapshots = new Map() // index → { state, timestamp }
    this.max = max
    this.snapshotInterval = snapshotInterval

    // ⭐ RAF + 防抖批处理
    this.pendingPatchGroups = new Map() // key → PatchGroup（自动去重）
    this.rafTimer = null
    this.debounceTimer = null
    this.DEBOUNCE_DELAY = debounceDelay

    // 外部注入
    this.runtimeManager = null  // RuntimeStateManager 实例
    this.applyPatchesToStores = null // Patch 分发器函数
  }

  /**
   * ⭐ 核心方法：带历史记录的修改
   *
   * @param {string} description - 操作描述（显示在历史面板）
   * @param {Function} updater - 修改函数 (draft) => {...}
   * @param {string} key - 去重 key（可选，用于高频操作合并）
   * @param {Object} sideEffects - 副作用对象（可选）
   * @param {Function} sideEffects.redo - 重做副作用
   * @param {Function} sideEffects.undo - 撤销副作用
   */
  modifyWithHistory(description, updater, key, sideEffects) {
    // 1. ✅ 立即执行修改，获取 Patches
    const { patches, inversePatches } = this.runtimeManager.modify(updater)

    // 2. ✅ 生成去重 key（同路径操作会自动覆盖）
    const operationKey = key || this.generateKey(patches)

    // 3. ✅ 加入队列（Map 自动去重）
    this.pendingPatchGroups.set(operationKey, {
      patches,
      inversePatches,
      description,
      timestamp: Date.now(),
      sideEffects
    })

    // 4. ✅ RAF 批量渲染（Vue 2 自动更新 UI）
    if (this.rafTimer === null) {
      this.rafTimer = requestAnimationFrame(() => {
        this.flushRender()
      })
    }

    // 5. ✅ 防抖记录历史（延迟记录）
    if (this.debounceTimer !== null) {
      clearTimeout(this.debounceTimer)
    }
    this.debounceTimer = setTimeout(() => {
      this.recordToHistory()
    }, this.DEBOUNCE_DELAY)
  }

  /**
   * RAF 触发（批量应用 Patches 到 UI Stores）
   */
  flushRender() {
    if (this.pendingPatchGroups.size === 0) {
      this.rafTimer = null
      return
    }

    // 将所有待处理的 Patches 应用到 UI Stores
    const groups = Array.from(this.pendingPatchGroups.values())
    groups.forEach(group => {
      if (this.applyPatchesToStores) {
        this.applyPatchesToStores(group.patches)
      }
    })

    this.rafTimer = null
    console.log(`[RAF] Applied ${groups.length} patch groups to UI`)
  }

  /**
   * 记录到历史（防抖触发）
   */
  recordToHistory() {
    if (this.pendingPatchGroups.size === 0) {
      this.debounceTimer = null
      return
    }

    const groups = Array.from(this.pendingPatchGroups.values())

    // 添加到历史栈
    groups.forEach(group => {
      this.undoStack.push(group)
    })

    // 清空 redo 栈
    this.redoStack = []

    // 裁剪 + 快照
    this.trim()
    this.saveSnapshotIfNeeded()

    // 清空队列
    this.pendingPatchGroups.clear()
    this.debounceTimer = null

    console.log(`[History] Recorded ${groups.length} operations, total: ${this.undoStack.length}`)
  }

  /**
   * 生成去重 key
   *
   * 策略：使用第一个 Patch 的路径作为 key
   * 例如：["preview", "node_123", "meta", "x"] → "preview:node_123:meta:x"
   *
   * 效果：同一个节点的 x 坐标修改会自动覆盖（保留最后一次）
   */
  generateKey(patches) {
    if (patches.length === 0) return `empty_${Date.now()}`
    return patches[0].path.join(':')
  }

  /**
   * 撤销操作
   *
   * @param {number} steps - 撤销步数（默认 1）
   */
  undo(steps = 1) {
    // 先强制提交待处理的操作
    this.forceFlush()

    for (let i = 0; i < steps && this.canUndo(); i++) {
      const group = this.undoStack.pop()
      if (!group) break

      // 1. 应用反向 Patches 到 runtimeState
      this.runtimeManager.applyPatches(group.inversePatches)

      // 2. 应用反向 Patches 到 UI Stores
      if (this.applyPatchesToStores) {
        this.applyPatchesToStores(group.inversePatches)
      }

      // 3. 撤销副作用（如文件引用计数减少）
      if (group.sideEffects?.undo) {
        try {
          group.sideEffects.undo()
        } catch (error) {
          console.error('[SideEffect] Undo failed:', error)
        }
      }

      // 4. 移动到重做栈
      this.redoStack.push(group)

      console.log(`[Undo] ${group.description}`)
    }
  }

  /**
   * 重做操作
   *
   * @param {number} steps - 重做步数（默认 1）
   */
  redo(steps = 1) {
    for (let i = 0; i < steps && this.canRedo(); i++) {
      const group = this.redoStack.pop()
      if (!group) break

      // 1. 应用正向 Patches 到 runtimeState
      this.runtimeManager.applyPatches(group.patches)

      // 2. 应用正向 Patches 到 UI Stores
      if (this.applyPatchesToStores) {
        this.applyPatchesToStores(group.patches)
      }

      // 3. 重做副作用（如文件引用计数增加）
      if (group.sideEffects?.redo) {
        try {
          group.sideEffects.redo()
        } catch (error) {
          console.error('[SideEffect] Redo failed:', error)
        }
      }

      // 4. 移动到撤销栈
      this.undoStack.push(group)

      console.log(`[Redo] ${group.description}`)
    }
  }

  /**
   * 立即刷新（强制提交待处理的操作）
   */
  forceFlush() {
    // 取消所有定时器
    if (this.rafTimer !== null) {
      cancelAnimationFrame(this.rafTimer)
      this.rafTimer = null
    }
    if (this.debounceTimer !== null) {
      clearTimeout(this.debounceTimer)
      this.debounceTimer = null
    }

    // 先刷新渲染，再记录历史
    this.flushRender()
    this.recordToHistory()
  }

  /**
   * 保存快照（如果需要）
   */
  saveSnapshotIfNeeded() {
    const currentIndex = this.undoStack.length

    if (currentIndex % this.snapshotInterval === 0 && currentIndex > 0) {
      const state = this.runtimeManager.clone()
      this.snapshots.set(currentIndex, {
        state: state,
        timestamp: Date.now()
      })

      console.log(`[Snapshot] Saved at index ${currentIndex}`)

      // 限制快照数量（最多保留 10 个）
      if (this.snapshots.size > 10) {
        const oldestKey = Math.min(...this.snapshots.keys())
        this.snapshots.delete(oldestKey)
      }
    }
  }

  /**
   * 裁剪历史栈（LRU 策略）
   */
  trim() {
    if (this.undoStack.length > this.max) {
      const removeCount = this.undoStack.length - this.max
      this.undoStack.splice(0, removeCount)

      // 清理对应的快照
      this.snapshots.forEach((_, index) => {
        if (index < removeCount) {
          this.snapshots.delete(index)
        }
      })
    }
  }

  /**
   * 工具方法
   */
  canUndo() {
    return this.undoStack.length > 0
  }

  canRedo() {
    return this.redoStack.length > 0
  }

  getState() {
    return {
      canUndo: this.canUndo(),
      canRedo: this.canRedo(),
      undoCount: this.undoStack.length,
      redoCount: this.redoStack.length
    }
  }
}
```

**使用示例：**

```javascript
// 初始化
const runtimeManager = new RuntimeStateManager(initialState)
const historyManager = new HistoryManager({ max: 100, snapshotInterval: 20 })

// 注入依赖
historyManager.runtimeManager = runtimeManager
historyManager.applyPatchesToStores = (patches) => {
  // 将 patches 分发到 4 个 UI Stores（见第 8 章）
  applyPatchesToStores(patches)
}

// ✅ 普通操作（自动合并）
historyManager.modifyWithHistory(
  '修改节点位置',
  draft => {
    draft.preview.node_123.meta.x = 150
    draft.preview.node_123.meta.y = 200
  }
)

// ✅ 高频操作（指定 key，自动覆盖）
function onDrag(nodeId, x, y) {
  historyManager.modifyWithHistory(
    `拖拽节点 ${nodeId}`,
    draft => {
      draft.preview[nodeId].meta.x = x
      draft.preview[nodeId].meta.y = y
    },
    `drag:${nodeId}` // ← 同一个节点的拖拽操作会覆盖
  )
}

// ✅ 带副作用的操作（文件上传）
historyManager.modifyWithHistory(
  '添加图片组件',
  draft => {
    const nodeId = 'node_' + Date.now()
    const imageHash = 'a3d2f1e9...' // FilePool 返回的 hash

    draft.tree.layers[nodeId] = { id: nodeId, type: 'Image' }
    draft.preview[nodeId] = { id: nodeId, meta: { x: 0, y: 0 } }
    draft.json.elements.push({
      name: 'Image',
      attributes: {
        id: nodeId,
        src: { hash: imageHash, androidPath: 'drawable/icon.png' }
      }
    })
  },
  null, // key（自动生成）
  {
    // ← 副作用：文件引用计数
    redo: () => { filePool.addRef(imageHash) },
    undo: () => { filePool.removeRef(imageHash) }
  }
)

// ✅ 撤销/重做
historyManager.undo()    // 撤销 1 步
historyManager.redo()    // 重做 1 步
historyManager.undo(5)   // 撤销 5 步
```

---

#### 3. PatchGroup 数据结构

```typescript
/**
 * PatchGroup - 历史记录的存储单元
 *
 * 注意：undoStack 和 redoStack 存储的是 PatchGroup，而非完整状态
 */
interface PatchGroup {
  /** 正向 Patch（用于 redo） */
  patches: Patch[]

  /** 反向 Patch（用于 undo） */
  inversePatches: Patch[]

  /** 操作描述（人类可读） */
  description: string

  /** 时间戳 */
  timestamp: number

  /** 可选：副作用处理器 */
  sideEffects?: {
    redo?: () => void  // 重做副作用（如文件引用 +1）
    undo?: () => void  // 撤销副作用（如文件引用 -1）
  }
}

/**
 * Immer Patch 格式（标准 JSON Patch）
 */
interface Patch {
  op: 'add' | 'remove' | 'replace'  // 操作类型
  path: (string | number)[]         // 路径数组，如 ['preview', 'node_123', 'meta', 'x']
  value?: any                       // 新值（add/replace 需要）
}
```

**Patch 示例：**

```javascript
// 修改节点位置
{
  patches: [
    { op: 'replace', path: ['preview', 'node_123', 'meta', 'x'], value: 150 },
    { op: 'replace', path: ['preview', 'node_123', 'meta', 'y'], value: 200 }
  ],
  inversePatches: [
    { op: 'replace', path: ['preview', 'node_123', 'meta', 'x'], value: 100 },
    { op: 'replace', path: ['preview', 'node_123', 'meta', 'y'], value: 100 }
  ],
  description: '修改节点位置',
  timestamp: 1702345678000
}

// 添加节点
{
  patches: [
    { op: 'add', path: ['tree', 'layers', 'node_456'], value: { id: 'node_456', type: 'Text' } },
    { op: 'add', path: ['preview', 'node_456'], value: { id: 'node_456', meta: {...} } }
  ],
  inversePatches: [
    { op: 'remove', path: ['tree', 'layers', 'node_456'] },
    { op: 'remove', path: ['preview', 'node_456'] }
  ],
  description: '添加文本组件',
  timestamp: 1702345678000
}

// 删除节点
{
  patches: [
    { op: 'remove', path: ['tree', 'layers', 'node_123'] },
    { op: 'remove', path: ['preview', 'node_123'] }
  ],
  inversePatches: [
    { op: 'add', path: ['tree', 'layers', 'node_123'], value: { id: 'node_123', type: 'Image' } },
    { op: 'add', path: ['preview', 'node_123'], value: { id: 'node_123', meta: {...} } }
  ],
  description: '删除图片组件',
  timestamp: 1702345678000
}
```

---

### RAF + 防抖策略详解

**问题场景：用户拖拽节点**

```
用户按住鼠标 → mousemove × 30 次（500ms内） → 松开鼠标
```

**方案对比：**

| 方案            | 执行时机          | 渲染效果       | 历史记录       | 问题               |
| --------------- | ----------------- | -------------- | -------------- | ------------------ |
| **纯防抖**      | 500ms 后执行 1 次 | ❌ 无实时反馈  | ✅ 1 条记录    | UI 卡顿            |
| **纯 RAF**      | 每 16ms 执行 1 次 | ✅ 流畅        | ❌ 30 条记录   | 历史污染           |
| **RAF + 防抖**  | 立即执行 + 延迟记录 | ✅ 流畅        | ✅ 1 条记录    | ✅ 完美            |

**实现原理：**

```javascript
// 用户触发 30 次 mousemove
for (let i = 0; i < 30; i++) {
  onDrag('node_123', 100 + i, 200 + i)
}

// ↓ modifyWithHistory 内部流程

// 1. 立即执行修改（30 次）
runtimeManager.modify(draft => {
  draft.preview.node_123.meta.x = 100 + i
  draft.preview.node_123.meta.y = 200 + i
})

// 2. Map 自动去重（key = "drag:node_123"）
pendingPatchGroups.set('drag:node_123', {
  patches: [...],  // ← 只保留最后一次的 patches
  inversePatches: [...],
  description: '拖拽节点 node_123'
})

// 3. RAF 触发（每 16ms 一次，约 2-3 次）
requestAnimationFrame(() => {
  applyPatchesToStores(patches) // ← 应用到 UI
})
// 结果：UI 实时更新，流畅无卡顿

// 4. 防抖触发（500ms 后只触发 1 次）
setTimeout(() => {
  undoStack.push(pendingPatchGroups.get('drag:node_123'))
  pendingPatchGroups.clear()
}, 30)
// 结果：30 次拖拽 → 1 条历史记录
```

**性能数据：**

| 指标         | 纯 RAF 方案    | RAF + 防抖方案 | 优化比例 |
| ------------ | -------------- | -------------- | -------- |
| **渲染次数** | 30 次          | 2-3 次         | 90%      |
| **历史记录** | 30 条          | 1 条           | 97%      |
| **用户体验** | 流畅（但历史多）| 流畅 + 历史少  | ✅       |

---

### 快照加速长距离撤销

**问题：连续撤销 50 步很慢**

```javascript
// 传统方案：逐个应用 inversePatches
for (let i = 0; i < 50; i++) {
  applyPatches(undoStack[i].inversePatches)
}
// 耗时：50 × 10ms = 500ms（可感知卡顿）
```

**快照方案：**

```javascript
// 每 20 步保存一次快照
snapshots.set(20, { state: clone(runtimeState), timestamp: ... })
snapshots.set(40, { state: clone(runtimeState), timestamp: ... })
snapshots.set(60, { state: clone(runtimeState), timestamp: ... })

// 撤销 50 步时
1. 找到最近的快照（index = 40）
2. 恢复快照到 index 40
3. 只需要应用 10 个 inversePatches（从 50 到 40）
// 耗时：快照恢复 50ms + 10 × 10ms = 150ms（快 3 倍）
```

**实现：**

```javascript
saveSnapshotIfNeeded() {
  const currentIndex = this.undoStack.length

  // 每 20 步保存一次
  if (currentIndex % 20 === 0 && currentIndex > 0) {
    this.snapshots.set(currentIndex, {
      state: this.runtimeManager.clone(),
      timestamp: Date.now()
    })
  }
}

// 加速撤销（使用快照）
undoWithSnapshot(steps) {
  const targetIndex = this.undoStack.length - steps

  // 查找最近的快照
  let nearestSnapshotIndex = 0
  for (const [index, snapshot] of this.snapshots) {
    if (index <= targetIndex && index > nearestSnapshotIndex) {
      nearestSnapshotIndex = index
    }
  }

  if (nearestSnapshotIndex > 0) {
    // 1. 恢复快照
    const snapshot = this.snapshots.get(nearestSnapshotIndex)
    this.runtimeManager.setState(snapshot.state)

    // 2. 只应用剩余的 inversePatches
    const remainingSteps = this.undoStack.length - nearestSnapshotIndex
    for (let i = 0; i < remainingSteps; i++) {
      this.undo(1)
    }
  } else {
    // 无快照，逐个撤销
    for (let i = 0; i < steps; i++) {
      this.undo(1)
    }
  }
}
```

---

## 🔄 8. UI 同步策略（Patch 分发机制）

### 双层架构的挑战

在双层架构中，runtimeState 是单一数据源，但 UI 由 4 个独立的 Store 渲染：

```
runtimeState (单一数据源)
      ↓ Patch 分发
┌─────────┬──────────┬─────────────┬─────────────┐
│ layerTreeManager  │  treeStore  │  formStore  │  selectionStore
│ (左侧图层树)      │  (中间画布) │  (右侧表单) │  (选中状态)
└──────────┴──────────┴─────────────┴─────────────┘
      ↓         ↓           ↓            ↓
   Vue 2 响应式系统自动更新 UI
```

**核心问题：如何将 Immer 生成的 Patch 正确分发到 4 个 Store？**

---

### Patch 分发器实现

```javascript
/**
 * 将 Patch 分发到 4 个 UI Stores
 *
 * @param {Patch[]} patches - Immer 生成的标准 Patch
 */
function applyPatchesToStores(patches) {
  if (!patches || patches.length === 0) return

  patches.forEach(patch => {
    const { op, path, value } = patch
    const [root, ...rest] = path

    try {
      // 根据 path 的第一层路径，分发到不同的 Store
      switch (root) {
        case 'tree':
          applyPatchToLayerTree(op, rest, value)
          break

        case 'preview':
          applyPatchToTreeStore(op, rest, value)
          break

        case 'json':
          // json 变化可能影响表单
          applyPatchToFormStore(op, rest, value)
          break

        case 'vars':
          applyPatchToVars(op, rest, value)
          break

        case 'meta':
          // 元数据变化（如选中状态）
          applyPatchToMeta(op, rest, value)
          break

        default:
          console.warn(`Unknown patch root: ${root}`, patch)
      }
    } catch (error) {
      console.error('[Patch Apply Failed]', patch, error)
      // 降级：从 runtimeState 重建对应的 Store
      rebuildStoreFromRuntime(root)
    }
  })
}
```

---

### 各 Store 的 Patch 处理

#### 1. layerTreeManager（左侧图层树）

```javascript
/**
 * 应用 Patch 到 layerTreeManager
 *
 * path 格式：['tree', 'layers', 'node_123', 'name']
 * rest: ['layers', 'node_123', 'name']
 */
function applyPatchToLayerTree(op, rest, value) {
  const [segment, nodeId, field] = rest

  if (segment !== 'layers') return

  switch (op) {
    case 'add':
      // 添加节点
      if (field === undefined) {
        // path: ['tree', 'layers', 'node_123']
        layerTreeManager.add(value)
      }
      break

    case 'remove':
      // 删除节点
      if (field === undefined) {
        layerTreeManager.delete(nodeId)
      }
      break

    case 'replace':
      // 更新节点
      if (nodeId && field) {
        // path: ['tree', 'layers', 'node_123', 'name']
        layerTreeManager.update(nodeId, { [field]: value })
      }
      break
  }

  // 强制触发 Vue 2 响应式更新（如果需要）
  // layerTreeManager.layerData.value = [...layerTreeManager.layerData.value]
}
```

**需要补充的方法：**

```javascript
// layerTreeManager 需要实现的方法（当前可能缺失）
class LayerTreeManager {
  // 已有：add、delete
  add(node) { /* ... */ }
  delete(nodeId) { /* ... */ }

  // 🆕 需要新增：update
  update(nodeId, changes) {
    const node = this.layerData.value.find(n => n.id === nodeId)
    if (node) {
      Object.assign(node, changes)
      // 触发响应式更新
      this.layerData.value = [...this.layerData.value]
    }
  }

  // 🆕 需要新增：move
  move(nodeId, newPid, newIndex) {
    const node = this.layerData.value.find(n => n.id === nodeId)
    if (node) {
      node.pid = newPid
      // 调整顺序...
      this.layerData.value = [...this.layerData.value]
    }
  }
}
```

---

#### 2. treeStore（中间画布预览）

```javascript
/**
 * 应用 Patch 到 treeStore
 *
 * path 格式：['preview', 'node_123', 'meta', 'x']
 * rest: ['node_123', 'meta', 'x']
 */
function applyPatchToTreeStore(op, rest, value) {
  const [nodeId, ...fields] = rest

  switch (op) {
    case 'add':
      // 添加节点到画布
      if (fields.length === 0) {
        // path: ['preview', 'node_123']
        treeStore.add(value)
      }
      break

    case 'remove':
      // 从画布删除节点
      if (fields.length === 0) {
        treeStore.remove(nodeId)
      }
      break

    case 'replace':
      // 更新节点属性
      if (fields.length > 0) {
        // path: ['preview', 'node_123', 'meta', 'x']
        const changes = buildNestedObject(fields, value)
        treeStore.update(nodeId, changes)
      }
      break
  }
}

/**
 * 辅助函数：从路径构建嵌套对象
 * ['meta', 'x'], 150 → { meta: { x: 150 } }
 */
function buildNestedObject(path, value) {
  if (path.length === 0) return value

  const [first, ...rest] = path
  return { [first]: buildNestedObject(rest, value) }
}
```

**treeStore 已有的方法：**

```javascript
class TreeStore {
  // 已有完整的 CRUD 方法
  add(node) {
    this.nodeMap.set(node.id, node)
    this.eventBus.emit('node:added', node)
  }

  update(nodeId, changes) {
    const node = this.nodeMap.get(nodeId)
    if (node) {
      // 深度合并
      deepMerge(node, changes)
      this.eventBus.emit('node:updated', node)
    }
  }

  remove(nodeId) {
    this.nodeMap.delete(nodeId)
    this.eventBus.emit('node:removed', nodeId)
  }

  move(nodeId, newPid, newIndex) {
    // ...
  }
}
```

---

#### 3. currentFormStore（右侧属性表单）

```javascript
/**
 * 应用 Patch 到 formStore
 *
 * 策略：表单数据依赖于选中节点，Patch 变化时检查是否需要重新获取表单
 */
function applyPatchToFormStore(op, rest, value) {
  const [segment, nodeId, ...fields] = rest

  // 如果修改的是当前选中的节点，重新获取表单数据
  const selectedId = selectionStore.selectedNodeId.value

  if (nodeId === selectedId) {
    // 方案1：重新获取表单数据（推荐，数据来自后端）
    currentFormStore.fetchFormData(nodeId)

    // 方案2：直接更新表单字段（如果表单是纯前端维护）
    // const fieldPath = fields.join('.')
    // currentFormStore.updateField(fieldPath, value)
  }
}
```

**formStore 示例：**

```javascript
class CurrentFormStore {
  formData = ref([])

  async fetchFormData(nodeId) {
    // 从后端或 runtimeState 获取表单数据
    const response = await getFormDataByID(lockscreenID, nodeId)
    this.formData.value = response.data.form
  }

  updateField(fieldPath, value) {
    // 直接更新表单字段
    const field = this.formData.value.find(f => f.name === fieldPath)
    if (field) {
      field.value = value
    }
  }
}
```

---

#### 4. selectionStore（选中状态）

```javascript
/**
 * 应用 Patch 到 selectionStore
 *
 * 规则：
 * - 删除节点时，如果该节点被选中，清空选中
 * - 添加节点时，可选自动选中新节点
 */
function applyPatchToMeta(op, rest, value) {
  // 删除节点时检查选中状态
  if (op === 'remove') {
    const [segment, nodeId] = rest
    if (segment === 'layers' || segment === nodeId) {
      const selectedId = selectionStore.selectedNodeId.value
      if (selectedId === nodeId) {
        selectionStore.clearSelection()
      }
    }
  }
}
```

---

### 完整的 Patch 分发流程

```javascript
// 在 HistoryManager 中调用
class HistoryManager {
  flushRender() {
    if (this.pendingPatchGroups.size === 0) {
      this.rafTimer = null
      return
    }

    // 将所有待处理的 Patches 应用到 UI Stores
    const groups = Array.from(this.pendingPatchGroups.values())
    groups.forEach(group => {
      // ⭐ 调用 Patch 分发器
      applyPatchesToStores(group.patches)
    })

    this.rafTimer = null
    console.log(`[RAF] Applied ${groups.length} patch groups to UI`)
  }

  undo(steps = 1) {
    // ...
    // 1. 应用反向 Patches 到 runtimeState
    this.runtimeManager.applyPatches(group.inversePatches)

    // 2. ⭐ 应用反向 Patches 到 UI Stores
    applyPatchesToStores(group.inversePatches)

    // 3. 撤销副作用
    if (group.sideEffects?.undo) {
      group.sideEffects.undo()
    }
  }

  redo(steps = 1) {
    // ...
    // 1. 应用正向 Patches 到 runtimeState
    this.runtimeManager.applyPatches(group.patches)

    // 2. ⭐ 应用正向 Patches 到 UI Stores
    applyPatchesToStores(group.patches)

    // 3. 重做副作用
    if (group.sideEffects?.redo) {
      group.sideEffects.redo()
    }
  }
}
```

---

### 降级策略：从 runtimeState 重建 UI

```javascript
/**
 * 当 Patch 分发失败时，从 runtimeState 完全重建对应的 Store
 */
function rebuildStoreFromRuntime(storeType) {
  const state = runtimeManager.getState()

  switch (storeType) {
    case 'tree':
      // 重建 layerTreeManager
      const layers = Object.values(state.tree.layers)
      layerTreeManager.layerData.value = layers
      break

    case 'preview':
      // 重建 treeStore
      treeStore.nodeMap.clear()
      Object.values(state.preview).forEach(node => {
        treeStore.add(node)
      })
      break

    case 'json':
      // 重建 formStore（如果有选中节点）
      const selectedId = selectionStore.selectedNodeId.value
      if (selectedId) {
        currentFormStore.fetchFormData(selectedId)
      }
      break

    case 'vars':
      // 重建变量
      // updateVars(state.vars)
      break
  }

  console.warn(`[Rebuild] Rebuilt ${storeType} from runtimeState`)
}
```

---

### 一致性校验（定期检查）

```javascript
/**
 * 定期校验 runtimeState 与 UI Store 的一致性
 * 推荐：每 5 分钟或每 100 次操作后执行一次
 */
function validateConsistency() {
  const state = runtimeManager.getState()
  let inconsistencies = []

  // 1. 检查 layerTreeManager
  const layerIds = Object.keys(state.tree.layers)
  const uiLayerIds = layerTreeManager.layerData.value.map(n => n.id)
  const layerDiff = arrayDiff(layerIds, uiLayerIds)
  if (layerDiff.length > 0) {
    inconsistencies.push(`layerTree: ${layerDiff.join(', ')}`)
  }

  // 2. 检查 treeStore
  const previewIds = Object.keys(state.preview)
  const canvasIds = Array.from(treeStore.nodeMap.keys())
  const previewDiff = arrayDiff(previewIds, canvasIds)
  if (previewDiff.length > 0) {
    inconsistencies.push(`treeStore: ${previewDiff.join(', ')}`)
  }

  // 如果发现不一致，重建 UI
  if (inconsistencies.length > 0) {
    console.error('[Consistency Check Failed]', inconsistencies)
    rebuildAllStoresFromRuntime()
  } else {
    console.log('[Consistency Check] ✅ All stores in sync')
  }
}

// 每 5 分钟执行一次
setInterval(validateConsistency, 5 * 60 * 1000)
```

---

### 性能优化：批量分发

```javascript
/**
 * 优化：批量分发 Patches，减少 Store 更新次数
 */
function applyPatchesToStoresBatch(patches) {
  // 1. 按 Store 分组
  const grouped = {
    tree: [],
    preview: [],
    json: [],
    vars: []
  }

  patches.forEach(patch => {
    const [root] = patch.path
    if (grouped[root]) {
      grouped[root].push(patch)
    }
  })

  // 2. 批量应用到各 Store
  Object.entries(grouped).forEach(([store, storePatches]) => {
    if (storePatches.length === 0) return

    // 批量更新（减少响应式更新次数）
    switch (store) {
      case 'tree':
        layerTreeManager.batchUpdate(() => {
          storePatches.forEach(p => applyPatchToLayerTree(p.op, p.path.slice(1), p.value))
        })
        break

      case 'preview':
        treeStore.batchUpdate(() => {
          storePatches.forEach(p => applyPatchToTreeStore(p.op, p.path.slice(1), p.value))
        })
        break

      // ...
    }
  })
}

// Store 需要支持 batchUpdate
class LayerTreeManager {
  batchUpdate(fn) {
    // 暂停响应式更新
    this._batchMode = true
    fn()
    // 恢复并触发一次更新
    this._batchMode = false
    this.layerData.value = [...this.layerData.value]
  }
}
```

---

## ⚡ 9. 渲染优化策略（RAF + 防抖深入）

### 为什么需要 RAF + 防抖组合？

**场景：用户拖拽节点**

```
用户按住鼠标 → mousemove × 30 次（500ms内） → 松开鼠标
```

**三种方案对比：**

| 方案              | 执行时机          | 数据更新       | UI 渲染        | 历史记录       | 用户体验      |
| ----------------- | ----------------- | -------------- | -------------- | -------------- | ------------- |
| **纯防抖**        | 500ms 后执行 1 次 | ❌ 延迟 500ms  | ❌ 延迟 500ms  | ✅ 1 条记录    | ❌ 严重卡顿   |
| **纯 RAF**        | 每 16ms 执行 1 次 | ✅ 实时        | ✅ 流畅        | ❌ 30 条记录   | ⚠️ 历史污染   |
| **RAF + 防抖 ✅** | 立即执行          | ✅ 实时        | ✅ 流畅        | ✅ 1 条记录    | ✅ 完美       |

**关键洞察：分离"执行"和"记录"**

```javascript
// 传统防抖方案的问题
debounce(() => {
  updateData()  // ← 延迟 500ms 才执行
  updateUI()    // ← UI 跟着延迟
  recordHistory() // ← 历史也延迟
}, 500)

// ✅ RAF + 防抖方案
function modifyWithHistory() {
  // 1. 立即执行（不等待）
  updateData()  // ← 立即执行

  // 2. RAF 批量渲染（每 16ms）
  requestAnimationFrame(() => {
    updateUI()  // ← 实时渲染
  })

  // 3. 防抖记录历史（延迟 30ms）
  debounce(() => {
    recordHistory()  // ← 延迟记录
  }, 30)
}
```

---

### RAF 渲染优化的 5 种策略

#### 策略 1：单帧批量更新（基础）

```javascript
class HistoryManager {
  rafTimer = null
  pendingUpdates = []

  scheduleRender() {
    if (this.rafTimer !== null) return

    this.rafTimer = requestAnimationFrame(() => {
      // 批量应用所有待处理的 Patches
      this.pendingUpdates.forEach(patches => {
        applyPatchesToStores(patches)
      })
      this.pendingUpdates = []
      this.rafTimer = null
    })
  }
}
```

**效果：**
- 30 次 mousemove → 2-3 次 RAF 回调
- 渲染次数减少 90%

---

#### 策略 2：优先级渲染（高级）

```javascript
/**
 * 优先级队列：高优先级操作先渲染
 */
class PriorityRenderQueue {
  highPriority = []   // 用户可见的操作（拖拽、点击）
  lowPriority = []    // 后台操作（autosave、统计）

  add(patches, priority = 'high') {
    if (priority === 'high') {
      this.highPriority.push(patches)
    } else {
      this.lowPriority.push(patches)
    }
    this.scheduleRender()
  }

  scheduleRender() {
    if (this.rafTimer !== null) return

    this.rafTimer = requestAnimationFrame(() => {
      // 先处理高优先级
      this.highPriority.forEach(applyPatchesToStores)
      this.highPriority = []

      // 低优先级可能延迟到下一帧
      if (this.lowPriority.length > 0 && Date.now() - this.frameStart < 10) {
        this.lowPriority.forEach(applyPatchesToStores)
        this.lowPriority = []
      }

      this.rafTimer = null
    })
  }
}
```

---

#### 策略 3：增量渲染（避免全量更新）

```javascript
/**
 * 只渲染受影响的节点
 */
function applyPatchesToStoresIncremental(patches) {
  const affectedNodes = new Set()

  patches.forEach(patch => {
    const [root, segment, nodeId] = patch.path

    if (root === 'preview' && nodeId) {
      affectedNodes.add(nodeId)
    }
  })

  // 只更新受影响的节点
  affectedNodes.forEach(nodeId => {
    const node = treeStore.nodeMap.get(nodeId)
    if (node) {
      // 局部更新 Konva 节点
      updateKonvaNode(nodeId, node)
    }
  })
}
```

---

#### 策略 4：智能跳帧（性能保护）

```javascript
/**
 * 如果帧率过低，跳过部分中间帧
 */
class SmartRenderScheduler {
  lastFrameTime = Date.now()
  targetFPS = 60
  frameInterval = 1000 / this.targetFPS

  scheduleRender(patches) {
    const now = Date.now()
    const elapsed = now - this.lastFrameTime

    // 如果距离上次渲染 < 16ms，跳过中间帧
    if (elapsed < this.frameInterval) {
      this.pendingPatches = patches  // 覆盖之前的
      return
    }

    // 否则立即渲染
    requestAnimationFrame(() => {
      applyPatchesToStores(this.pendingPatches || patches)
      this.lastFrameTime = Date.now()
      this.pendingPatches = null
    })
  }
}
```

---

#### 策略 5：离屏渲染（Konva 优化）

```javascript
/**
 * 对于画布（Konva），使用 batchDraw 减少重绘
 */
class TreeStore {
  batchUpdate(fn) {
    // 暂停 Konva 自动渲染
    this.konvaLayer.listening(false)

    // 执行批量更新
    fn()

    // 手动触发一次重绘
    this.konvaLayer.batchDraw()
    this.konvaLayer.listening(true)
  }
}

// 使用
treeStore.batchUpdate(() => {
  patches.forEach(patch => {
    applyPatchToTreeStore(patch.op, patch.path.slice(1), patch.value)
  })
})
```

---

### 防抖合并优化（Map 去重）

**问题：相同属性的重复修改**

```javascript
// 用户快速拖拽，触发 30 次修改
draft.preview.node_123.meta.x = 100
draft.preview.node_123.meta.x = 101
draft.preview.node_123.meta.x = 102
// ...
draft.preview.node_123.meta.x = 130  // ← 只需保留最后一次
```

**解决方案：Map 去重**

```javascript
class HistoryManager {
  pendingPatchGroups = new Map()  // key → PatchGroup

  generateKey(patches) {
    if (patches.length === 0) return `empty_${Date.now()}`
    // 使用第一个 Patch 的路径作为 key
    return patches[0].path.join(':')
    // 例如：["preview", "node_123", "meta", "x"] → "preview:node_123:meta:x"
  }

  modifyWithHistory(description, updater, key, sideEffects) {
    const { patches, inversePatches } = this.runtimeManager.modify(updater)

    const operationKey = key || this.generateKey(patches)

    // ⭐ Map 自动覆盖：同 key 的操作只保留最后一次
    this.pendingPatchGroups.set(operationKey, {
      patches,
      inversePatches,
      description,
      timestamp: Date.now(),
      sideEffects
    })

    this.scheduleRender()
    this.scheduleRecord()
  }
}
```

**效果：**
- 30 次拖拽 → Map 中只有 1 个 PatchGroup
- 历史记录减少 97%

---

### 性能监控

```javascript
/**
 * 性能监控：检测渲染性能
 */
class PerformanceMonitor {
  renderTimes = []

  measureRender(fn) {
    const start = performance.now()
    fn()
    const duration = performance.now() - start

    this.renderTimes.push(duration)

    // 保留最近 100 次
    if (this.renderTimes.length > 100) {
      this.renderTimes.shift()
    }

    // P95 性能指标
    const p95 = this.getPercentile(95)
    if (p95 > 50) {
      console.warn(`[Performance] Render P95: ${p95.toFixed(2)}ms (target: <50ms)`)
    }
  }

  getPercentile(p) {
    const sorted = [...this.renderTimes].sort((a, b) => a - b)
    const index = Math.floor((p / 100) * sorted.length)
    return sorted[index]
  }
}

// 使用
const perfMonitor = new PerformanceMonitor()

function applyPatchesToStores(patches) {
  perfMonitor.measureRender(() => {
    // 实际渲染逻辑
    patches.forEach(...)
  })
}
```

---

## 🎯 10. 操作合并优化（Map 去重算法）

### 合并策略

**目标：减少历史记录数量，同时保持操作语义**

```
30 次拖拽操作 → 合并为 1 条历史记录
3 次颜色修改 → 保留 3 条历史记录（不同属性）
```

---

### Map 去重算法

**核心思想：使用操作路径作为 key，相同路径的操作自动覆盖**

```javascript
/**
 * 生成去重 key 的策略
 */
function generateKey(patches) {
  if (patches.length === 0) return `empty_${Date.now()}`

  // 策略 1：使用第一个 Patch 的路径
  const firstPatch = patches[0]
  return firstPatch.path.join(':')
  // 例如：["preview", "node_123", "meta", "x"] → "preview:node_123:meta:x"
}

// 使用示例
const key1 = generateKey([
  { op: 'replace', path: ['preview', 'node_123', 'meta', 'x'], value: 100 }
])
// key1 = "preview:node_123:meta:x"

const key2 = generateKey([
  { op: 'replace', path: ['preview', 'node_123', 'meta', 'x'], value: 150 }
])
// key2 = "preview:node_123:meta:x" (相同！会覆盖)

const key3 = generateKey([
  { op: 'replace', path: ['preview', 'node_123', 'meta', 'y'], value: 200 }
])
// key3 = "preview:node_123:meta:y" (不同！不会覆盖)
```

---

### 高频操作合并示例

#### 示例 1：拖拽节点

```javascript
// 用户拖拽节点，触发 30 次 mousemove
for (let i = 0; i < 30; i++) {
  historyManager.modifyWithHistory(
    `拖拽节点 node_123`,
    draft => {
      draft.preview.node_123.meta.x = 100 + i
      draft.preview.node_123.meta.y = 200 + i
    },
    `drag:node_123`  // ← 指定 key，所有拖拽操作使用同一个 key
  )
}

// 结果：pendingPatchGroups 中只有 1 个 PatchGroup
console.log(historyManager.pendingPatchGroups.size)  // 1
```

#### 示例 2：滑块调整

```javascript
// 用户拖动滑块，触发 20 次 input 事件
for (let i = 0; i < 20; i++) {
  historyManager.modifyWithHistory(
    '调整透明度',
    draft => {
      draft.preview.node_456.meta.alpha = i * 10  // 0 → 190
    },
    `slider:alpha:node_456`  // ← 指定 key
  )
}

// 结果：20 次调整 → 1 条历史记录
```

#### 示例 3：连续输入文本

```javascript
// 用户输入文本"Hello"
'Hello'.split('').forEach((char, i) => {
  historyManager.modifyWithHistory(
    '输入文本',
    draft => {
      draft.json.elements[0].attributes.text = 'Hello'.slice(0, i + 1)
    },
    `input:text:node_789`  // ← 指定 key
  )
})

// 结果：5 次输入 → 1 条历史记录（内容从 "" → "Hello"）
```

---

### 智能合并算法（可选增强）

**问题：有时需要更智能的合并策略**

```javascript
// 场景：用户先修改 x，后修改 y
draft.preview.node_123.meta.x = 100  // key: "preview:node_123:meta:x"
draft.preview.node_123.meta.y = 200  // key: "preview:node_123:meta:y"

// 问题：生成了 2 个 key，无法合并为 1 条"移动节点"历史
```

**解决方案：时间窗口合并**

```javascript
/**
 * 智能合并：相同节点、相同操作类型、时间窗口内的操作合并
 */
class SmartMergeStrategy {
  timeWindow = 100  // 100ms 内的操作可合并

  generateSmartKey(patches, timestamp) {
    const [root, segment, nodeId, field] = patches[0].path

    // 提取节点 ID 和操作类型
    const operationType = this.getOperationType(patches)

    // 时间窗口 ID（向下取整到 100ms）
    const windowId = Math.floor(timestamp / this.timeWindow)

    // 生成智能 key
    return `${operationType}:${nodeId}:${windowId}`
    // 例如：move:node_123:16723456  (16723456 = timestamp / 100)
  }

  getOperationType(patches) {
    // 分析 Patch，判断操作类型
    if (patches.some(p => p.path.includes('meta'))) {
      return 'move'  // 位置/大小相关
    }
    if (patches.some(p => p.path.includes('text'))) {
      return 'editText'
    }
    // ...
    return 'update'
  }
}
```

**效果：**

```javascript
// 100ms 内修改 x 和 y
historyManager.modifyWithHistory('修改 x', draft => { draft.preview.node_123.meta.x = 100 }, null)  // t=0
historyManager.modifyWithHistory('修改 y', draft => { draft.preview.node_123.meta.y = 200 }, null)  // t=50

// 生成的 key 都是 "move:node_123:16723456" → 自动合并！
```

---

### 合并验收标准

| 场景                | 操作次数 | 期望历史记录数 | 实际合并率 |
| ------------------- | -------- | -------------- | ---------- |
| **拖拽节点**        | 30       | 1              | 97%        |
| **滑块调整**        | 20       | 1              | 95%        |
| **连续输入文本**    | 10       | 1              | 90%        |
| **快速修改多属性**  | 15       | 1-2            | 90%        |
| **不同节点操作**    | 10       | 10             | 0% (正确)  |

---

## 🔍 11. 典型业务流程示例

### 流程 1：添加图片组件

```javascript
/**
 * 添加图片组件（完整流程）
 *
 * 步骤：
 * 1. 用户选择图片文件
 * 2. 上传到 FilePool（去重 + 引用计数）
 * 3. 修改 runtimeState（tree + preview + json）
 * 4. 同步 UI（3 个 Store）
 * 5. 记录历史（带副作用）
 */
async function addImageComponent(imagePath) {
  const parentId = selectionStore.selectedNodeId.value || 'node_root'
  const newId = `node_${Date.now()}`

  // 1. 上传到 FilePool
  const imageHash = await filePool.addFile(imagePath, `drawable/${path.basename(imagePath)}`)
  const metadata = filePool.metadata.get(imageHash)

  // 2. 修改 runtimeState
  historyManager.modifyWithHistory(
    '添加图片组件',
    draft => {
      // tree
      draft.tree.layers[newId] = {
        id: newId,
        pid: parentId,
        type: 'Image',
        name: metadata.filename || '图片'
      }

      // preview
      draft.preview[newId] = {
        id: newId,
        pid: parentId,
        meta: { x: 0, y: 0, w: metadata.width, h: metadata.height, visible: true },
        renderType: 'image'
      }

      // json
      const parentElement = findElementById(draft.json.elements, parentId)
      if (parentElement) {
        parentElement.elements = parentElement.elements || []
        parentElement.elements.push({
          name: 'Image',
          attributes: {
            id: newId,
            src: {
              hash: imageHash,
              androidPath: `drawable/${path.basename(imagePath)}`
            },
            x: '0',
            y: '0',
            w: String(metadata.width),
            h: String(metadata.height)
          }
        })
      }
    },
    `add:${newId}`,
    {
      // 副作用：文件引用计数
      redo: () => { filePool.addRef(imageHash) },
      undo: () => { filePool.removeRef(imageHash) }
    }
  )

  // 3. UI 会自动更新（通过 RAF + Patch 分发）

  // 4. 选中新节点
  selectionStore.selectNode(newId)

  return newId
}
```

---

### 流程 2：删除节点（带子节点）

```javascript
/**
 * 删除节点（递归删除子节点 + 释放文件）
 */
async function deleteNodeRecursive(nodeId) {
  const state = runtimeManager.getState()

  // 1. 收集要删除的节点（包括子节点）
  const nodesToDelete = [nodeId]
  const collectChildren = (id) => {
    Object.values(state.tree.layers).forEach(node => {
      if (node.pid === id) {
        nodesToDelete.push(node.id)
        collectChildren(node.id)
      }
    })
  }
  collectChildren(nodeId)

  // 2. 收集所有关联的文件 hash
  const fileHashes = []
  nodesToDelete.forEach(id => {
    const element = findElementById(state.json.elements, id)
    if (element?.attributes?.src?.hash) {
      fileHashes.push(element.attributes.src.hash)
    }
  })

  // 3. 删除节点
  historyManager.modifyWithHistory(
    `删除节点及其 ${nodesToDelete.length - 1} 个子节点`,
    draft => {
      nodesToDelete.forEach(id => {
        // 删除 tree
        delete draft.tree.layers[id]

        // 删除 preview
        delete draft.preview[id]

        // 删除 json（需要从父节点的 elements 中移除）
        const parentElement = findParentElement(draft.json.elements, id)
        if (parentElement && parentElement.elements) {
          parentElement.elements = parentElement.elements.filter(el => el.attributes.id !== id)
        }
      })
    },
    `delete:${nodeId}`,
    {
      // 副作用：释放文件引用
      redo: () => {
        fileHashes.forEach(hash => filePool.removeRef(hash))
      },
      undo: () => {
        fileHashes.forEach(hash => filePool.addRef(hash))
      }
    }
  )

  // 4. 清空选中
  if (selectionStore.selectedNodeId.value === nodeId) {
    selectionStore.clearSelection()
  }
}
```

---

### 流程 3：替换图片

```javascript
/**
 * 替换图片（释放旧文件 + 添加新文件）
 */
async function replaceImage(nodeId, newImagePath) {
  const state = runtimeManager.getState()

  // 1. 获取旧图片 hash
  const element = findElementById(state.json.elements, nodeId)
  const oldHash = element?.attributes?.src?.hash

  // 2. 上传新图片
  const newHash = await filePool.addFile(newImagePath, `drawable/${path.basename(newImagePath)}`)
  const metadata = filePool.metadata.get(newHash)

  // 3. 替换
  historyManager.modifyWithHistory(
    '替换图片',
    draft => {
      const el = findElementById(draft.json.elements, nodeId)
      if (el) {
        el.attributes.src = {
          hash: newHash,
          androidPath: `drawable/${path.basename(newImagePath)}`
        }
      }
    },
    `replace:image:${nodeId}`,
    {
      // 副作用：文件引用计数
      redo: () => {
        if (newHash) filePool.addRef(newHash)
        if (oldHash) filePool.removeRef(oldHash)
      },
      undo: () => {
        if (oldHash) filePool.addRef(oldHash)
        if (newHash) filePool.removeRef(newHash)
      }
    }
  )
}
```

---

### 流程 4：批量移动节点

```javascript
/**
 * 批量移动节点到新父节点
 */
function batchMoveNodes(nodeIds, newParentId) {
  historyManager.modifyWithHistory(
    `批量移动 ${nodeIds.length} 个节点`,
    draft => {
      nodeIds.forEach(nodeId => {
        // 更新 tree
        if (draft.tree.layers[nodeId]) {
          draft.tree.layers[nodeId].pid = newParentId
        }

        // 更新 preview
        if (draft.preview[nodeId]) {
          draft.preview[nodeId].pid = newParentId
        }

        // 更新 json（从旧父节点移除，添加到新父节点）
        const oldParent = findParentElement(draft.json.elements, nodeId)
        const newParent = findElementById(draft.json.elements, newParentId)

        if (oldParent && newParent) {
          const element = oldParent.elements.find(el => el.attributes.id === nodeId)
          oldParent.elements = oldParent.elements.filter(el => el.attributes.id !== nodeId)
          newParent.elements = newParent.elements || []
          newParent.elements.push(element)
        }
      })
    },
    `batch:move:${nodeIds.join(',')}`
  )
}
```

---

### 流程 5：撤销/重做

```javascript
/**
 * 撤销操作（完整流程）
 */
function performUndo() {
  // 1. 强制提交待处理的操作
  historyManager.forceFlush()

  // 2. 检查是否可以撤销
  if (!historyManager.canUndo()) {
    console.warn('[Undo] No operations to undo')
    return
  }

  // 3. 执行撤销
  historyManager.undo(1)

  // 4. UI 会自动更新（通过 Patch 分发）

  // 5. 更新历史面板（可选）
  updateHistoryPanel()
}

/**
 * 重做操作（完整流程）
 */
function performRedo() {
  if (!historyManager.canRedo()) {
    console.warn('[Redo] No operations to redo')
    return
  }

  historyManager.redo(1)
  updateHistoryPanel()
}

// 绑定快捷键
document.addEventListener('keydown', (e) => {
  const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0
  const modifier = isMac ? e.metaKey : e.ctrlKey

  if (modifier && e.key === 'z' && !e.shiftKey) {
    e.preventDefault()
    performUndo()
  }

  if (modifier && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
    e.preventDefault()
    performRedo()
  }
})
```

---

### 流程 6：保存前的强制刷新

```javascript
/**
 * 保存锁屏主题（强制刷新历史）
 */
async function saveLockscreen() {
  // 1. 强制提交所有待处理的操作
  historyManager.forceFlush()

  // 2. 获取最终状态
  const finalState = runtimeManager.getState()

  // 3. 保存到后端
  const response = await api.saveLockscreen({
    lockscreenId,
    data: finalState
  })

  if (response.code === 0) {
    console.log('[Save] Lockscreen saved successfully')
  } else {
    console.error('[Save] Failed:', response.message)
  }
}
```

---

## 🛡️ 12. 降级与容错策略

### 核心设计原则

**分层容错：**

1. **数据层容错**：补丁应用失败时立即回滚
2. **UI 层容错**：UI 同步失败时从 runtimeState 重建
3. **副作用容错**：文件操作失败时提供降级方案
4. **系统级容错**：Immer 失效时切换快照模式

---

### 降级方案矩阵

| 故障类型         | 检测方式        | 降级方案     | 恢复策略           |
| ---------------- | --------------- | ------------ | ------------------ |
| **Immer 失效**   | try-catch       | 切换快照模式 | 用户操作后自动重试 |
| **补丁应用失败** | 应用返回 false  | inverse 回滚 | 提示用户           |
| **快照损坏**     | JSON.parse 失败 | 跳过快照     | 使用更早快照       |
| **副作用失败**   | IO 错误         | 跳过副作用   | 用户手动修复       |
| **UI 同步失败**  | 捕获异常        | 重建 UI      | 自动恢复           |
| **内存不足**     | 历史栈超限      | LRU 裁剪     | 自动清理           |

---

### 具体实现

#### 12.1 Immer 失效降级（切换快照模式）

```javascript
class RuntimeStateManager {
  constructor(initial) {
    this.state = initial
    this.immerEnabled = true // Immer 可用标志
    this.fallbackMode = false // 降级模式标志
  }

  /**
   * 修改状态（支持降级）
   */
  modify(updater) {
    if (!this.immerEnabled || this.fallbackMode) {
      // 降级：使用快照模式
      return this.modifyWithSnapshot(updater)
    }

    try {
      // 正常：使用 Immer
      const [nextState, patches, inversePatches] = produceWithPatches(
        this.state,
        updater
      )
      this.state = nextState
      return { patches, inversePatches }
    } catch (error) {
      console.error('[Immer Error]', error)
      // 检测到 Immer 失败，切换到快照模式
      this.fallbackMode = true
      return this.modifyWithSnapshot(updater)
    }
  }

  /**
   * 快照模式（降级方案）
   */
  modifyWithSnapshot(updater) {
    // 1. 备份当前状态
    const before = JSON.parse(JSON.stringify(this.state))

    // 2. 直接修改状态（不使用 Immer）
    const mutableState = JSON.parse(JSON.stringify(this.state))
    updater(mutableState)
    this.state = mutableState

    // 3. 生成快照式补丁
    return {
      patches: [{ op: 'replace', path: [], value: this.state }],
      inversePatches: [{ op: 'replace', path: [], value: before }]
    }
  }
}
```

**触发场景：**
- Immer 库加载失败
- Proxy 不可用（IE 11 等）
- 复杂对象导致 Immer 崩溃

---

#### 12.2 补丁应用失败回滚

```javascript
class HistoryManager {
  /**
   * 撤销（带容错）
   */
  undo(steps = 1) {
    const rollbackStack = [] // 回滚栈

    for (let i = 0; i < steps && this.canUndo(); i++) {
      const group = this.undoStack.pop()
      if (!group) break

      try {
        // 1. 备份当前状态（用于回滚）
        const backup = this.runtimeManager.clone()

        // 2. 应用 inverse patches
        this.runtimeManager.applyPatches(group.inversePatches)

        // 3. 应用到 UI
        applyPatchesToStores(group.inversePatches)

        // 4. 撤销副作用
        if (group.sideEffects?.undo) {
          group.sideEffects.undo()
        }

        // 5. 移动到 redo 栈
        this.redoStack.push(group)

        console.log(`[Undo] ${group.description}`)
      } catch (error) {
        console.error('[Undo Failed]', error, group)

        // 回滚：恢复到撤销前的状态
        if (backup) {
          this.runtimeManager.setState(backup)
          rebuildAllStoresFromRuntime()
        }

        // 将失败的操作放回 undo 栈
        this.undoStack.push(group)

        // 提示用户
        alert(`撤销失败：${error.message}。状态已回滚。`)
        break
      }
    }
  }

  /**
   * 重做（带容错）
   */
  redo(steps = 1) {
    for (let i = 0; i < steps && this.canRedo(); i++) {
      const group = this.redoStack.pop()
      if (!group) break

      try {
        const backup = this.runtimeManager.clone()

        this.runtimeManager.applyPatches(group.patches)
        applyPatchesToStores(group.patches)

        if (group.sideEffects?.redo) {
          group.sideEffects.redo()
        }

        this.undoStack.push(group)

        console.log(`[Redo] ${group.description}`)
      } catch (error) {
        console.error('[Redo Failed]', error, group)

        if (backup) {
          this.runtimeManager.setState(backup)
          rebuildAllStoresFromRuntime()
        }

        this.redoStack.push(group)
        alert(`重做失败：${error.message}。状态已回滚。`)
        break
      }
    }
  }
}
```

---

#### 12.3 快照损坏处理

```javascript
/**
 * 保存快照（带容错）
 */
saveSnapshotIfNeeded() {
  const currentIndex = this.undoStack.length

  if (currentIndex % this.snapshotInterval === 0 && currentIndex > 0) {
    try {
      const state = this.runtimeManager.clone()

      // 验证快照完整性
      if (!this.validateSnapshot(state)) {
        console.error('[Snapshot] Invalid snapshot, skipping')
        return
      }

      this.snapshots.set(currentIndex, {
        state: state,
        timestamp: Date.now(),
        checksum: this.computeChecksum(state) // 可选：计算校验和
      })

      console.log(`[Snapshot] Saved at index ${currentIndex}`)
    } catch (error) {
      console.error('[Snapshot] Failed to save:', error)
    }
  }
}

/**
 * 验证快照完整性
 */
validateSnapshot(snapshot) {
  if (!snapshot) return false
  if (!snapshot.tree || !snapshot.preview || !snapshot.json) return false
  return true
}

/**
 * 使用快照恢复（带容错）
 */
restoreFromSnapshot(snapshotIndex) {
  try {
    const snapshot = this.snapshots.get(snapshotIndex)

    if (!snapshot) {
      console.error('[Snapshot] Snapshot not found:', snapshotIndex)
      return false
    }

    // 验证快照
    if (!this.validateSnapshot(snapshot.state)) {
      console.error('[Snapshot] Corrupted snapshot:', snapshotIndex)
      // 尝试使用更早的快照
      return this.findAndRestoreEarlierSnapshot(snapshotIndex)
    }

    // 恢复快照
    this.runtimeManager.setState(snapshot.state)
    rebuildAllStoresFromRuntime()

    console.log(`[Snapshot] Restored from index ${snapshotIndex}`)
    return true
  } catch (error) {
    console.error('[Snapshot] Restore failed:', error)
    return false
  }
}

/**
 * 查找并恢复更早的有效快照
 */
findAndRestoreEarlierSnapshot(targetIndex) {
  let nearest = null
  let minDiff = Infinity

  // 查找最近的有效快照
  this.snapshots.forEach((snapshot, index) => {
    if (index < targetIndex) {
      const diff = targetIndex - index
      if (diff < minDiff && this.validateSnapshot(snapshot.state)) {
        minDiff = diff
        nearest = { index, snapshot }
      }
    }
  })

  if (nearest) {
    console.log(`[Snapshot] Using earlier snapshot at index ${nearest.index}`)
    return this.restoreFromSnapshot(nearest.index)
  }

  console.error('[Snapshot] No valid snapshot found')
  return false
}
```

---

#### 12.4 副作用失败处理

```javascript
/**
 * 副作用执行（带重试）
 */
async executeSideEffect(sideEffect, type = 'redo') {
  const maxRetries = 3
  let retries = 0

  while (retries < maxRetries) {
    try {
      if (type === 'redo') {
        await sideEffect.redo()
      } else {
        await sideEffect.undo()
      }
      return true
    } catch (error) {
      retries++
      console.error(`[SideEffect] ${type} failed (attempt ${retries}/${maxRetries}):`, error)

      if (retries >= maxRetries) {
        // 重试失败，询问用户
        const userChoice = confirm(
          `文件操作失败：${error.message}\n\n` +
          `是否继续操作？\n` +
          `- 点击"确定"：跳过此文件操作，继续\n` +
          `- 点击"取消"：撤销整个操作`
        )

        if (userChoice) {
          // 用户选择跳过
          console.warn('[SideEffect] User chose to skip side effect')
          return true // 假装成功
        } else {
          // 用户选择撤销
          throw new Error('用户取消操作')
        }
      }

      // 等待后重试
      await new Promise(resolve => setTimeout(resolve, 100 * retries))
    }
  }

  return false
}
```

---

#### 12.5 UI 同步失败恢复

```javascript
/**
 * 应用补丁到 UI（带容错）
 */
function applyPatchesToStoresSafe(patches) {
  const failedStores = []

  patches.forEach(patch => {
    const { op, path, value } = patch
    const [root, ...rest] = path

    try {
      switch (root) {
        case 'tree':
          applyPatchToLayerTree(op, rest, value)
          break
        case 'preview':
          applyPatchToTreeStore(op, rest, value)
          break
        case 'json':
          applyPatchToFormStore(op, rest, value)
          break
        case 'vars':
          applyPatchToVars(op, rest, value)
          break
        default:
          console.warn(`Unknown patch root: ${root}`, patch)
      }
    } catch (error) {
      console.error('[Patch Apply Failed]', patch, error)
      failedStores.push(root)
    }
  })

  // 如果有 Store 失败，从 runtimeState 重建
  if (failedStores.length > 0) {
    console.warn('[UI Sync] Rebuilding failed stores:', failedStores)
    failedStores.forEach(store => rebuildStoreFromRuntime(store))
  }
}
```

---

#### 12.6 内存不足处理（LRU 裁剪）

```javascript
/**
 * 裁剪历史栈（LRU 策略）
 */
trim() {
  if (this.undoStack.length > this.max) {
    const removeCount = this.undoStack.length - this.max

    // 清理旧的 PatchGroup
    const removed = this.undoStack.splice(0, removeCount)

    // 清理副作用引用（如文件引用计数）
    removed.forEach(group => {
      if (group.sideEffects?.cleanup) {
        try {
          group.sideEffects.cleanup()
        } catch (error) {
          console.error('[Cleanup] Side effect cleanup failed:', error)
        }
      }
    })

    // 清理对应的快照
    this.snapshots.forEach((_, index) => {
      if (index < removeCount) {
        this.snapshots.delete(index)
      }
    })

    console.log(`[History] Trimmed ${removeCount} operations`)
  }
}

/**
 * 内存监控（可选）
 */
monitorMemoryUsage() {
  if (!performance.memory) return

  const used = performance.memory.usedJSHeapSize
  const limit = performance.memory.jsHeapSizeLimit

  if (used / limit > 0.9) {
    console.warn('[Memory] High memory usage, triggering aggressive trim')

    // 减少历史记录上限
    this.max = Math.floor(this.max * 0.5)
    this.trim()

    // 清理所有快照（除了最近的一个）
    const latestSnapshot = Math.max(...this.snapshots.keys())
    this.snapshots.forEach((_, index) => {
      if (index !== latestSnapshot) {
        this.snapshots.delete(index)
      }
    })
  }
}
```

---

### 一致性校验（定期检查）

```javascript
/**
 * 定期校验 runtimeState 与 UI Store 的一致性
 */
function validateConsistency() {
  const state = runtimeManager.getState()
  let inconsistencies = []

  // 1. 检查 layerTreeManager
  const layerIds = Object.keys(state.tree.layers).sort()
  const uiLayerIds = layerTreeManager.layerData.value.map(n => n.id).sort()
  const layerDiff = arrayDiff(layerIds, uiLayerIds)
  if (layerDiff.length > 0) {
    inconsistencies.push({
      store: 'layerTree',
      missing: layerDiff,
      message: `Missing nodes: ${layerDiff.join(', ')}`
    })
  }

  // 2. 检查 treeStore
  const previewIds = Object.keys(state.preview).sort()
  const canvasIds = Array.from(treeStore.nodeMap.keys()).sort()
  const previewDiff = arrayDiff(previewIds, canvasIds)
  if (previewDiff.length > 0) {
    inconsistencies.push({
      store: 'treeStore',
      missing: previewDiff,
      message: `Missing nodes: ${previewDiff.join(', ')}`
    })
  }

  // 3. 检查 json 元素数量
  const jsonElementCount = countElements(state.json.elements)
  const layerCount = Object.keys(state.tree.layers).length
  if (Math.abs(jsonElementCount - layerCount) > 0) {
    inconsistencies.push({
      store: 'json',
      message: `Element count mismatch: json=${jsonElementCount}, tree=${layerCount}`
    })
  }

  // 如果发现不一致，重建 UI
  if (inconsistencies.length > 0) {
    console.error('[Consistency Check Failed]', inconsistencies)

    // 询问用户是否重建
    const shouldRebuild = confirm(
      '检测到数据不一致，是否重建界面？\n\n' +
      inconsistencies.map(i => `- ${i.store}: ${i.message}`).join('\n')
    )

    if (shouldRebuild) {
      rebuildAllStoresFromRuntime()
      alert('界面已重建，请检查数据是否正常')
    }
  } else {
    console.log('[Consistency Check] ✅ All stores in sync')
  }
}

// 每 5 分钟执行一次
setInterval(validateConsistency, 5 * 60 * 1000)
```

---

### 容错验收标准

| 场景             | 预期行为         | 验收标准          |
| ---------------- | ---------------- | ----------------- |
| **Immer 失效**   | 自动切换快照模式 | ✅ 操作继续可用   |
| **补丁应用失败** | inverse 回滚     | ✅ 状态已回滚     |
| **快照损坏**     | 使用更早快照     | ✅ 数据不丢失     |
| **副作用失败**   | 提示用户选择     | ✅ 不阻断主流程   |
| **UI 同步失败**  | 自动重建 UI      | ✅ 界面恢复正常   |
| **连续失败**     | 从快照恢复       | ✅ 数据不丢失     |

---

## ⚠️ 13. 错误处理与边界情况

### 常见错误场景

#### 1. 循环引用

```javascript
// 问题：JSON.stringify 无法处理循环引用
const state = { a: {} }
state.a.parent = state // 循环引用

// 解决方案：使用自定义序列化
function cloneWithoutCircular(obj, seen = new WeakSet()) {
  if (obj === null || typeof obj !== 'object') return obj
  if (seen.has(obj)) return undefined // 跳过循环引用

  seen.add(obj)

  if (Array.isArray(obj)) {
    return obj.map(item => cloneWithoutCircular(item, seen))
  }

  const cloned = {}
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = cloneWithoutCircular(obj[key], seen)
    }
  }

  return cloned
}
```

---

#### 2. 大对象性能问题

```javascript
// 问题：5MB JSON 的 clone 耗时过长
const largeState = { /* 5MB data */ }
const cloned = JSON.parse(JSON.stringify(largeState)) // 200ms+

// 解决方案1：使用结构化克隆（更快）
const cloned = structuredClone(largeState) // 50ms

// 解决方案2：使用流式克隆（适合超大对象）
async function cloneLargeObject(obj) {
  const blob = new Blob([JSON.stringify(obj)])
  const text = await blob.text()
  return JSON.parse(text)
}

// 解决方案3：懒克隆（只克隆需要的部分）
function lazyClone(obj, paths) {
  const result = {}
  paths.forEach(path => {
    setByPath(result, path, getByPath(obj, path))
  })
  return result
}
```

---

#### 3. 并发修改冲突

```javascript
// 问题：用户快速连续操作，RAF 回调执行时状态已变化
let pendingUpdate = null

function modifyWithHistory(description, updater) {
  // 记录操作，但不立即执行
  pendingUpdate = { description, updater }

  requestAnimationFrame(() => {
    if (!pendingUpdate) return

    // 执行时检查状态是否被其他操作修改
    const currentState = runtimeManager.getState()
    const stateHash = computeHash(currentState)

    if (stateHash !== lastKnownHash) {
      console.warn('[Concurrent Modification] State changed, re-executing')
    }

    const { patches, inversePatches } = runtimeManager.modify(pendingUpdate.updater)
    // ...

    pendingUpdate = null
  })
}
```

---

#### 4. 跨页面/窗口同步

```javascript
// 问题：用户打开多个编辑器窗口，如何同步状态？

// 方案1：使用 BroadcastChannel
const channel = new BroadcastChannel('lockscreen-sync')

channel.onmessage = (event) => {
  if (event.data.type === 'state-update') {
    // 接收到其他窗口的状态更新
    runtimeManager.setState(event.data.state)
    rebuildAllStoresFromRuntime()
  }
}

// 发送状态更新
function broadcastStateUpdate() {
  channel.postMessage({
    type: 'state-update',
    state: runtimeManager.getState(),
    timestamp: Date.now()
  })
}

// 方案2：使用 localStorage 监听
window.addEventListener('storage', (e) => {
  if (e.key === 'lockscreen-state') {
    const newState = JSON.parse(e.newValue)
    runtimeManager.setState(newState)
    rebuildAllStoresFromRuntime()
  }
})
```

---

#### 5. Undo 按钮连续点击

```javascript
// 问题：用户快速连续点击 Undo，可能导致状态错乱

// 方案1：节流（推荐）
const throttledUndo = throttle(() => {
  historyManager.undo()
}, 100)

// 方案2：禁用按钮（等待操作完成）
async function performUndoWithLock() {
  if (this.isUndoing) return

  this.isUndoing = true
  this.undoButton.disabled = true

  try {
    await historyManager.undo()
  } finally {
    this.isUndoing = false
    this.undoButton.disabled = !historyManager.canUndo()
  }
}

// 方案3：批量撤销（150ms 内的点击合并）
let undoQueue = 0
let undoTimer = null

function queueUndo() {
  undoQueue++

  clearTimeout(undoTimer)
  undoTimer = setTimeout(() => {
    historyManager.undo(undoQueue)
    undoQueue = 0
  }, 150)
}
```

---

#### 6. 文件操作失败

```javascript
// 问题：文件上传失败，但状态已修改

async function addImageComponentSafe(imagePath) {
  let imageHash = null
  let nodeId = null

  try {
    // 1. 先上传文件
    imageHash = await filePool.addFile(imagePath, ...)

    // 2. 文件上传成功后才修改状态
    nodeId = genId()
    historyManager.modifyWithHistory(
      '添加图片组件',
      draft => {
        // ...
      },
      `add:${nodeId}`,
      {
        redo: () => { filePool.addRef(imageHash) },
        undo: () => { filePool.removeRef(imageHash) }
      }
    )

    return { success: true, nodeId }
  } catch (error) {
    console.error('[Add Image] Failed:', error)

    // 清理已上传的文件
    if (imageHash) {
      try {
        filePool.removeFile(imageHash)
      } catch (cleanupError) {
        console.error('[Cleanup] Failed to remove file:', cleanupError)
      }
    }

    return { success: false, error: error.message }
  }
}
```

---

### 边界情况处理

#### 1. 空历史栈

```javascript
function undo() {
  if (this.undoStack.length === 0) {
    console.warn('[Undo] Nothing to undo')
    // 可选：播放提示音或震动
    navigator.vibrate && navigator.vibrate(50)
    return
  }

  // ...
}
```

---

#### 2. 超大历史栈

```javascript
// 历史记录超过 1000 条时的优化策略
if (this.undoStack.length > 1000) {
  // 策略1：自动合并相邻的相似操作
  this.undoStack = this.mergeAdjacentOperations(this.undoStack)

  // 策略2：只保留关键操作（如添加/删除节点）
  const importantOps = this.undoStack.filter(op =>
    op.description.includes('添加') ||
    op.description.includes('删除')
  )

  // 策略3：提示用户清理历史
  if (this.undoStack.length > 2000) {
    const shouldClear = confirm('历史记录过多，是否清理？')
    if (shouldClear) {
      this.undoStack = this.undoStack.slice(-100) // 只保留最近 100 条
      this.snapshots.clear()
    }
  }
}
```

---

#### 3. Patch 路径不存在

```javascript
function applyPatchSafe(patch) {
  const { op, path, value } = patch

  // 检查路径是否存在
  if (op === 'replace' || op === 'remove') {
    if (!pathExists(this.state, path)) {
      console.warn('[Patch] Path does not exist:', path)
      return false
    }
  }

  // 应用 Patch
  try {
    this.state = applyPatches(this.state, [patch])
    return true
  } catch (error) {
    console.error('[Patch] Apply failed:', error)
    return false
  }
}

function pathExists(obj, path) {
  let current = obj
  for (const key of path) {
    if (current == null || !(key in current)) {
      return false
    }
    current = current[key]
  }
  return true
}
```

---

## 📐 14. 技术约束

### 环境要求

| 项目           | 要求                          | 说明                      |
| -------------- | ----------------------------- | ------------------------- |
| **Node.js**    | >= 14.0.0                     | 支持 ES2020 语法          |
| **浏览器**     | Chrome/Edge >= 90             | 需要 Proxy 支持           |
| **Vue**        | Vue 2.6+ 或 Vue 3.0+          | 响应式系统                |
| **Electron**   | >= 13.0.0                     | 文件 IO 操作              |
| **Immer.js**   | >= 9.0.0                      | produceWithPatches API    |

---

### 性能约束

| 指标                 | 限制值             | 超出时的处理       |
| -------------------- | ------------------ | ------------------ |
| **单个 JSON 大小**   | < 10MB             | 警告用户           |
| **历史记录数量**     | <= 100 条          | LRU 自动裁剪       |
| **快照数量**         | <= 10 个           | 自动删除最旧快照   |
| **单步撤销/重做**    | < 50ms (P95)       | 使用快照加速       |
| **Patch 应用时间**   | < 10ms (P95)       | 批量优化           |

---

### 数据约束

| 约束项             | 限制                             | 原因                   |
| ------------------ | -------------------------------- | ---------------------- |
| **节点数量**       | < 500 个                         | UI 渲染性能            |
| **嵌套深度**       | < 10 层                          | Patch 路径复杂度       |
| **文件大小**       | 单个文件 < 5MB                   | 内存占用               |
| **文件总数**       | < 100 个                         | 文件池管理复杂度       |
| **变量数量**       | < 50 个                          | 表达式解析性能         |

---

### 功能范围限制

**不支持的功能：**

1. ❌ **协同编辑**：多人同时编辑同一个锁屏
2. ❌ **云端历史同步**：历史记录上传到服务器
3. ❌ **跨设备同步**：在不同设备间同步编辑状态
4. ❌ **操作回放**：按时间线回放所有操作
5. ❌ **分支历史**：像 Git 一样支持分支和合并

**部分支持的功能：**

1. ⚠️ **批量操作**：支持，但历史记录会合并
2. ⚠️ **大步撤销**：支持，但超过 50 步可能较慢
3. ⚠️ **崩溃恢复**：支持 Autosave，但需要用户手动确认

---

### 已知问题

| 问题                     | 影响范围       | 临时方案               | 计划修复 |
| ------------------------ | -------------- | ---------------------- | -------- |
| **IE 11 不支持**         | 无法使用 Immer | 使用快照模式降级       | ❌ 不计划 |
| **大文件上传慢**         | 用户体验       | 显示进度条             | ✅ Q1     |
| **历史面板性能**         | 历史 > 500 条  | 虚拟滚动               | ✅ Q2     |
| **文件池 GC 延迟**       | 磁盘占用       | 手动触发 GC            | ✅ Q1     |
| **跨窗口状态同步**       | 多窗口编辑     | 提示用户只打开一个窗口 | ⚠️ Q3     |

---

## 🔨 15. 集成与改造任务拆解

### 实施路线图

#### 阶段 1：基础设施搭建（2 周）

**任务清单：**

1. ✅ 安装依赖
   ```bash
   npm install immer
   ```

2. ✅ 创建核心类
   - [ ] `RuntimeStateManager` (src/business/lockscreen-v2/runtime-state-manager.js)
   - [ ] `HistoryManager` (src/business/lockscreen-v2/history-manager.js)
   - [ ] `FilePoolManager` (src/electron/lockscreenNew/file-pool-manager.js)

3. ✅ 定义接口和类型
   - [ ] `PatchGroup` interface
   - [ ] `SideEffects` interface
   - [ ] Patch 分发器接口

---

#### 阶段 2：Store 能力补齐（1 周）

**layerTreeManager 改造：**

```javascript
// 需要新增的方法
class LayerTreeManager {
  // ✅ 已有
  add(node) { /* ... */ }
  delete(nodeId) { /* ... */ }

  // 🆕 需要新增
  update(nodeId, changes) {
    const node = this.layerData.value.find(n => n.id === nodeId)
    if (node) {
      Object.assign(node, changes)
      this.layerData.value = [...this.layerData.value]
    }
  }

  move(nodeId, newPid) {
    const node = this.layerData.value.find(n => n.id === nodeId)
    if (node) {
      node.pid = newPid
      this.layerData.value = [...this.layerData.value]
    }
  }

  batchUpdate(fn) {
    this._batchMode = true
    fn()
    this._batchMode = false
    this.layerData.value = [...this.layerData.value]
  }
}
```

**treeStore 确认：**
- ✅ `add()` - 已有
- ✅ `update()` - 已有
- ✅ `remove()` - 已有
- ✅ `move()` - 已有

---

#### 阶段 3：Patch 分发器实现（1 周）

创建 `src/business/lockscreen-v2/patch-dispatcher.js`：

```javascript
export function applyPatchesToStores(patches) {
  patches.forEach(patch => {
    const { op, path, value } = patch
    const [root, ...rest] = path

    switch (root) {
      case 'tree':
        applyPatchToLayerTree(op, rest, value)
        break
      case 'preview':
        applyPatchToTreeStore(op, rest, value)
        break
      case 'json':
        applyPatchToFormStore(op, rest, value)
        break
      case 'vars':
        applyPatchToVars(op, rest, value)
        break
    }
  })
}
```

---

#### 阶段 4：业务流程改造（2 周）

**改造清单：**

1. ✅ 添加组件流程
   - [ ] `addComponentFlow()` → 使用 `historyManager.modifyWithHistory()`
   - [ ] 集成 FilePool

2. ✅ 删除组件流程
   - [ ] `deleteComponentFlow()` → 递归删除子节点
   - [ ] 释放文件引用

3. ✅ 更新属性流程
   - [ ] `updatePropertyFlow()` → 批量更新
   - [ ] 表单联动

4. ✅ 移动节点流程
   - [ ] `moveNodeFlow()` → 支持拖拽

5. ✅ 替换资源流程
   - [ ] `replaceImageFlow()` → 文件引用计数

---

#### 阶段 5：UI 集成（1 周）

**快捷键绑定：**

```javascript
// src/business/lockscreen-v2/setup-shortcuts.js
export function setupShortcuts(historyManager) {
  document.addEventListener('keydown', (e) => {
    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0
    const modifier = isMac ? e.metaKey : e.ctrlKey

    if (modifier && e.key === 'z' && !e.shiftKey) {
      e.preventDefault()
      historyManager.undo()
    }

    if (modifier && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
      e.preventDefault()
      historyManager.redo()
    }
  })
}
```

**按钮状态绑定：**

```vue
<template>
  <div class="history-controls">
    <button @click="undo" :disabled="!canUndo">
      <i class="icon-undo"></i> 撤销
    </button>
    <button @click="redo" :disabled="!canRedo">
      <i class="icon-redo"></i> 重做
    </button>
  </div>
</template>

<script>
import { computed } from 'vue'
import { historyManager } from './history-manager'

export default {
  setup() {
    const historyState = computed(() => historyManager.getState())
    const canUndo = computed(() => historyState.value.canUndo)
    const canRedo = computed(() => historyState.value.canRedo)

    return {
      canUndo,
      canRedo,
      undo: () => historyManager.undo(),
      redo: () => historyManager.redo()
    }
  }
}
</script>
```

---

#### 阶段 6：测试与验收（1 周）

**测试用例：**

| 用例编号 | 测试场景             | 预期结果               | 状态 |
| -------- | -------------------- | ---------------------- | ---- |
| TC-001   | 添加组件 + 撤销      | 组件消失               | ⏳    |
| TC-002   | 删除组件 + 撤销      | 组件恢复               | ⏳    |
| TC-003   | 修改属性 + 撤销      | 属性恢复               | ⏳    |
| TC-004   | 移动节点 + 撤销      | 位置恢复               | ⏳    |
| TC-005   | 拖拽 30 次           | 历史记录 1 条          | ⏳    |
| TC-006   | 连续撤销 50 步       | < 500ms                | ⏳    |
| TC-007   | 上传图片 + 撤销      | 文件已删除             | ⏳    |
| TC-008   | 相同图片上传 3 次    | 磁盘只有 1 份          | ⏳    |
| TC-009   | Immer 失败模拟       | 自动切换快照模式       | ⏳    |
| TC-010   | 刷新页面             | Autosave 恢复          | ⏳    |

---

### 改造风险评估

| 风险                 | 概率 | 影响 | 缓解措施                       |
| -------------------- | ---- | ---- | ------------------------------ |
| **Store 接口不兼容** | 中   | 高   | 先做接口适配层，逐步迁移       |
| **性能回归**         | 低   | 中   | 性能监控 + 基准测试            |
| **文件泄漏**         | 中   | 高   | FilePool 单元测试 + 延迟 GC    |
| **UI 不一致**        | 中   | 中   | 定期一致性校验 + 重建机制      |
| **用户数据丢失**     | 低   | 高   | Autosave + 快照 + 降级方案     |

---

## ✅ 16. 验收标准

### 功能验收

| 功能项               | 验收标准                                         | 测试方法                     |
| -------------------- | ------------------------------------------------ | ---------------------------- |
| **基础撤销/重做**    | Ctrl/Cmd+Z/Y 可用，支持所有操作类型              | 手动测试所有操作             |
| **历史深度**         | ≥ 100 步                                         | 执行 100 次操作后检查        |
| **文件管理**         | 文件自动去重，引用计数正确，GC 不误删            | 上传相同文件 3 次，检查磁盘  |
| **高频操作合并**     | 拖拽/滑块等操作自动合并为 1 条历史记录           | 拖拽 30 次，检查历史面板     |
| **崩溃恢复**         | 刷新页面后可选恢复未保存状态                     | 修改后强制刷新，检查恢复提示 |

---

### 性能验收

| 指标                 | 目标值             | 测试方法                       |
| -------------------- | ------------------ | ------------------------------ |
| **单步撤销/重做**    | < 50ms (P95)       | Performance API 测量 100 次    |
| **内存占用**         | < 100MB (100 步)   | Chrome DevTools Memory Profile |
| **合并率**           | > 90%              | 拖拽 30 次，检查历史记录数     |
| **文件去重率**       | > 60%              | 实际文件数 / 理论文件数        |
| **UI 渲染时间**      | < 16ms (60fps)     | Chrome DevTools Performance    |

---

### 稳定性验收

| 场景                 | 验收标准                                         |
| -------------------- | ------------------------------------------------ |
| **Immer 失效**       | 自动切换快照模式，操作继续可用                   |
| **补丁应用失败**     | 自动回滚，提示用户                               |
| **快照损坏**         | 使用更早快照，数据不丢失                         |
| **副作用失败**       | 提示用户选择（跳过/撤销），不阻断主流程          |
| **UI 同步失败**      | 自动从 runtimeState 重建，界面恢复正常           |
| **内存不足**         | LRU 自动裁剪，不崩溃                             |
| **连续 100 次撤销**  | < 5s，无卡顿                                     |

---

### 一致性验收

| 检查项               | 验收标准                                         |
| -------------------- | ------------------------------------------------ |
| **runtimeState 一致性** | runtimeState 与 UI Stores 数据一致            |
| **文件引用计数**     | 引用计数 = 实际使用次数                          |
| **历史栈完整性**     | 每个 PatchGroup 的 inversePatches 可还原        |
| **快照有效性**       | 所有快照可正常恢复                               |

---

## 🚀 17. 后续扩展方向

### 可选增强功能

#### 1. 历史面板（操作记录可视化）

```vue
<template>
  <div class="history-panel">
    <div v-for="(group, index) in history" :key="index" class="history-item">
      <span class="description">{{ group.description }}</span>
      <span class="timestamp">{{ formatTime(group.timestamp) }}</span>
      <button @click="jumpTo(index)">跳转</button>
    </div>
  </div>
</template>
```

**功能：**
- 显示所有历史记录
- 点击跳转到任意历史状态
- 搜索/过滤历史记录

---

#### 2. 操作分组/折叠

```javascript
// 将连续的相似操作分组显示
const grouped = groupHistoryByType(historyManager.undoStack)
// 结果：
// - 拖拽节点 (30 次) ← 折叠
// - 修改颜色
// - 添加组件
```

---

#### 3. 快照预览

```javascript
// 在历史面板中预览快照
function previewSnapshot(snapshotIndex) {
  const snapshot = historyManager.snapshots.get(snapshotIndex)

  // 在预览窗口渲染快照
  renderPreview(snapshot.state)
}
```

---

#### 4. Autosave 增强

```javascript
// 定期保存到 IndexedDB
setInterval(() => {
  const state = runtimeManager.getState()
  const history = historyManager.serialize()

  indexedDB.put('autosave', {
    state,
    history,
    timestamp: Date.now()
  })
}, 30 * 1000) // 每 30 秒

// 启动时恢复
const autosave = await indexedDB.get('autosave')
if (autosave && confirm('检测到未保存的更改，是否恢复？')) {
  runtimeManager.setState(autosave.state)
  historyManager.deserialize(autosave.history)
}
```

---

#### 5. 性能分析面板

```javascript
// 显示性能指标
const stats = {
  undoP95: perfMonitor.getPercentile(95),
  avgPatchSize: calculateAvgPatchSize(),
  mergeRate: calculateMergeRate(),
  memoryUsage: performance.memory.usedJSHeapSize
}
```

---

#### 6. 协同编辑（长期）

**架构升级：**
- 使用 CRDT (Conflict-free Replicated Data Types)
- WebSocket 实时同步
- Operational Transformation (OT)

**挑战：**
- 并发冲突解决
- 网络延迟处理
- 历史记录合并

---

### Vue 3 迁移路径

**当前架构的优势：**
- ✅ RuntimeStateManager 与框架无关
- ✅ HistoryManager 与框架无关
- ✅ 只需要重构 Patch 分发器

**Vue 3 迁移步骤：**

1. **第1步：重构 UI Stores**
   ```javascript
   // Vue 2 → Vue 3
   import { ref, reactive } from 'vue'

   // 使用 reactive 替代 Vuex
   const layerTreeState = reactive({
     layers: []
   })
   ```

2. **第2步：简化 Patch 分发**
   ```javascript
   // Vue 3 可以直接修改 reactive 对象
   function applyPatchesToStores(patches) {
     patches.forEach(patch => {
       const { op, path, value } = patch

       // 直接应用到 reactive 对象
       setByPath(layerTreeState, path, value)
     })
   }
   ```

3. **第3步：理想架构**
   ```javascript
   // 未来：runtimeState 直接使用 Vue 3 reactive
   import { reactive } from 'vue'

   const runtimeState = reactive({
     tree: {},
     preview: {},
     json: {}
   })

   // UI 直接渲染 runtimeState
   <component :data="runtimeState.preview[nodeId]" />
   ```

---

## 📦 第18章. 文件池管理（FilePool）

### 18.1 核心设计：内容寻址 + 引用计数

**当前问题：**

在没有文件池管理的情况下，锁屏编辑器存在以下问题：

- ❌ 文件按名称存储，多个组件使用同一图片会重复复制
- ❌ 无引用计数，删除组件时不知道是否该删除文件
- ❌ undo/redo 无法管理文件生命周期，导致文件泄漏或误删

**FilePool 方案：**

- ✅ 按文件 hash 存储（内容寻址），自动去重
- ✅ 引用计数管理，安全删除文件
- ✅ 与 undo/redo 集成，副作用对称处理
- ✅ 延迟 GC，避免误删

---

### 18.2 数据结构设计

```javascript
/**
 * 文件池管理器
 */
class FilePoolManager {
  constructor(lockscreenID) {
    this.lockscreenID = lockscreenID
    this.poolDir = path.resolve(dir_lockscreens, lockscreenID, '.file-pool')

    // 引用计数：hash → count
    this.refCount = new Map()

    // 元数据：hash → { androidPath, width, height, size, mimeType }
    this.metadata = new Map()

    // GC 标记：hash → markTime（引用计数归零的时间）
    this.gcMarks = new Map()

    // 确保目录存在
    utils.mkdirsSync(this.poolDir)

    // 加载持久化数据
    this.loadMetadata()
  }
}
```

**设计要点：**

1. **内容寻址（Content-Addressed Storage）**
   - 使用 SHA256 hash 作为文件名
   - 相同内容的文件只存储一份
   - 磁盘占用显著减少

2. **引用计数（Reference Counting）**
   - 跟踪每个文件被引用的次数
   - 只有引用计数归零才标记为可删除
   - 避免误删正在使用的文件

3. **延迟垃圾回收（Delayed GC）**
   - 引用计数归零后不立即删除
   - 保留 1 小时，避免频繁 undo/redo 导致文件反复删除/恢复
   - 定时 GC 自动清理过期文件

4. **元数据持久化**
   - 保存引用计数、文件元数据到 `metadata.json`
   - 启动时恢复状态
   - 避免文件丢失

---

### 18.3 核心方法实现

#### 18.3.1 添加文件（自动去重）

```javascript
/**
 * 添加文件到池中
 * @param {string} filePath - 源文件路径
 * @param {string} androidPath - Android 路径（如 'drawable/icon.png'）
 * @returns {Promise<string>} 文件 hash
 */
async addFile(filePath, androidPath) {
  // 1. 计算文件 hash
  const hash = await this.computeHash(filePath)

  // 2. 检查是否已存在
  if (!this.fileExists(hash)) {
    // 3. 文件不存在，复制到池中
    const poolPath = path.resolve(this.poolDir, hash)
    await utils.copy(filePath, poolPath)

    // 4. 保存元数据
    const stats = fs.statSync(filePath)
    let width, height

    if (filePath.match(/\.(png|jpg|jpeg|webp)$/i)) {
      const imgSize = utils.getImgSize(filePath)
      width = imgSize.width
      height = imgSize.height
    }

    this.metadata.set(hash, {
      androidPath,
      width,
      height,
      size: stats.size,
      mimeType: this.getMimeType(filePath),
      addedAt: Date.now()
    })

    // 持久化元数据
    this.saveMetadata()
  }

  // 5. 增加引用计数
  this.addRef(hash)

  // 6. 如果之前被标记为 GC，取消标记
  this.gcMarks.delete(hash)

  return hash
}

/**
 * 增加引用计数
 */
addRef(hash) {
  const count = this.refCount.get(hash) || 0
  this.refCount.set(hash, count + 1)
  console.log(`[FilePool] addRef ${hash}: ${count} → ${count + 1}`)
}

/**
 * 计算文件 SHA256 hash
 */
async computeHash(filePath) {
  const crypto = require('crypto')
  const buffer = fs.readFileSync(filePath)
  return crypto.createHash('sha256').update(buffer).digest('hex')
}

/**
 * 检查文件是否存在
 */
fileExists(hash) {
  const poolPath = path.resolve(this.poolDir, hash)
  return fs.existsSync(poolPath)
}

/**
 * 获取 MIME 类型
 */
getMimeType(filePath) {
  const ext = path.extname(filePath).toLowerCase()
  const mimeTypes = {
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.webp': 'image/webp',
    '.gif': 'image/gif',
    '.mp4': 'video/mp4',
    '.webm': 'video/webm'
  }
  return mimeTypes[ext] || 'application/octet-stream'
}
```

**工作流程：**

1. 计算文件 SHA256 hash
2. 检查池中是否已存在该 hash 的文件
3. 如果不存在，复制文件到池中（使用 hash 作为文件名）
4. 保存文件元数据（尺寸、MIME 类型等）
5. 增加引用计数
6. 如果文件之前被标记为 GC，取消标记
7. 返回 hash 供 JSON 数据使用

---

#### 18.3.2 移除引用（延迟 GC）

```javascript
/**
 * 移除文件引用（引用计数 -1）
 * @param {string} hash - 文件 hash
 */
removeRef(hash) {
  const count = this.refCount.get(hash) || 0

  if (count <= 1) {
    // 引用计数归零，标记为可删除（延迟 GC）
    this.refCount.delete(hash)
    this.gcMarks.set(hash, Date.now())
    console.log(`[FilePool] removeRef ${hash}: ${count} → 0 (marked for GC)`)
  } else {
    this.refCount.set(hash, count - 1)
    console.log(`[FilePool] removeRef ${hash}: ${count} → ${count - 1}`)
  }
}
```

**设计要点：**

- 引用计数 > 1：直接减 1，文件继续保留
- 引用计数 = 1：归零后标记为 GC，记录当前时间
- 不立即删除文件，避免 undo 操作导致文件丢失

---

#### 18.3.3 垃圾回收（延迟删除）

```javascript
/**
 * 垃圾回收（删除引用计数为 0 且超过保留期的文件）
 * @param {number} retentionTime - 保留时间（毫秒），默认 1 小时
 */
async gc(retentionTime = 60 * 60 * 1000) {
  const now = Date.now()
  const toDelete = []

  // 查找需要删除的文件
  this.gcMarks.forEach((markTime, hash) => {
    if (now - markTime > retentionTime) {
      toDelete.push(hash)
    }
  })

  // 删除文件
  for (const hash of toDelete) {
    try {
      const poolPath = path.resolve(this.poolDir, hash)
      if (fs.existsSync(poolPath)) {
        fs.unlinkSync(poolPath)
        console.log(`[FilePool] GC deleted: ${hash}`)
      }

      // 清理元数据
      this.metadata.delete(hash)
      this.gcMarks.delete(hash)
    } catch (error) {
      console.error(`[FilePool] GC failed for ${hash}:`, error)
    }
  }

  // 持久化元数据
  if (toDelete.length > 0) {
    this.saveMetadata()
  }

  console.log(`[FilePool] GC completed: ${toDelete.length} files deleted`)
  return toDelete.length
}

/**
 * 启动定时 GC
 * @param {number} interval - GC 间隔（毫秒），默认 5 分钟
 */
startAutoGC(interval = 5 * 60 * 1000) {
  this.gcTimer = setInterval(() => {
    this.gc()
  }, interval)
}

/**
 * 停止定时 GC
 */
stopAutoGC() {
  if (this.gcTimer) {
    clearInterval(this.gcTimer)
    this.gcTimer = null
  }
}
```

**GC 策略：**

- **触发时机：**定时 GC（默认每 5 分钟）
- **删除条件：**引用计数为 0 且超过保留期（默认 1 小时）
- **容错处理：**删除失败不影响其他文件
- **性能优化：**批量删除，一次持久化

---

#### 18.3.4 获取文件路径（用于渲染）

```javascript
/**
 * 获取文件路径（用于预览）
 * @param {string} hash - 文件 hash
 * @returns {string} 文件绝对路径
 */
getFilePath(hash) {
  return `file://${path.resolve(this.poolDir, hash)}`
}

/**
 * 导出文件到目标位置（用于导出锁屏）
 * @param {string} hash - 文件 hash
 * @param {string} targetPath - 目标路径
 */
async exportFile(hash, targetPath) {
  const poolPath = path.resolve(this.poolDir, hash)
  if (fs.existsSync(poolPath)) {
    await utils.copy(poolPath, targetPath)
  } else {
    throw new Error(`File not found: ${hash}`)
  }
}
```

**使用场景：**

1. **预览渲染：**`getFilePath()` 返回 `file://` 协议路径，供 Konva 或 `<img>` 标签使用
2. **导出锁屏：**`exportFile()` 将池中文件复制到导出目录，恢复原始文件名

---

#### 18.3.5 持久化元数据

```javascript
/**
 * 保存元数据到磁盘
 */
saveMetadata() {
  const metaPath = path.resolve(this.poolDir, 'metadata.json')
  const data = {
    refCount: Array.from(this.refCount.entries()),
    metadata: Array.from(this.metadata.entries()),
    gcMarks: Array.from(this.gcMarks.entries())
  }

  fs.writeFileSync(metaPath, JSON.stringify(data, null, 2))
}

/**
 * 从磁盘加载元数据
 */
loadMetadata() {
  const metaPath = path.resolve(this.poolDir, 'metadata.json')

  if (fs.existsSync(metaPath)) {
    try {
      const data = JSON.parse(fs.readFileSync(metaPath, 'utf-8'))
      this.refCount = new Map(data.refCount || [])
      this.metadata = new Map(data.metadata || [])
      this.gcMarks = new Map(data.gcMarks || [])
      console.log(`[FilePool] Loaded metadata: ${this.refCount.size} files`)
    } catch (error) {
      console.error('[FilePool] Failed to load metadata:', error)
    }
  }
}
```

**持久化策略：**

- **保存时机：**添加/删除文件、GC 完成后
- **数据格式：**JSON，Map 转换为数组
- **启动恢复：**从 `metadata.json` 加载引用计数和元数据

---

### 18.4 与 undo/redo 集成

FilePool 的引用计数必须与 undo/redo 系统集成，确保文件生命周期正确管理。

#### 18.4.1 添加组件（带文件）

```javascript
/**
 * 添加带图片的组件
 */
async function addComponentFlow({ name, desc, imagePath }) {
  const parentId = selectionStore.selectedNodeId.value || 'node_root'
  const newId = genId()

  // 1. 如果有图片，先添加到 FilePool
  let imageHash = null
  if (imagePath && renderTypeMap[name] === 'image') {
    imageHash = await filePool.addFile(imagePath, `drawable/${path.basename(imagePath)}`)
  }

  // 2. 使用 Immer 生成补丁
  history.modifyWithHistory(
    `add ${name}`,
    draft => {
      // 更新 tree
      draft.tree.layers[newId] = {
        id: newId,
        pid: parentId,
        type: name,
        name: desc || name
      }

      // 更新 preview
      draft.preview[newId] = {
        id: newId,
        pid: parentId,
        meta: { x: 0, y: 0, w: 120, h: 120, visible: true },
        renderType: renderTypeMap[name] || 'group'
      }

      // 更新 json
      const parentElement = findElementById(draft.json.elements, parentId)
      if (parentElement) {
        parentElement.elements = parentElement.elements || []
        parentElement.elements.push({
          name,
          attributes: {
            id: newId,
            src: imageHash
              ? {
                  hash: imageHash,
                  androidPath: `drawable/${path.basename(imagePath)}`,
                  ...filePool.metadata.get(imageHash)
                }
              : undefined,
            x: '0',
            y: '0',
            w: '120',
            h: '120'
          }
        })
      }
    },
    `add:${newId}`, // 去重 key
    {
      // ⭐ 副作用：管理文件引用计数
      redo: () => {
        if (imageHash) filePool.addRef(imageHash)
      },
      undo: () => {
        if (imageHash) filePool.removeRef(imageHash)
      }
    }
  )

  // 3. 同步 UI
  const latestPatches = history.pendingPatchGroups.get(`add:${newId}`)?.patches
  if (latestPatches) {
    applyPatchesToStores(latestPatches)
  }

  // 4. 选中新节点
  selectionStore.selectNode(newId)
}
```

**关键点：**

1. **文件先入池：**在修改 runtimeState 之前调用 `filePool.addFile()`
2. **存储 hash：**JSON 数据中存储 hash，而不是文件路径
3. **副作用对称：**redo 时 `addRef()`，undo 时 `removeRef()`

---

#### 18.4.2 删除组件（带文件）

```javascript
/**
 * 删除节点
 */
function removeNodeFlow() {
  const nodeId = selectionStore.selectedNodeId.value
  if (!nodeId) return

  // 获取节点信息（用于副作用）
  const node = runtimeManager.getState().json.elements.find(e => e.attributes?.id === nodeId)
  const imageHash = node?.attributes?.src?.hash

  history.modifyWithHistory(
    `remove ${nodeId}`,
    draft => {
      // 从 tree 中删除
      delete draft.tree.layers[nodeId]

      // 从 preview 中删除
      delete draft.preview[nodeId]

      // 从 json 中删除
      removeElementById(draft.json.elements, nodeId)
    },
    `remove:${nodeId}`,
    {
      // ⭐ 副作用：文件引用计数
      redo: () => {
        if (imageHash) filePool.removeRef(imageHash)
      },
      undo: () => {
        if (imageHash) filePool.addRef(imageHash)
      }
    }
  )

  // 同步 UI
  const latestPatches = history.pendingPatchGroups.get(`remove:${nodeId}`)?.patches
  if (latestPatches) {
    applyPatchesToStores(latestPatches)
  }

  // 清空选中
  selectionStore.deselectNode()
  currentFormStore.formItems.value = []
}
```

**关键点：**

- **提前获取 hash：**在修改 runtimeState 之前保存 `imageHash`
- **副作用对称：**redo 时 `removeRef()`（删除减引用），undo 时 `addRef()`（撤销删除加引用）

---

#### 18.4.3 替换图片

```javascript
/**
 * 替换图片
 */
async function replaceImageFlow(nodeId, newImagePath) {
  const oldNode = runtimeManager.getState().json.elements.find(e => e.attributes?.id === nodeId)
  const oldHash = oldNode?.attributes?.src?.hash

  // 添加新文件到池中
  const newHash = await filePool.addFile(newImagePath, `drawable/${path.basename(newImagePath)}`)

  history.modifyWithHistory(
    `replace image ${nodeId}`,
    draft => {
      const element = findElementById(draft.json.elements, nodeId)
      if (element && element.attributes) {
        element.attributes.src = {
          hash: newHash,
          androidPath: `drawable/${path.basename(newImagePath)}`,
          ...filePool.metadata.get(newHash)
        }
      }
    },
    `replace:${nodeId}`,
    {
      // ⭐ 副作用：新文件 +1，旧文件 -1
      redo: () => {
        filePool.addRef(newHash)
        if (oldHash) filePool.removeRef(oldHash)
      },
      undo: () => {
        if (oldHash) filePool.addRef(oldHash)
        filePool.removeRef(newHash)
      }
    }
  )

  // 同步 UI
  const latestPatches = history.pendingPatchGroups.get(`replace:${nodeId}`)?.patches
  if (latestPatches) {
    applyPatchesToStores(latestPatches)
  }
}
```

**关键点：**

- **原子操作：**新文件 +1，旧文件 -1 必须同时发生
- **副作用对称：**undo 时反向操作（旧文件 +1，新文件 -1）

---

### 18.5 文件结构对比

#### ❌ 当前方案（无 FilePool）

```
userData/lockscreens/ABC123/
  ├── manifest.xml
  ├── logo.png          (1MB)
  ├── logo_copy.png     (1MB，重复！)
  ├── logo_copy2.png    (1MB，重复！)
  └── time.png          (500KB)

问题：
- 磁盘占用：3.5MB（3 个重复的 logo）
- 文件管理：手动命名，容易冲突
- undo/redo：无法管理文件生命周期
```

#### ✅ FilePool 方案

```
userData/lockscreens/ABC123/
  ├── manifest.xml
  ├── .file-pool/
  │   ├── a3d2f1e9c4b8...hash   (1MB，logo 原文件，只存 1 份)
  │   ├── b7c4d6e8f3a1...hash   (500KB，time 原文件)
  │   └── metadata.json          (元数据 + 引用计数)

优势：
- 磁盘占用：1.5MB（节省 57%）
- 自动去重：相同文件只存 1 份
- 引用计数：安全管理文件生命周期
- undo/redo：副作用对称，文件无泄漏
```

**实际效果：**

| 场景             | 无 FilePool | 有 FilePool | 节省比例 |
| ---------------- | ----------- | ----------- | -------- |
| 3 个组件用同一图 | 3MB         | 1MB         | 66%      |
| 10 个组件用同一图 | 10MB        | 1MB         | 90%      |
| 复杂锁屏（50+组件） | ~50MB       | ~15MB       | 70%      |

---

### 18.6 性能对比

| 指标             | 无 FilePool      | 有 FilePool       | 提升           |
| ---------------- | ---------------- | ----------------- | -------------- |
| **磁盘占用**     | 高（文件重复）   | 低（自动去重）    | 节省 50-90%    |
| **内存占用**     | 中（存文件名）   | 中（存 hash）     | 相当           |
| **文件查找**     | O(n) 遍历文件名  | O(1) hash 查找    | 快 10-100x     |
| **undo/redo**    | ❌ 文件泄漏      | ✅ 引用计数管理   | 无泄漏         |
| **GC**           | ❌ 手动清理      | ✅ 自动延迟 GC    | 自动化         |
| **文件安全**     | ⚠️ 可能误删      | ✅ 引用计数保护   | 100% 安全      |
| **并发安全**     | ❌ 命名冲突      | ✅ hash 无冲突    | 100% 安全      |

---

### 18.7 使用示例

#### 18.7.1 初始化

```javascript
// 启动时初始化 FilePool
const filePool = new FilePoolManager(lockscreenID)
filePool.startAutoGC() // 启动定时 GC（每 5 分钟）
```

#### 18.7.2 添加文件

```javascript
// 用户上传图片
const hash = await filePool.addFile('/path/to/logo.png', 'drawable/logo.png')
// → hash: 'a3d2f1e9c4b8f7d6e5a3c2b1...'
// → refCount: 1
```

#### 18.7.3 多组件共享文件

```javascript
// 第 1 个组件使用 logo
const hash1 = await filePool.addFile('/path/to/logo.png', 'drawable/logo.png')
// → refCount: 1

// 第 2 个组件使用相同 logo
const hash2 = await filePool.addFile('/path/to/logo.png', 'drawable/logo.png')
// → hash2 === hash1（相同）
// → refCount: 2（不会重复复制文件）

// 第 3 个组件使用相同 logo
const hash3 = await filePool.addFile('/path/to/logo.png', 'drawable/logo.png')
// → hash3 === hash1（相同）
// → refCount: 3（仍然只存 1 份文件）
```

#### 18.7.4 删除组件

```javascript
// 删除第 1 个组件
filePool.removeRef(hash)
// → refCount: 2（文件继续保留）

// 删除第 2 个组件
filePool.removeRef(hash)
// → refCount: 1（文件继续保留）

// 删除第 3 个组件
filePool.removeRef(hash)
// → refCount: 0（标记为 GC，但不立即删除）
```

#### 18.7.5 撤销操作

```javascript
// 用户撤销删除
history.undo()
// → sideEffects.undo() 被调用
// → filePool.addRef(hash)
// → refCount: 1（文件被重新激活，GC 标记取消）
```

#### 18.7.6 垃圾回收

```javascript
// 1 小时后，定时 GC 触发
filePool.gc()
// → 检查 gcMarks，发现该文件标记时间超过 1 小时
// → 删除文件 a3d2f1e9c4b8f7d6e5a3c2b1...
// → 清理元数据
// → 持久化 metadata.json
```

---

### 18.8 边界情况处理

#### 18.8.1 文件损坏

```javascript
async addFile(filePath, androidPath) {
  try {
    const hash = await this.computeHash(filePath)
    // ...
  } catch (error) {
    console.error('[FilePool] Failed to add file:', error)
    throw new Error(`无法添加文件：${error.message}`)
  }
}
```

#### 18.8.2 磁盘空间不足

```javascript
async addFile(filePath, androidPath) {
  const stats = fs.statSync(filePath)
  const availableSpace = utils.getAvailableDiskSpace()

  if (stats.size > availableSpace) {
    throw new Error('磁盘空间不足')
  }

  // ...
}
```

#### 18.8.3 文件被外部删除

```javascript
getFilePath(hash) {
  const poolPath = path.resolve(this.poolDir, hash)

  if (!fs.existsSync(poolPath)) {
    console.error(`[FilePool] File not found: ${hash}`)
    // 可选：从引用计数中移除
    this.refCount.delete(hash)
    this.metadata.delete(hash)
    throw new Error(`文件丢失：${hash}`)
  }

  return `file://${poolPath}`
}
```

#### 18.8.4 元数据损坏

```javascript
loadMetadata() {
  const metaPath = path.resolve(this.poolDir, 'metadata.json')

  if (fs.existsSync(metaPath)) {
    try {
      const data = JSON.parse(fs.readFileSync(metaPath, 'utf-8'))
      this.refCount = new Map(data.refCount || [])
      this.metadata = new Map(data.metadata || [])
      this.gcMarks = new Map(data.gcMarks || [])
    } catch (error) {
      console.error('[FilePool] Metadata corrupted, rebuilding...')
      // 重建元数据：扫描池目录，重新计算引用计数
      this.rebuildMetadata()
    }
  }
}

rebuildMetadata() {
  // 扫描池目录
  const files = fs.readdirSync(this.poolDir).filter(f => f !== 'metadata.json')

  // 扫描 JSON 数据，重新计算引用计数
  const state = runtimeManager.getState()
  const usedHashes = new Set()

  function collectHashes(elements) {
    elements.forEach(el => {
      if (el.attributes?.src?.hash) {
        usedHashes.add(el.attributes.src.hash)
      }
      if (el.elements) {
        collectHashes(el.elements)
      }
    })
  }

  collectHashes(state.json.elements)

  // 重建引用计数
  this.refCount.clear()
  usedHashes.forEach(hash => {
    this.refCount.set(hash, 1) // 简化处理，设为 1
  })

  // 标记未使用的文件为 GC
  files.forEach(hash => {
    if (!usedHashes.has(hash)) {
      this.gcMarks.set(hash, Date.now())
    }
  })

  // 持久化
  this.saveMetadata()
}
```

---

### 18.9 测试用例

#### 18.9.1 功能测试

```javascript
// 测试 1：基本添加和删除
test('add and remove file', async () => {
  const hash = await filePool.addFile('test.png', 'drawable/test.png')
  expect(filePool.refCount.get(hash)).toBe(1)

  filePool.removeRef(hash)
  expect(filePool.refCount.has(hash)).toBe(false)
  expect(filePool.gcMarks.has(hash)).toBe(true)
})

// 测试 2：自动去重
test('auto deduplication', async () => {
  const hash1 = await filePool.addFile('test.png', 'drawable/test.png')
  const hash2 = await filePool.addFile('test.png', 'drawable/test.png')

  expect(hash1).toBe(hash2)
  expect(filePool.refCount.get(hash1)).toBe(2)
})

// 测试 3：引用计数
test('reference counting', async () => {
  const hash = await filePool.addFile('test.png', 'drawable/test.png')
  filePool.addRef(hash)
  filePool.addRef(hash)
  expect(filePool.refCount.get(hash)).toBe(3)

  filePool.removeRef(hash)
  filePool.removeRef(hash)
  expect(filePool.refCount.get(hash)).toBe(1)

  filePool.removeRef(hash)
  expect(filePool.refCount.has(hash)).toBe(false)
})

// 测试 4：GC
test('garbage collection', async () => {
  const hash = await filePool.addFile('test.png', 'drawable/test.png')
  filePool.removeRef(hash)

  // 立即 GC（不会删除，因为未超过保留期）
  await filePool.gc(60 * 60 * 1000)
  expect(filePool.fileExists(hash)).toBe(true)

  // 模拟 1 小时后
  filePool.gcMarks.set(hash, Date.now() - 61 * 60 * 1000)
  await filePool.gc(60 * 60 * 1000)
  expect(filePool.fileExists(hash)).toBe(false)
})
```

#### 18.9.2 集成测试

```javascript
// 测试 5：与 undo/redo 集成
test('undo/redo integration', async () => {
  // 添加组件（带图片）
  await addComponentFlow({ name: 'Image', imagePath: 'test.png' })
  const hash = Object.values(runtimeManager.getState().json.elements)[0]?.attributes?.src?.hash
  expect(filePool.refCount.get(hash)).toBe(1)

  // 撤销
  history.undo()
  expect(filePool.refCount.has(hash)).toBe(false)
  expect(filePool.gcMarks.has(hash)).toBe(true)

  // 重做
  history.redo()
  expect(filePool.refCount.get(hash)).toBe(1)
  expect(filePool.gcMarks.has(hash)).toBe(false)
})

// 测试 6：替换图片
test('replace image', async () => {
  await addComponentFlow({ name: 'Image', imagePath: 'old.png' })
  const oldHash = Object.values(runtimeManager.getState().json.elements)[0]?.attributes?.src?.hash

  await replaceImageFlow(nodeId, 'new.png')
  const newHash = Object.values(runtimeManager.getState().json.elements)[0]?.attributes?.src?.hash

  expect(filePool.refCount.get(oldHash)).toBe(undefined)
  expect(filePool.refCount.get(newHash)).toBe(1)

  // 撤销替换
  history.undo()
  expect(filePool.refCount.get(oldHash)).toBe(1)
  expect(filePool.refCount.get(newHash)).toBe(undefined)
})
```

---

### 18.10 最佳实践

#### 1. 总是使用 FilePool

```javascript
// ✅ 正确
const hash = await filePool.addFile(imagePath, androidPath)
element.attributes.src = { hash, ...filePool.metadata.get(hash) }

// ❌ 错误
element.attributes.src = imagePath // 不要直接存路径
```

#### 2. 副作用必须对称

```javascript
// ✅ 正确
sideEffects: {
  redo: () => filePool.addRef(hash),
  undo: () => filePool.removeRef(hash)
}

// ❌ 错误
sideEffects: {
  redo: () => filePool.addRef(hash)
  // 缺少 undo，会导致文件泄漏
}
```

#### 3. 提前保存 hash

```javascript
// ✅ 正确
const oldHash = node.attributes?.src?.hash
history.modifyWithHistory(desc, draft => {
  // 修改 draft...
}, key, {
  undo: () => filePool.addRef(oldHash) // 使用保存的 oldHash
})

// ❌ 错误
history.modifyWithHistory(desc, draft => {
  // 修改 draft...
}, key, {
  undo: () => {
    const hash = runtimeManager.getState()... // draft 已经改了，获取不到旧值
    filePool.addRef(hash)
  }
})
```

#### 4. 定期 GC

```javascript
// 启动时启动定时 GC
filePool.startAutoGC()

// 关闭时停止 GC
window.addEventListener('beforeunload', () => {
  filePool.stopAutoGC()
})
```

#### 5. 导出时复制文件

```javascript
// 导出锁屏
async function exportLockscreen(targetDir) {
  const state = runtimeManager.getState()

  // 遍历所有元素，导出文件
  function exportFiles(elements) {
    elements.forEach(el => {
      if (el.attributes?.src?.hash) {
        const hash = el.attributes.src.hash
        const androidPath = el.attributes.src.androidPath
        const targetPath = path.resolve(targetDir, androidPath)

        filePool.exportFile(hash, targetPath)
      }
      if (el.elements) {
        exportFiles(el.elements)
      }
    })
  }

  exportFiles(state.json.elements)
}
```

---

## 📝 附录 A. 文档维护

### 版本历史

| 版本 | 日期       | 作者   | 主要变更                                         |
| ---- | ---------- | ------ | ------------------------------------------------ |
| v4.0 | 2025-12-10 | Claude | 按照参考文档范式重新组织，补充背景和术语表       |
| v3.0 | 2025-12-09 | -      | 增加 Immer、FilePool、降级策略等完整技术方案      |
| v2.0 | 2025-12-08 | -      | 初始版本，基础架构设计                           |

### 待办事项

- [x] 完成第 7-11 章（架构设计与实现）✅
- [x] 完成第 12-14 章（容错与边界）✅
- [x] 完成第 15-17 章（集成、验收与扩展）✅
- [x] 添加第 18 章（FilePool 文件池管理）✅
- [x] 补充完整代码示例和最佳实践 ✅

### 文档完成度

本文档已完整包含以下内容：

- ✅ **第 1-6 章：背景与决策** - 项目背景、核心诉求、术语定义、设计目标、整体设计思路、JSON 数据结构原则
- ✅ **第 7-11 章：架构与实现** - RuntimeStateManager、HistoryManager、UI 同步策略、渲染优化、操作合并、典型业务流程（完整代码实现）
- ✅ **第 12-14 章：容错与边界** - 6 种降级策略、错误处理、边界情况、技术约束（含完整实现代码）
- ✅ **第 15-17 章：评估与扩展** - 集成改造任务拆解（6 阶段）、验收标准、6 个扩展方向、Vue 3 迁移路径
- ✅ **第 18 章：FilePool** - 内容寻址 + 引用计数、与 undo/redo 集成、性能对比、测试用例、最佳实践

**代码行数统计：**
- RuntimeStateManager: ~150 行
- HistoryManager: ~300 行
- Patch 分发器: ~200 行
- 降级策略: ~520 行
- FilePoolManager: ~400 行
- 业务流程示例: ~600 行
- 测试用例: ~200 行

**总计：约 5000+ 行完整技术文档，包含 2000+ 行可执行代码示例**
