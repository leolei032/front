# 锁屏编辑器前进/后退技术方案（v3，聚焦运行时与历史，去掉打包插件化）

> 适配现状：Vue 2 + lockscreen-v2（layerTreeManager / treeStore / currentFormStore / selectionStore），主进程 lockscreenNew。目标：建立单一运行时真源 + 补丁栈 + 双栈 undo/redo + 快照兜底的可落地方案，增量同步 UI，保证性能与容错。

---

## 目录

1. 目标与非目标
2. 现状与差距
3. 总体架构
4. 数据结构设计
5. 补丁与历史模型
6. 运行时状态管理器（草案代码）
7. 历史管理器（草案代码）
8. 关键业务流程（增/删/改/移/undo/redo）
9. UI 同步策略（左/中/右 + 选中）
10. 快照与 Autosave
11. 性能优化点
12. 容错与回滚策略
13. 集成与改造任务拆解
14. 验收标准
15. 可选增强

---

## 1. 目标与非目标

- 目标
  - 单一运行时数据源 runtimeState，补丁先作用真源，再同步 UI。
  - 补丁栈 + undo/redo 双栈；支持 ≥100 步历史。
  - 增量更新 UI，避免根引用替换导致全量渲染。
  - 快照兜底 + 可选 Autosave/崩溃恢复。
  - 性能：单步 undo/redo < 50ms（P95）；高频操作可合并。
  - 容错：补丁失败可回滚；快照损坏可绕过；副作用可对称撤销。
- 非目标
  - 不改技术栈（仍 Vue2）。
  - 不做导出插件化/打包流程改造。
  - 不大改主进程导出逻辑。

---

## 2. 现状与差距

- UI 三块：左（layerTreeManager）、中（treeStore + previewTreeStore 初始）、右（currentFormStore）+ 选中（selectionStore）。
- 写操作：invokeMiddle → middle/主进程写缓存/文件 → 回传增量更新 UI；无 runtimeState。
- 前端无 undo/redo；主/中层整包快照未接线；无补丁栈。
- layerTreeManager 缺 update/move；无 Autosave/快照兜底；高频操作无聚合。

---

## 3. 总体架构

### 3.1 分层视图

```
UI 层（Vue2 组件）
 ├─ 左：图层/变量树（layerTreeManager）
 ├─ 中：画布（treeStore + Konva；previewTreeStore 初始）
 └─ 右：表单（currentFormStore）+ 选中（selectionStore）

状态层
 ├─ runtimeState（唯一真源，非响应式根）
 ├─ 补丁与历史（undoStack/redoStack + 快照）
 └─ applyPatchToStores（UI 投影同步器）

业务层
 ├─ Flow（add/remove/update/move/vars/资源）
 └─ invokeMiddle（需落盘/读缓存时）

基础设施
 ├─ 快照/Autosave（可选）
 ├─ 错误与副作用处理
 └─ 性能/批处理（可选）
```

### 3.2 数据流与调用关系

- 写操作：UI → Flow → 生成补丁 → runtimeState.applyPatches → applyPatchToStores → history.push。
- 撤销/重做：history 弹栈 → runtimeState.applyPatches(inverse/forward) → applyPatchGroupToStores → sideEffects 对称执行。
- 快照/Autosave：由 HistoryManager 周期触发或定时触发，序列化 runtimeState（可含历史）。
- 与 middle/主进程：仅在持久化/导出时调用；常规编辑链路可纯前端。

### 3.3 组件职责摘要

- runtimeStateManager：保存真源，提供 applyPatches/clone。
- HistoryManager：双栈 + 快照管理，裁剪与可用状态。
- applyPatchToStores：将补丁映射到左/中/右/选中，保持 UI 与真源一致。
- Flow：封装具体业务操作（增删改移/变量/资源），生成补丁并入栈。

---

## 4. 数据结构设计

### 4.1 runtimeState 结构

- runtimeState（真源，内存，不暴露为响应式根）
  - tree：左树数据（layers/vars）
  - preview：画布渲染树（含 meta/children/id/pid）
  - json：用于表单/派生的结构（对应节点原始数据）
  - vars：变量集合
  - xml：专家模式/导出需要的 XML
  - meta：锁屏基本信息（name/dir/osVersion 等）
- UI 投影
  - 左：`layerTreeManager.layerData/varData`
  - 中：`treeStore`（扁平 Map + 事件总线），`previewTreeStore` 仅初始化用
  - 右：`currentFormStore.formItems`
  - 选中：`selectionStore`

### 4.2 JSON 数据结构设计原则

为保证 Patch 机制的正确性和性能，数据结构必须遵循以下原则：

#### 原则 1：使用稳定 ID 作为 key（必须）

```javascript
// ❌ 错误：使用数组（索引会变化）
{
  "elements": [
    { "type": "Image", "src": "icon.png" }  // 索引 0
  ]
}

// ✅ 正确：使用对象 + 稳定 ID
{
  "elementsById": {
    "node_12345": {
      "id": "node_12345",
      "type": "Image",
      "src": { "hash": "a3d2f1e9...", "androidPath": "icon.png" }
    }
  },
  "elementOrder": ["node_12345"]  // 单独维护顺序
}
```

**原因：**

- Patch 路径依赖 key（如 `/elementsById/node_12345/src`）
- 删除其他节点不会影响该节点的路径
- 撤销/重做永远能找到正确的节点

**ID 生成策略：**

```javascript
function genId() {
	return `node_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`
	// 示例：node_1702345678901_a3x9f2k
}
```

#### 原则 2：文件引用只存 hash（必须）

```javascript
// ❌ 错误：存储 base64 或完整路径
{
  "src": "data:image/png;base64,iVBORw0KGgo..."  // 10MB
}

// ✅ 正确：只存储 hash + 元数据
{
  "src": {
    "hash": "a3d2f1e9b7c4d6e8f0a1b2c3d4e5f6a7",  // 64 bytes
    "androidPath": "drawable/icon.png",
    "width": 120,
    "height": 120,
    "size": 10240
  }
}
```

**收益：**

- 内存占用节省 99.9%（10MB → 64 bytes）
- 自动去重（多个组件使用同一图片 → 只存储 1 份）
- 文件实际存储在 FilePool（见第 14 章）

#### 原则 3：禁止污染业务数据（必须）

```javascript
// ❌ 错误：添加元数据字段
{
  "id": "node_123",
  "type": "Image",
  "_version": 3,              // ← 不需要
  "_lastModified": 1702345678, // ← 不需要
  "_author": "user123"        // ← 不需要
}

// ✅ 正确：元数据由 Patch 管理
{
  "id": "node_123",
  "type": "Image"
  // 无任何元数据字段
}
```

**原因：**

- 每次修改 `_lastModified` 会产生无关 Patch
- 无法正确合并操作
- 增加序列化大小

**版本信息应由 PatchGroup 记录：**

```javascript
{
  patches: [...],
  inversePatches: [...],
  desc: "update node",
  ts: Date.now(),  // ← 时间戳在这里
  sideEffects: {...}
}
```

#### 原则 4：禁止软删除（必须）

```javascript
// ❌ 错误：软删除标记
{
  "elementsById": {
    "node_123": {
      "type": "Image",
      "_deleted": true  // ← 不要这样做
    }
  }
}

// ✅ 正确：直接删除 key
{
  "elementsById": {
    // node_123 已被删除，key 不存在
  }
}
```

**Patch 示例：**

```javascript
// 删除操作的 Patch
{
  op: "remove",
  path: ["elementsById", "node_123"]
}

// 撤销时的 inverse Patch
{
  op: "add",
  path: ["elementsById", "node_123"],
  value: { "type": "Image", "src": {...} }
}
```

### 4.3 推荐的数据结构模式

```javascript
// 完整的 runtimeState 结构示例
const runtimeState = {
	// 元数据
	meta: {
		name: '我的锁屏',
		dir: '/path/to/lockscreen',
		osVersion: '16'
	},

	// 树形数据（按 ID 存储）
	tree: {
		layers: {
			node_root: { id: 'node_root', pid: 0, type: 'Lockscreen', name: '根节点' },
			node_123: { id: 'node_123', pid: 'node_root', type: 'Image', name: '图标' }
		},
		vars: {
			var_123: { id: 'var_123', name: 'hour12', expression: '#hour12' }
		}
	},

	// 渲染数据（用于画布）
	preview: {
		node_123: {
			id: 'node_123',
			pid: 'node_root',
			meta: { x: 0, y: 0, w: 120, h: 120, visible: true },
			renderType: 'image'
		}
	},

	// 原始 JSON（用于表单/导出）
	json: {
		elements: [
			{
				name: 'Lockscreen',
				attributes: { id: 'node_root' },
				elements: [
					{
						name: 'Image',
						attributes: {
							id: 'node_123',
							src: {
								hash: 'a3d2f1e9...',
								androidPath: 'drawable/icon.png',
								width: 120,
								height: 120
							},
							x: '0',
							y: '0',
							w: '120',
							h: '120'
						}
					}
				]
			}
		]
	},

	// XML 字符串（用于导出）
	xml: '<Lockscreen>...</Lockscreen>',

	// 变量上下文
	vars: [{ name: 'hour12', value: '#hour12' }]
}
```

---

## 5. 补丁与历史模型

- 补丁类型（最小集，可扩展）
  - addNode：{ treeNode, renderNode, index? }
  - removeNode：{ id, pid, snapshotNode?, renderNode? }
  - updateNode：{ nodeId, renderNode?, treeNode?, form?, meta? }
  - moveNode：{ nodeId, fromPid, toPid, index? }
  - updateVars：{ vars }
  - replaceAsset（可选）：{ key, oldRef, newRef }
- 补丁组（历史单元）
  - `{ patches: Patch[], inversePatches: Patch[], desc, ts, sideEffects? }`
  - sideEffects：文件引用计数、拷贝等需对称撤销/重做的操作
- 生成方式
  - 自定义构造；或用 Immer 仅取 patches/inversePatches，丢弃 newState，避免根替换。

---

## 6. 运行时状态管理器（增强版：支持 Immer）

### 6.1 核心设计：Immer 自动生成 Patch

**关键优势：**

- ✅ 零手写 Patch，避免手动构造 forward/inverse
- ✅ 100% 准确，自动处理深层嵌套修改
- ✅ 与双层架构兼容（runtimeState + UI Stores）

### 6.2 实现代码

```js
import { produceWithPatches, applyPatches as immerApplyPatches } from 'immer'

/**
 * runtimeState 持有者，非响应式根
 * 支持 Immer 自动生成 Patch
 */
class RuntimeStateManager {
	constructor(initial) {
		this.state = initial // { tree, preview, json, vars, xml, meta }
	}

	/**
	 * ⭐ 使用 Immer 自动生成 Patch（推荐方式）
	 * @param {Function} updater - 修改函数 (draft) => { draft.xxx = yyy }
	 * @returns {{ patches: Patch[], inversePatches: Patch[] }}
	 */
	modify(updater) {
		const [nextState, patches, inversePatches] = produceWithPatches(this.state, updater)
		this.state = nextState
		return { patches, inversePatches }
	}

	/**
	 * 应用 Patch（用于 undo/redo）
	 * @param {Patch[]} patches - Immer 标准 Patch 数组
	 */
	applyPatches(patches) {
		this.state = immerApplyPatches(this.state, patches)
		return this.state
	}

	/**
	 * 获取当前状态（只读）
	 */
	getState() {
		return this.state
	}

	/**
	 * 克隆状态（用于快照）
	 */
	clone() {
		return JSON.parse(JSON.stringify(this.state))
	}
}
```

### 6.3 使用示例

```js
// 初始化
const runtimeManager = new RuntimeStateManager({
	tree: { layers: {}, vars: {} },
	preview: {},
	json: { elements: [] },
	vars: [],
	xml: '',
	meta: {}
})

// ✅ 使用 Immer 自动生成 Patch
const { patches, inversePatches } = runtimeManager.modify(draft => {
	// 直接修改 draft，Immer 自动追踪变化
	draft.json.elements.push({
		name: 'Image',
		attributes: {
			id: 'node_123',
			src: { hash: 'a3d2f1e9...', androidPath: 'icon.png' },
			x: '0',
			y: '0',
			w: '120',
			h: '120'
		}
	})
	draft.tree.layers['node_123'] = {
		id: 'node_123',
		pid: 'node_root',
		type: 'Image'
	}
	draft.preview['node_123'] = {
		id: 'node_123',
		meta: { x: 0, y: 0, w: 120, h: 120 }
	}
})

// Immer 自动生成的 Patch 示例
console.log(patches)
// [
//   { op: 'add', path: ['json', 'elements', 0], value: {...} },
//   { op: 'add', path: ['tree', 'layers', 'node_123'], value: {...} },
//   { op: 'add', path: ['preview', 'node_123'], value: {...} }
// ]

console.log(inversePatches)
// [
//   { op: 'remove', path: ['json', 'elements', 0] },
//   { op: 'remove', path: ['tree', 'layers', 'node_123'] },
//   { op: 'remove', path: ['preview', 'node_123'] }
// ]
```

### 6.4 与手写 Patch 的对比

```js
// ❌ 手写方式（不推荐）
function buildUpdatePatches({ nodeId, meta }) {
	const before = runtimeManager.getState().json?.[nodeId] || {}
	const forward = [
		{ type: 'updateNode', nodeId, renderNode, treeNode, form }
	]
	const inverse = [
		{ type: 'updateNode', nodeId, renderNode: before.render, ... }
	]
	return { forward, inverse }
}

// ✅ Immer 方式（推荐）
function updateNode(nodeId, meta) {
	return runtimeManager.modify(draft => {
		draft.json.elementsById[nodeId].attributes.src = meta.src
		draft.tree.layers[nodeId].name = meta.name
		draft.preview[nodeId].meta = { ...draft.preview[nodeId].meta, ...meta }
	})
	// Immer 自动生成 patches/inversePatches，无需手写
}
```

**收益对比：**

| 维度         | 手写 Patch             | Immer 自动生成  |
| ------------ | ---------------------- | --------------- |
| **代码量**   | 50-100 行              | 5-10 行         |
| **出错风险** | 高（手动计算 inverse） | 低（100% 准确） |
| **维护成本** | 高                     | 低              |
| **深层嵌套** | 复杂                   | 自动处理        |
| **开发效率** | 1x                     | 10x             |

---

## 7. 历史管理器（增强版：RAF + 防抖批处理 + 双栈 + 快照）

### 7.1 核心设计：RAF + 防抖组合策略

**问题：为什么不能只用防抖？**

在数据驱动的 UI 架构中，存在一个根本矛盾：

```javascript
// ❌ 纯防抖方案的问题：
用户拖动组件 → 30ms 后才执行 → 数据才更新 → UI 才渲染
// 结果：用户拖动时看不到实时反馈！UI 卡顿！

// ✅ 正确方案：分离"执行"和"记录"
用户拖动组件 → 立即执行（更新数据）→ RAF 批量渲染 → 防抖记录历史
// 结果：UI 实时响应 + 历史完美合并
```

**方案对比：**

| 方案              | 渲染次数             | 历史记录数 | 问题                   |
| ----------------- | -------------------- | ---------- | ---------------------- |
| **纯防抖**        | 1 次（延迟 30ms）    | 1 条       | ❌ UI 卡顿，无实时反馈 |
| **纯 RAF**        | 2 次（每 16ms 一帧） | 2 条       | ⚠️ 仍有多条历史记录    |
| **RAF + 防抖 ✅** | 2 次（实时）         | 1 条       | ✅ 完美                |

### 7.2 实现代码

```js
/**
 * 历史管理器
 * 支持：RAF 批处理 + 防抖合并 + 双栈 + 周期快照 + Map 去重
 */
class HistoryManager {
	constructor({ max = 100, snapshotInterval = 20 }) {
		// 双栈
		this.undoStack = []
		this.redoStack = []

		// 快照
		this.snapshots = new Map()
		this.max = max
		this.snapshotInterval = snapshotInterval

		// ⭐ RAF + 防抖批处理
		this.pendingPatchGroups = new Map() // key → PatchGroup（自动去重）
		this.rafTimer = null
		this.debounceTimer = null
		this.DEBOUNCE_DELAY = 30 // 30ms 防抖延迟

		// 外部注入
		this.runtimeManager = null  // RuntimeStateManager 实例
		this.onStateChange = null   // 状态变化回调
		this.onSnapshot = null      // 快照生成回调
	}

	/**
	 * ⭐ 添加操作（RAF + 防抖组合）
	 * @param {string} description - 操作描述
	 * @param {Function} updater - 修改函数 (draft) => {}
	 * @param {string} key - 去重 key（可选）
	 * @param {Object} sideEffects - 副作用（可选）
	 */
	modifyWithHistory(description, updater, key, sideEffects) {
		// 1. 立即执行修改，获取 Patches
		const { patches, inversePatches } = this.runtimeManager.modify(updater)

		// 2. 生成去重 key（同路径操作会自动覆盖）
		const operationKey = key || this.generateKey(patches)

		// 3. 加入队列（Map 自动去重）
		this.pendingPatchGroups.set(operationKey, {
			patches,
			inversePatches,
			description,
			timestamp: Date.now(),
			sideEffects
		})

		// 4. RAF 批量渲染（Vue 2 响应式系统会自动处理 UI 更新）
		if (this.rafTimer === null) {
			this.rafTimer = requestAnimationFrame(() => {
				this.flushRender()
			})
		}

		// 5. 防抖记录历史（延迟记录）
		if (this.debounceTimer !== null) {
			clearTimeout(this.debounceTimer)
		}
		this.debounceTimer = setTimeout(() => {
			this.recordToHistory()
		}, this.DEBOUNCE_DELAY)
	}

	/**
	 * RAF 触发（批量修改已完成，Vue 2 会自动处理 UI 更新）
	 */
	flushRender() {
		if (this.pendingPatchGroups.size === 0) return

		// 所有修改已通过 modify() 完成
		// applyPatchToStores 会在 modifyWithHistory 外部同步调用
		this.rafTimer = null

		console.log(`[RAF] Batch completed ${this.pendingPatchGroups.size} operations`)
	}

	/**
	 * 记录到历史（防抖触发）
	 */
	recordToHistory() {
		if (this.pendingPatchGroups.size === 0) return

		const groups = Array.from(this.pendingPatchGroups.values())

		// 可选：智能合并相同路径的 Patch
		const merged = this.smartMergeIfNeeded(groups)

		// 添加到历史栈
		merged.forEach(group => {
			this.undoStack.push(group)
		})
		this.redoStack = []

		// 裁剪 + 快照
		this.trim()
		this.saveSnapshotIfNeeded()

		// 清空队列
		this.pendingPatchGroups.clear()
		this.debounceTimer = null

		console.log(`[History] Recorded ${merged.length} patch groups`)
		this.emitStateChange()
	}

	/**
	 * 立即刷新（用于强制提交，如用户点击保存按钮）
	 */
	forceFlush() {
		// 取消所有定时器
		if (this.rafTimer !== null) {
			cancelAnimationFrame(this.rafTimer)
			this.rafTimer = null
		}
		if (this.debounceTimer !== null) {
			clearTimeout(this.debounceTimer)
			this.debounceTimer = null
		}

		// 立即记录到历史
		this.recordToHistory()
	}

	/**
	 * 生成去重 key
	 */
	generateKey(patches) {
		if (patches.length === 0) return `empty_${Date.now()}`
		// 使用第一个 Patch 的路径作为 key
		return patches[0].path.join(':')
	}

	/**
	 * 智能合并（可选）
	 */
	smartMergeIfNeeded(groups) {
		// 简单示例：如果只有一个 group，直接返回
		if (groups.length === 1) return groups

		// 详细的合并逻辑参考第9章
		// 这里可以实现路径级合并、时间窗口合并等
		return groups
	}

	/**
	 * 直接添加 PatchGroup（不经过批处理，用于非用户操作）
	 */
	push(group) {
		if (!group || !group.patches?.length) return
		this.undoStack.push(group)
		this.redoStack = []
		this.trim()
		this.saveSnapshotIfNeeded()
		this.emitStateChange()
	}

	/**
	 * 撤销
	 */
	undo(steps = 1) {
		for (let i = 0; i < steps && this.canUndo(); i++) {
			const g = this.popUndo()

			// 应用 inverse patches
			this.runtimeManager.applyPatches(g.inversePatches)

			// 副作用
			if (g.sideEffects?.undo) {
				g.sideEffects.undo()
			}

			this.pushRedo(g)
		}
		this.emitStateChange()
	}

	/**
	 * 重做
	 */
	redo(steps = 1) {
		for (let i = 0; i < steps && this.canRedo(); i++) {
			const g = this.popRedo()

			// 应用 forward patches
			this.runtimeManager.applyPatches(g.patches)

			// 副作用
			if (g.sideEffects?.redo) {
				g.sideEffects.redo()
			}

			this.undoStack.push(g)
		}
		this.emitStateChange()
	}

	// 以下为辅助方法
	popUndo() {
		return this.undoStack.pop()
	}
	popRedo() {
		return this.redoStack.pop()
	}
	pushRedo(g) {
		this.redoStack.push(g)
	}
	canUndo() {
		return this.undoStack.length > 0
	}
	canRedo() {
		return this.redoStack.length > 0
	}
	trim() {
		if (this.undoStack.length > this.max) {
			const remove = this.undoStack.splice(0, this.undoStack.length - this.max)
			// TODO: 清理副作用引用计数
		}
	}
	saveSnapshotIfNeeded() {
		const idx = this.undoStack.length
		if (idx % this.snapshotInterval === 0) {
			const snap = this.onSnapshot?.()
			if (snap) this.snapshots.set(idx, snap)
		}
	}
	findSnapshot(targetIndex) {
		let nearest = null
		let min = Infinity
		this.snapshots.forEach((v, k) => {
			if (k <= targetIndex && targetIndex - k < min) {
				min = targetIndex - k
				nearest = { idx: k, state: v }
			}
		})
		return nearest
	}
	emitStateChange() {
		this.onStateChange?.({
			canUndo: this.canUndo(),
			canRedo: this.canRedo(),、
			undoCount: this.undoStack.length,
			redoCount: this.redoStack.length
		})
	}
}
```

### 7.3 实际工作流程

```javascript
// 用户拖动组件 500ms（30 次 mousemove 事件）
0ms:    modifyWithHistory → 立即执行修改 → RAF 调度 + 防抖调度
16ms:   RAF 执行 → UI 更新（第1帧）
17ms:   modifyWithHistory → 立即执行修改 → RAF 调度 + 防抖重置
33ms:   RAF 执行 → UI 更新（第2帧）
...
500ms:  停止拖动
530ms:  防抖触发 → 记录 1 条历史

// 最终结果：
// - 渲染次数：2 次（每 16ms 一帧，减少 93%）
// - 历史记录：1 条（完美合并）
// - 用户体验：流畅的实时拖动反馈
```

### 7.4 性能数据对比

| 指标         | 无优化 | 纯防抖        | 纯 RAF | **RAF + 防抖** |
| ------------ | ------ | ------------- | ------ | -------------- |
| **渲染次数** | 30 次  | 1 次（延迟）  | 2 次   | **2 次** ✅    |
| **历史记录** | 30 条  | 1 条          | 2 条   | **1 条** ✅    |
| **实时反馈** | ✅ 有  | ❌ 无（卡顿） | ✅ 有  | **✅ 有**      |
| **内存占用** | 高     | 低            | 中     | **低**         |

---

## 8. 关键业务流程（增/删/改/移/undo/redo）

### 8.0 总体时序（使用 Immer + RAF + 防抖）

```
UI 事件 → Flow 收集上下文
    ↓
调用 history.modifyWithHistory(desc, updater, key?, sideEffects?)
    ↓
① Immer 自动生成 patches/inversePatches
    ↓
② 更新 runtimeState（立即生效）
    ↓
③ applyPatchesToStores 同步 UI（增量更新）
    ↓
④ RAF 批量渲染（16ms 一帧）
    ↓
⑤ 防抖延迟 30ms 后记录到历史栈
```

**关键优势：**

- ✅ 无需手写 `buildAddPatches` / `buildUpdatePatches`
- ✅ Immer 自动生成 100% 准确的 inverse patches
- ✅ RAF + 防抖自动合并高频操作（拖拽、滑块等）

### 8.1 新的写操作通用步骤

```javascript
// 统一模式：通过 history.modifyWithHistory 完成所有操作
history.modifyWithHistory(
	'操作描述',              // 用于历史面板显示
	draft => {              // Immer updater 函数
		// 直接修改 draft，Immer 自动追踪
		draft.tree.layers[nodeId] = { ... }
		draft.preview[nodeId] = { ... }
		draft.json.elements.push({ ... })
	},
	'去重key',               // 可选，用于 Map 去重
	{                       // 可选，副作用
		redo: () => filePool.addRef(hash),
		undo: () => filePool.removeRef(hash)
	}
)

// 之后立即同步 UI
applyPatchesToStores(patches)
```

### 8.2 add 示例（使用 Immer）

```js
/**
 * 添加组件（支持图片文件）
 */
async function addComponentFlow({ name, desc, imagePath }) {
	const parentId = selectionStore.selectedNodeId.value || 'node_root'
	const newId = genId()

	// 1. 如果有图片，先添加到 FilePool
	let imageHash = null
	if (imagePath && renderTypeMap[name] === 'image') {
		imageHash = await filePool.addFile(imagePath, `drawable/${path.basename(imagePath)}`)
	}

	// 2. ⭐ 使用 Immer 自动生成补丁
	history.modifyWithHistory(
		`add ${name}`,
		draft => {
			// 直接修改 draft，Immer 自动追踪所有变化

			// 更新 tree
			draft.tree.layers[newId] = {
				id: newId,
				pid: parentId,
				type: name,
				name: desc || name
			}

			// 更新 preview
			draft.preview[newId] = {
				id: newId,
				pid: parentId,
				meta: { x: 0, y: 0, w: 120, h: 120, visible: true },
				renderType: renderTypeMap[name] || 'group'
			}

			// 更新 json
			const parentElement = findElementById(draft.json.elements, parentId)
			if (parentElement) {
				parentElement.elements = parentElement.elements || []
				parentElement.elements.push({
					name,
					attributes: {
						id: newId,
						src: imageHash
							? {
									hash: imageHash,
									androidPath: `drawable/${path.basename(imagePath)}`,
									...filePool.metadata.get(imageHash)
							  }
							: undefined,
						x: '0',
						y: '0',
						w: '120',
						h: '120'
					}
				})
			}
		},
		`add:${newId}`, // 去重 key
		{
			// 副作用：管理文件引用计数
			redo: () => {
				if (imageHash) filePool.addRef(imageHash)
			},
			undo: () => {
				if (imageHash) filePool.removeRef(imageHash)
			}
		}
	)

	// 3. 同步 UI（从 pendingPatchGroups 中获取最新 patches）
	const latestPatches = history.pendingPatchGroups.get(`add:${newId}`)?.patches
	if (latestPatches) {
		applyPatchesToStores(latestPatches)
	}

	// 4. 选中新节点
	selectionStore.selectNode(newId)
}
```

**对比手写方式：**

```javascript
// ❌ 旧方式：需要手写 buildAddPatches（50+ 行）
const { forward, inverse } = buildAddPatches({ parentId, name })
runtimeManager.applyPatches(forward)
applyPatchToStores(forward)
history.push({ patches: forward, inversePatches: inverse, ... })

// ✅ 新方式：Immer 自动生成（10 行）
history.modifyWithHistory('add component', draft => {
	draft.tree.layers[newId] = { ... }
	draft.preview[newId] = { ... }
	// Immer 自动生成 patches/inversePatches
})
```

### 8.3 update 示例（使用 Immer）

```js
/**
 * 更新节点属性（高频操作，会自动合并）
 */
function updateNodeFlow(nodeId, meta) {
	if (!nodeId) return

	// ⭐ 使用路径作为去重 key，同节点的连续修改会自动覆盖
	const key = `update:${nodeId}:meta`

	history.modifyWithHistory(
		`update ${nodeId}`,
		draft => {
			// 更新 preview（用于画布渲染）
			if (draft.preview[nodeId]) {
				draft.preview[nodeId].meta = {
					...draft.preview[nodeId].meta,
					...meta
				}
			}

			// 更新 tree（用于左侧图层树）
			if (draft.tree.layers[nodeId]) {
				draft.tree.layers[nodeId].name = meta.name || draft.tree.layers[nodeId].name
			}

			// 更新 json（用于导出和表单）
			const element = findElementById(draft.json.elements, nodeId)
			if (element && element.attributes) {
				Object.assign(element.attributes, {
					x: String(meta.x ?? element.attributes.x),
					y: String(meta.y ?? element.attributes.y),
					w: String(meta.w ?? element.attributes.w),
					h: String(meta.h ?? element.attributes.h)
				})
			}
		},
		key // ⭐ 去重 key：拖拽时连续 30 次调用 → Map 只保留最后一次
	)

	// 同步 UI
	const latestPatches = history.pendingPatchGroups.get(key)?.patches
	if (latestPatches) {
		applyPatchesToStores(latestPatches)
	}
}

// 用户拖动组件示例：
// 0ms:    updateNodeFlow(id, {x:10, y:20}) → Map['update:id:meta'] = patch1
// 16ms:   updateNodeFlow(id, {x:15, y:25}) → Map['update:id:meta'] = patch2（覆盖）
// 32ms:   updateNodeFlow(id, {x:20, y:30}) → Map['update:id:meta'] = patch3（覆盖）
// ...
// 530ms:  防抖触发 → 只记录 1 条历史（最后的 patch3）
```

### 8.4 remove 示例（使用 Immer）

```js
/**
 * 删除节点
 */
function removeNodeFlow() {
	const nodeId = selectionStore.selectedNodeId.value
	if (!nodeId) return

	// 获取节点信息（用于副作用）
	const node = runtimeManager.getState().json.elements.find(e => e.attributes?.id === nodeId)
	const imageHash = node?.attributes?.src?.hash

	history.modifyWithHistory(
		`remove ${nodeId}`,
		draft => {
			// 从 tree 中删除
			delete draft.tree.layers[nodeId]

			// 从 preview 中删除
			delete draft.preview[nodeId]

			// 从 json 中删除
			removeElementById(draft.json.elements, nodeId)
		},
		`remove:${nodeId}`,
		{
			// 副作用：文件引用计数
			redo: () => {
				if (imageHash) filePool.removeRef(imageHash)
			},
			undo: () => {
				if (imageHash) filePool.addRef(imageHash)
			}
		}
	)

	// 同步 UI
	const latestPatches = history.pendingPatchGroups.get(`remove:${nodeId}`)?.patches
	if (latestPatches) {
		applyPatchesToStores(latestPatches)
	}

	// 清空选中
	selectionStore.deselectNode()
	currentFormStore.formItems.value = []
}
```

### 8.5 move 示例（使用 Immer）

```js
/**
 * 移动节点（调整层级顺序）
 */
function moveNodeFlow(nodeId, toPid, index) {
	history.modifyWithHistory(
		`move ${nodeId}`,
		draft => {
			// 更新 tree
			if (draft.tree.layers[nodeId]) {
				draft.tree.layers[nodeId].pid = toPid
			}

			// 更新 preview
			if (draft.preview[nodeId]) {
				draft.preview[nodeId].pid = toPid
			}

			// 更新 json（需要移动元素位置）
			const element = findAndRemoveElementById(draft.json.elements, nodeId)
			if (element) {
				const targetParent = findElementById(draft.json.elements, toPid)
				if (targetParent) {
					targetParent.elements = targetParent.elements || []
					targetParent.elements.splice(index ?? targetParent.elements.length, 0, element)
				}
			}
		},
		`move:${nodeId}`
	)

	// 同步 UI
	const latestPatches = history.pendingPatchGroups.get(`move:${nodeId}`)?.patches
	if (latestPatches) {
		applyPatchesToStores(latestPatches)
	}
}
```

### 8.6 undo/redo 流程（已在第 7 章实现）

undo/redo 已经在 `HistoryManager` 中实现，业务代码只需调用：

```js
// 撤销
function handleUndo() {
	history.undo(1)
	// HistoryManager 会自动：
	// 1. 应用 inversePatches 到 runtimeState
	// 2. 调用 sideEffects.undo()
	// 3. 同步 UI（需要在外部监听 patches 并调用 applyPatchesToStores）
}

// 重做
function handleRedo() {
	history.redo(1)
	// HistoryManager 会自动：
	// 1. 应用 patches 到 runtimeState
	// 2. 调用 sideEffects.redo()
	// 3. 同步 UI
}

// 快捷键绑定
document.addEventListener('keydown', e => {
	if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
		e.preventDefault()
		handleUndo()
	}
	if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
		e.preventDefault()
		handleRedo()
	}
})
```

### 8.7 applyPatchesToStores 实现（UI 同步）

Immer 生成的 Patch 是标准的 JSON Patch 格式，需要将其映射到三个 UI Store：

```js
/**
 * 将 Immer Patch 应用到 UI Store
 * @param {Patch[]} patches - Immer 生成的标准 Patch 数组
 */
function applyPatchesToStores(patches) {
	patches.forEach(patch => {
		const { op, path, value } = patch

		// path 示例: ['tree', 'layers', 'node_123', 'name']
		const [rootKey, ...restPath] = path

		if (rootKey === 'tree' && restPath[0] === 'layers') {
			// 更新左侧图层树
			const nodeId = restPath[1]
			if (op === 'add' || op === 'replace') {
				if (restPath.length === 2) {
					// 添加/替换整个节点
					layerTreeManager.insertNode(value)
				} else {
					// 更新节点属性
					layerTreeManager.updateNode?.(nodeId, { [restPath[2]]: value })
				}
			} else if (op === 'remove') {
				layerTreeManager.deleteNode(nodeId)
			}
		}

		if (rootKey === 'preview') {
			// 更新中间画布
			const nodeId = restPath[0]
			if (op === 'add' || op === 'replace') {
				if (restPath.length === 1) {
					// 添加/替换整个节点
					treeStore.addNode(value, value.pid)
				} else if (restPath[1] === 'meta') {
					// 更新节点 meta
					treeStore.updateNode(nodeId, { meta: value })
				}
			} else if (op === 'remove') {
				treeStore.removeNode(nodeId, treeStore.getNode(nodeId)?.pid)
			}
		}

		if (rootKey === 'tree' && restPath[0] === 'vars') {
			// 更新变量列表
			layerTreeManager.varData.value = Object.values(runtimeManager.getState().tree.vars)
		}

		// 如果删除了选中节点，清空表单
		if (op === 'remove' && restPath[0] === 'preview') {
			const nodeId = restPath[1]
			if (selectionStore.isNodeSelected?.(nodeId)) {
				selectionStore.deselectNode()
				currentFormStore.formItems.value = []
			}
		}
	})
}
```

**关键优势：**

```javascript
// ✅ 使用 Immer Patch（标准格式）
{
	op: "replace",
	path: ["preview", "node_123", "meta", "x"],
	value: 100
}

// ❌ 旧方式（自定义格式，需要手写映射）
{
	type: "updateNode",
	nodeId: "node_123",
	renderNode: { meta: { x: 100 } }
}
```

### 8.8 快照 + 补丁重放（大步撤销优化）

当用户一次性撤销/重做多步时，可以利用快照加速：

```js
/**
 * 大步撤销（利用快照优化）
 * @param {number} steps - 撤销步数
 */
function undoWithSnapshot(steps) {
	const targetIndex = history.undoStack.length - steps
	if (targetIndex < 0) return

	// 查找最近的快照
	const snap = history.findSnapshot(targetIndex)

	if (snap && snap.idx < targetIndex) {
		// 1. 恢复快照
		runtimeManager.state = snap.state

		// 2. 从快照位置重放补丁到目标位置
		for (let i = snap.idx; i < targetIndex; i++) {
			const g = history.undoStack[i]
			runtimeManager.applyPatches(g.patches)
		}

		// 3. 调整历史栈
		history.redoStack.push(...history.undoStack.slice(targetIndex))
		history.undoStack = history.undoStack.slice(0, targetIndex)

		// 4. 重建 UI（从 runtimeState 完全重建）
		rebuildUIFromRuntimeState()
	} else {
		// 无快照，逐步撤销
		history.undo(steps)
	}
}

/**
 * 从 runtimeState 完全重建 UI
 */
function rebuildUIFromRuntimeState() {
	const state = runtimeManager.getState()

	// 重建左侧图层树
	layerTreeManager.layerData.value = Object.values(state.tree.layers)
	layerTreeManager.varData.value = Object.values(state.tree.vars)

	// 重建中间画布
	treeStore.clear()
	Object.values(state.preview).forEach(node => {
		treeStore.addNode(node, node.pid)
	})

	// 清空右侧表单
	currentFormStore.formItems.value = []
	selectionStore.deselectNode()
}
```

**性能对比：**

| 场景       | 逐步撤销                         | 快照恢复 + 重放                                   |
| ---------- | -------------------------------- | ------------------------------------------------- |
| 撤销 50 步 | 50 次 Patch 应用 + 50 次 UI 更新 | 1 次快照恢复 + 30 次 Patch（从快照 20 到目标 50） |
| 耗时       | ~2500ms（50 × 50ms）             | **~150ms**（快照恢复 100ms + 重放 50ms）          |
| 性能提升   | 1x                               | **16x**                                           |

---

## 9. 操作合并优化（Map 去重 + 智能合并）

### 9.1 核心设计：Map 自动去重

**问题场景：**

```javascript
// 用户拖动组件 500ms，触发 30 次 mousemove 事件
updateNodeFlow(nodeId, { x: 10, y: 20 }) // 第 1 次
updateNodeFlow(nodeId, { x: 15, y: 25 }) // 第 2 次
updateNodeFlow(nodeId, { x: 20, y: 30 }) // 第 3 次
// ... 共 30 次

// ❌ 无去重：30 条历史记录
// ✅ Map 去重：1 条历史记录（最后一次）
```

**解决方案：**

在 `HistoryManager` 中使用 `Map<key, PatchGroup>` 存储待处理的补丁：

```javascript
// HistoryManager.modifyWithHistory 中的关键代码
this.pendingPatchGroups.set(operationKey, {
	patches, // 最新的 patches
	inversePatches, // 最新的 inversePatches
	description,
	timestamp: Date.now(),
	sideEffects
})
// ⭐ Map 的特性：相同 key 会自动覆盖旧值
```

### 9.2 去重 Key 生成策略

```javascript
/**
 * 生成去重 key
 * @param {Patch[]} patches - Immer 生成的 Patch 数组
 * @returns {string} 去重 key
 */
function generateKey(patches) {
	if (patches.length === 0) return `empty_${Date.now()}`

	// 策略1：使用第一个 Patch 的路径
	const firstPatch = patches[0]
	return firstPatch.path.join(':')
	// 示例：["preview", "node_123", "meta", "x"] → "preview:node_123:meta:x"
}

// 示例：连续修改同一节点的 x 坐标
// Patch1: path = ["preview", "node_123", "meta", "x"], value = 10
//   → key = "preview:node_123:meta:x"
// Patch2: path = ["preview", "node_123", "meta", "x"], value = 20
//   → key = "preview:node_123:meta:x"（覆盖 Patch1）
// Patch3: path = ["preview", "node_123", "meta", "x"], value = 30
//   → key = "preview:node_123:meta:x"（覆盖 Patch2）
// 最终只记录 Patch3
```

**自定义 Key（更精确的控制）：**

```javascript
// 场景1：整体更新节点（使用节点级 key）
history.modifyWithHistory(
	'update node',
	draft => {
		/* 修改多个字段 */
	},
	`update:${nodeId}` // ← 自定义 key，覆盖同节点的所有修改
)

// 场景2：只更新位置（使用字段级 key）
history.modifyWithHistory(
	'update position',
	draft => {
		draft.preview[nodeId].meta.x = 100
	},
	`update:${nodeId}:position` // ← 字段级 key，不影响其他属性修改
)
```

### 9.3 合并效果对比

```javascript
// 用户拖动组件示例（30 次 mousemove）
0ms:    updateNodeFlow(nodeId, {x:10, y:20})
        → pendingPatchGroups['preview:node_123:meta'] = PatchGroup1

16ms:   updateNodeFlow(nodeId, {x:15, y:25})
        → pendingPatchGroups['preview:node_123:meta'] = PatchGroup2 （覆盖）

32ms:   updateNodeFlow(nodeId, {x:20, y:30})
        → pendingPatchGroups['preview:node_123:meta'] = PatchGroup3 （覆盖）

...

500ms:  停止拖动
530ms:  防抖触发 → recordToHistory()
        → pendingPatchGroups.size = 1（只剩最后一次）
        → 记录 1 条历史
```

**性能数据：**

| 指标           | 无优化 | 防抖   | **Map 去重 + 防抖** |
| -------------- | ------ | ------ | ------------------- |
| **历史记录数** | 30 条  | 2-3 条 | **1 条** ✅         |
| **内存占用**   | 高     | 中     | **低**              |
| **合并率**     | 0%     | ~90%   | **97%+**            |

### 9.4 智能合并算法（可选增强）

在 `recordToHistory()` 中，可以进一步优化合并策略：

```javascript
/**
 * 智能合并（可选）
 * @param {PatchGroup[]} groups - 待合并的 PatchGroup 数组
 * @returns {PatchGroup[]} 合并后的 PatchGroup 数组
 */
smartMergeIfNeeded(groups) {
	// 简单场景：只有一个 group，直接返回
	if (groups.length === 1) return groups

	// 高级合并策略1：路径级合并
	// 如果多个 group 修改了同一节点的不同字段，可以合并为一个 group
	const mergedByNode = new Map()

	for (const group of groups) {
		const nodeId = this.extractNodeId(group.patches)
		if (nodeId && mergedByNode.has(nodeId)) {
			// 合并到已有的 group
			const existing = mergedByNode.get(nodeId)
			existing.patches.push(...group.patches)
			existing.inversePatches.unshift(...group.inversePatches)
			existing.description += ` + ${group.description}`
		} else if (nodeId) {
			mergedByNode.set(nodeId, { ...group })
		} else {
			// 无法提取 nodeId，保持独立
			mergedByNode.set(`independent_${group.timestamp}`, group)
		}
	}

	return Array.from(mergedByNode.values())
}

/**
 * 从 Patches 中提取节点 ID
 */
extractNodeId(patches) {
	if (patches.length === 0) return null
	const path = patches[0].path
	// 尝试从 path 中提取 nodeId
	// 示例：["preview", "node_123", "meta", "x"] → "node_123"
	if (path[0] === 'preview' || path[0] === 'tree') {
		return path[1]
	}
	return null
}
```

### 9.5 使用示例

```javascript
// 场景1：高频操作（拖拽、滑块）
function handleMouseMove(e) {
	const { x, y } = calculatePosition(e)

	// ⭐ 使用相同的 key，自动覆盖
	history.modifyWithHistory(
		'drag component',
		draft => {
			draft.preview[selectedNodeId].meta.x = x
			draft.preview[selectedNodeId].meta.y = y
		},
		`drag:${selectedNodeId}`  // ← 相同 key
	)

	// 同步 UI
	applyPatchesToStores(...)
}
// 结果：30 次 mousemove → 1 条历史记录

// 场景2：批量操作（导入多个组件）
function importComponents(components) {
	components.forEach((comp, index) => {
		history.modifyWithHistory(
			`import ${comp.name}`,
			draft => {
				// 添加组件
				const newId = genId()
				draft.tree.layers[newId] = { ... }
				draft.preview[newId] = { ... }
			},
			`import:${index}`  // ← 每个组件不同的 key
		)
	})
}
// 结果：导入 10 个组件 → 10 条历史记录（符合预期）
```

### 9.6 合并策略选择

| 场景         | 推荐策略         | Key 设计                       | 合并率 |
| ------------ | ---------------- | ------------------------------ | ------ |
| **拖拽组件** | Map 去重         | `drag:${nodeId}`               | 97%+   |
| **滑块调整** | Map 去重         | `update:${nodeId}:${property}` | 95%+   |
| **文本输入** | Map 去重 + 防抖  | `edit:${nodeId}:text`          | 98%+   |
| **添加组件** | 不合并           | `add:${newId}`                 | 0%     |
| **删除组件** | 不合并           | `remove:${nodeId}`             | 0%     |
| **批量对齐** | 事务模式（可选） | 自定义                         | 100%   |

---

## 10. UI 同步策略（左/中/右 + 选中）

- 左树（layerTreeManager）：插入/删除/更新/移动；缺失的 update/move 方法需实现；必要时浅拷贝 `layerData.value = [...layerData.value]` 触发响应。
- 中画布（treeStore）：使用 add/update/remove/move 维护扁平 Map + 事件总线，驱动 Konva 局部刷新。
- 右表单（currentFormStore）：updateForms 或清空；选中变化时重新获取 formData。
- 选中（selectionStore）：删除选中节点后清空；新增可选自动选中新节点。
- 变量：`updateVars` 补丁时重新赋值新数组触发响应。

---

## 11. 快照与 Autosave

- 快照（兜底，低频）：每 N 步（如 20）或内存门限，保存 runtimeState 深拷贝/压缩；大步撤销时：最近快照恢复 + 补丁重放。
- Autosave（可选）：每 T 秒或 M 次操作，将 runtimeState + 历史栈序列化到 IndexedDB/本地文件；启动时询问恢复。

---

## 12. 性能优化点

- 不替换根引用，补丁只改必要字段。
- 高频属性操作：可开启路径去重/防抖/RAF 聚合（同路径保留最后值）。
- 大步撤销用快照 + 补丁重放，避免长链重放耗时。
- 局部刷新：仅受影响节点/变量/表单更新 UI。
- 可选：批量撤销聚合（按钮/快捷键短窗合并）；路径级去重（同路径 replace 仅保留末次）。
- 可选：分层刷新优先级（先数据再画布/表单），减少重复渲染。

---

## 13. 降级与容错策略

### 13.1 核心设计原则

**分层容错：**

1. **数据层容错**：补丁应用失败时立即回滚
2. **UI 层容错**：UI 同步失败时从 runtimeState 重建
3. **副作用容错**：文件操作失败时提供降级方案
4. **系统级容错**：Immer 失效时切换快照模式

### 13.2 降级方案矩阵

| 故障类型         | 检测方式        | 降级方案     | 恢复策略           |
| ---------------- | --------------- | ------------ | ------------------ |
| **Immer 失效**   | try-catch       | 切换快照模式 | 用户操作后自动重试 |
| **补丁应用失败** | 应用返回 false  | inverse 回滚 | 提示用户           |
| **快照损坏**     | JSON.parse 失败 | 跳过快照     | 使用更早快照       |
| **副作用失败**   | IO 错误         | 跳过副作用   | 用户手动修复       |
| **UI 同步失败**  | 捕获异常        | 重建 UI      | 自动恢复           |
| **内存不足**     | 历史栈超限      | LRU 裁剪     | 自动清理           |

### 13.3 具体实现

#### 13.3.1 Immer 失效降级（切换快照模式）

```javascript
class RuntimeStateManager {
	constructor(initial) {
		this.state = initial
		this.immerEnabled = true // Immer 可用标志
		this.fallbackMode = false // 降级模式标志
	}

	/**
	 * 修改状态（支持降级）
	 */
	modify(updater) {
		if (!this.immerEnabled || this.fallbackMode) {
			// 降级：使用快照模式
			return this.modifyWithSnapshot(updater)
		}

		try {
			// 正常：使用 Immer
			const [nextState, patches, inversePatches] = produceWithPatches(this.state, updater)
			this.state = nextState
			return { patches, inversePatches }
		} catch (error) {
			console.error('[Immer Error]', error)
			// 检测到 Immer 失败，切换到快照模式
			this.fallbackMode = true
			return this.modifyWithSnapshot(updater)
		}
	}

	/**
	 * 快照模式（降级方案）
	 */
	modifyWithSnapshot(updater) {
		// 1. 备份当前状态
		const before = JSON.parse(JSON.stringify(this.state))

		// 2. 直接修改状态（不使用 Immer）
		const mutableState = JSON.parse(JSON.stringify(this.state))
		updater(mutableState)
		this.state = mutableState

		// 3. 生成快照式补丁
		return {
			patches: [{ op: 'replace', path: [], value: this.state }],
			inversePatches: [{ op: 'replace', path: [], value: before }]
		}
	}
}
```

**触发场景：**

- Immer 库加载失败
- Proxy 不可用（IE 11 等）
- 复杂对象导致 Immer 崩溃

#### 13.3.2 补丁应用失败回滚

```javascript
class HistoryManager {
	/**
	 * 撤销（带容错）
	 */
	undo(steps = 1) {
		const rollbackStack = [] // 回滚栈

		for (let i = 0; i < steps && this.canUndo(); i++) {
			const g = this.popUndo()

			try {
				// 1. 应用 inverse patches
				this.runtimeManager.applyPatches(g.inversePatches)

				// 2. 应用副作用
				if (g.sideEffects?.undo) {
					g.sideEffects.undo()
				}

				// 3. 记录成功
				this.pushRedo(g)
				rollbackStack.push(g)
			} catch (error) {
				console.error('[Undo Failed]', error)

				// ⭐ 失败处理：立即回滚已执行的操作
				this.rollbackFailedUndo(rollbackStack)

				// 提示用户
				this.notifyUser({
					type: 'error',
					message: '撤销失败，已自动回滚',
					detail: error.message
				})

				return false // 撤销失败
			}
		}

		this.emitStateChange()
		return true
	}

	/**
	 * 回滚失败的撤销操作
	 */
	rollbackFailedUndo(rollbackStack) {
		// 反向重做已执行的操作
		while (rollbackStack.length > 0) {
			const g = rollbackStack.pop()
			try {
				this.runtimeManager.applyPatches(g.patches)
				if (g.sideEffects?.redo) {
					g.sideEffects.redo()
				}
				this.undoStack.push(g)
			} catch (e) {
				console.error('[Rollback Failed]', e)
				// 如果回滚也失败，只能从快照恢复
				this.recoverFromSnapshot()
			}
		}
	}

	/**
	 * 从最近快照恢复
	 */
	recoverFromSnapshot() {
		const latestSnap = this.findLatestSnapshot()
		if (latestSnap) {
			this.runtimeManager.state = latestSnap.state
			// 重建 UI
			rebuildUIFromRuntimeState()
		} else {
			// 无快照，只能提示用户重新加载
			this.notifyUser({
				type: 'fatal',
				message: '数据损坏，请重新加载项目'
			})
		}
	}
}
```

#### 12.3.3 快照损坏处理

```javascript
/**
 * 保存快照（带容错）
 */
saveSnapshotIfNeeded() {
	const idx = this.undoStack.length
	if (idx % this.snapshotInterval !== 0) return

	try {
		const snap = this.onSnapshot?.()
		if (snap) {
			// 验证快照可序列化
			const serialized = JSON.stringify(snap)
			const deserialized = JSON.parse(serialized)

			// 保存快照
			this.snapshots.set(idx, deserialized)

			// 限制快照数量（LRU）
			if (this.snapshots.size > 10) {
				const oldest = Math.min(...this.snapshots.keys())
				this.snapshots.delete(oldest)
			}
		}
	} catch (error) {
		console.error('[Snapshot Failed]', error)
		// 快照失败不影响主流程，只记录日志
	}
}

/**
 * 查找可用快照（跳过损坏的）
 */
findSnapshot(targetIndex) {
	let nearest = null
	let min = Infinity

	this.snapshots.forEach((snap, idx) => {
		if (idx <= targetIndex && targetIndex - idx < min) {
			try {
				// 验证快照完整性
				if (snap && snap.tree && snap.preview && snap.json) {
					min = targetIndex - idx
					nearest = { idx, state: snap }
				}
			} catch (e) {
				// 跳过损坏的快照
				console.warn('[Snapshot Corrupted]', idx, e)
			}
		}
	})

	return nearest
}
```

#### 13.3.4 副作用失败处理

```javascript
/**
 * 副作用执行（带重试）
 */
async executeSideEffect(sideEffect, type = 'redo') {
	if (!sideEffect || !sideEffect[type]) return true

	const maxRetries = 3
	let retries = 0

	while (retries < maxRetries) {
		try {
			await sideEffect[type]()
			return true
		} catch (error) {
			retries++
			console.warn(`[SideEffect Failed] Retry ${retries}/${maxRetries}`, error)

			if (retries >= maxRetries) {
				// 最终失败：提示用户
				const action = await this.askUser({
					title: '副作用执行失败',
					message: `文件操作失败: ${error.message}`,
					options: [
						{ label: '跳过', value: 'skip' },
						{ label: '重试', value: 'retry' },
						{ label: '取消操作', value: 'cancel' }
					]
				})

				if (action === 'retry') {
					retries = 0  // 重置重试次数
					continue
				} else if (action === 'skip') {
					return false  // 跳过副作用
				} else {
					throw error  // 取消操作
				}
			}

			// 等待后重试
			await sleep(1000 * retries)
		}
	}

	return false
}
```

#### 13.3.5 UI 同步失败恢复

```javascript
/**
 * 应用补丁到 UI（带容错）
 */
function applyPatchesToStoresWithFallback(patches) {
	try {
		applyPatchesToStores(patches)
	} catch (error) {
		console.error('[UI Sync Failed]', error)

		// 降级：从 runtimeState 完全重建 UI
		try {
			rebuildUIFromRuntimeState()
		} catch (rebuildError) {
			console.error('[UI Rebuild Failed]', rebuildError)

			// 最终降级：刷新页面
			if (confirm('UI 同步失败，是否刷新页面？')) {
				window.location.reload()
			}
		}
	}
}
```

#### 13.3.6 内存不足处理（LRU 裁剪）

```javascript
/**
 * 裁剪历史栈（LRU 策略）
 */
trim() {
	if (this.undoStack.length <= this.max) return

	const removeCount = this.undoStack.length - this.max
	const removed = this.undoStack.splice(0, removeCount)

	// 清理副作用引用
	removed.forEach(g => {
		if (g.sideEffects?.cleanup) {
			try {
				g.sideEffects.cleanup()
			} catch (e) {
				console.warn('[Cleanup Failed]', e)
			}
		}
	})

	// 删除对应的快照
	removed.forEach((_, idx) => {
		this.snapshots.delete(idx)
	})

	console.log(`[History] Trimmed ${removeCount} operations`)
}
```

### 13.4 一致性校验（定期检查）

```javascript
/**
 * 定期校验 runtimeState 与 UI 一致性
 */
function startConsistencyCheck() {
	setInterval(() => {
		try {
			const state = runtimeManager.getState()

			// 校验左侧图层树
			const layerCount = Object.keys(state.tree.layers).length
			const uiLayerCount = layerTreeManager.layerData.value.length

			if (layerCount !== uiLayerCount) {
				console.warn('[Consistency Warning] Layer count mismatch', {
					runtimeState: layerCount,
					ui: uiLayerCount
				})

				// 自动修复
				rebuildUIFromRuntimeState()
			}
		} catch (error) {
			console.error('[Consistency Check Failed]', error)
		}
	}, 5 * 60 * 1000) // 每 5 分钟检查一次
}
```

### 13.5 容错验收标准

| 场景             | 预期行为         | 验收标准          |
| ---------------- | ---------------- | ----------------- |
| **Immer 失效**   | 自动切换快照模式 | ✅ 操作继续可用   |
| **补丁应用失败** | 立即回滚         | ✅ 状态回到操作前 |
| **快照损坏**     | 跳过损坏快照     | ✅ 使用更早快照   |
| **副作用失败**   | 提示用户选择     | ✅ 不阻断主流程   |
| **UI 同步失败**  | 自动重建 UI      | ✅ 界面恢复正常   |
| **连续失败**     | 从快照恢复       | ✅ 数据不丢失     |

---

## 14. 集成与改造任务拆解

1. 基础设施
   - 新增 runtimeStateManager、historyManager；定义补丁类型/接口。
   - 实现 applyPatchToStores / applyPatchGroupToStores。
2. store 能力补齐
   - layerTreeManager：add/delete 已有，补齐 update/move；暴露浅拷贝触发响应的安全方法。
   - treeStore：确认 add/update/remove/move 已覆盖；必要时补 move。
3. flow 注入
   - add/remove/update/move 流程生成补丁 + 应用 runtimeState + 同步 UI + 入栈。
4. undo/redo UI
   - 快捷键（Ctrl/Cmd+Z / Ctrl/Cmd+Y），按钮状态（canUndo/canRedo）。
   - 可选批量撤销（150ms 聚合多次点击）。
5. 快照/Autosave（可选）
   - 周期快照；定时/计数 autosave；启动恢复路径。
6. 错误与副作用
   - sideEffects（文件引用计数）对称处理；失败回滚。
7. 校验与回归
   - 用例：增删改移、变量、资源替换；大步撤销；补丁失败模拟；快照恢复。

---

## 15. 文件池管理（FilePool）

### 15.1 核心设计：内容寻址 + 引用计数

**当前问题（如前文分析）：**

- ✗ 文件按名称存储，多个组件使用同一图片会重复复制
- ✗ 无引用计数，删除组件时不知道是否该删除文件
- ✗ undo/redo 无法管理文件生命周期，导致文件泄漏

**FilePool 方案：**

- ✅ 按文件 hash 存储（内容寻址），自动去重
- ✅ 引用计数管理，安全删除文件
- ✅ 与 undo/redo 集成，副作用对称处理
- ✅ 延迟 GC，避免误删

### 15.2 数据结构设计

```javascript
/**
 * 文件池管理器
 */
class FilePoolManager {
	constructor(lockscreenID) {
		this.lockscreenID = lockscreenID
		this.poolDir = path.resolve(dir_lockscreens, lockscreenID, '.file-pool')

		// 引用计数：hash → count
		this.refCount = new Map()

		// 元数据：hash → { androidPath, width, height, size, mimeType }
		this.metadata = new Map()

		// GC 标记：hash → markTime（引用计数归零的时间）
		this.gcMarks = new Map()

		// 确保目录存在
		utils.mkdirsSync(this.poolDir)

		// 加载持久化数据
		this.loadMetadata()
	}
}
```

### 15.3 核心方法实现

#### 15.3.1 添加文件（自动去重）

```javascript
/**
 * 添加文件到池中
 * @param {string} filePath - 源文件路径
 * @param {string} androidPath - Android 路径（如 'drawable/icon.png'）
 * @returns {Promise<string>} 文件 hash
 */
async addFile(filePath, androidPath) {
	// 1. 计算文件 hash
	const hash = await this.computeHash(filePath)

	// 2. 检查是否已存在
	if (!this.fileExists(hash)) {
		// 3. 文件不存在，复制到池中
		const poolPath = path.resolve(this.poolDir, hash)
		await utils.copy(filePath, poolPath)

		// 4. 保存元数据
		const stats = fs.statSync(filePath)
		let width, height

		if (filePath.match(/\.(png|jpg|jpeg|webp)$/i)) {
			const imgSize = utils.getImgSize(filePath)
			width = imgSize.width
			height = imgSize.height
		}

		this.metadata.set(hash, {
			androidPath,
			width,
			height,
			size: stats.size,
			mimeType: this.getMimeType(filePath),
			addedAt: Date.now()
		})

		// 持久化元数据
		this.saveMetadata()
	}

	// 5. 增加引用计数
	this.addRef(hash)

	// 6. 如果之前被标记为 GC，取消标记
	this.gcMarks.delete(hash)

	return hash
}

/**
 * 增加引用计数
 */
addRef(hash) {
	const count = this.refCount.get(hash) || 0
	this.refCount.set(hash, count + 1)
	console.log(`[FilePool] addRef ${hash}: ${count} → ${count + 1}`)
}

/**
 * 计算文件 SHA256 hash
 */
async computeHash(filePath) {
	const crypto = require('crypto')
	const buffer = fs.readFileSync(filePath)
	return crypto.createHash('sha256').update(buffer).digest('hex')
}

/**
 * 检查文件是否存在
 */
fileExists(hash) {
	const poolPath = path.resolve(this.poolDir, hash)
	return fs.existsSync(poolPath)
}
```

#### 15.3.2 移除引用（延迟 GC）

```javascript
/**
 * 移除文件引用（引用计数 -1）
 * @param {string} hash - 文件 hash
 */
removeRef(hash) {
	const count = this.refCount.get(hash) || 0

	if (count <= 1) {
		// 引用计数归零，标记为可删除（延迟 GC）
		this.refCount.delete(hash)
		this.gcMarks.set(hash, Date.now())
		console.log(`[FilePool] removeRef ${hash}: ${count} → 0 (marked for GC)`)
	} else {
		this.refCount.set(hash, count - 1)
		console.log(`[FilePool] removeRef ${hash}: ${count} → ${count - 1}`)
	}
}
```

#### 15.3.3 垃圾回收（延迟删除）

```javascript
/**
 * 垃圾回收（删除引用计数为 0 且超过保留期的文件）
 * @param {number} retentionTime - 保留时间（毫秒），默认 1 小时
 */
async gc(retentionTime = 60 * 60 * 1000) {
	const now = Date.now()
	const toDelete = []

	// 查找需要删除的文件
	this.gcMarks.forEach((markTime, hash) => {
		if (now - markTime > retentionTime) {
			toDelete.push(hash)
		}
	})

	// 删除文件
	for (const hash of toDelete) {
		try {
			const poolPath = path.resolve(this.poolDir, hash)
			if (fs.existsSync(poolPath)) {
				fs.unlinkSync(poolPath)
				console.log(`[FilePool] GC deleted: ${hash}`)
			}

			// 清理元数据
			this.metadata.delete(hash)
			this.gcMarks.delete(hash)
		} catch (error) {
			console.error(`[FilePool] GC failed for ${hash}:`, error)
		}
	}

	// 持久化元数据
	if (toDelete.length > 0) {
		this.saveMetadata()
	}

	console.log(`[FilePool] GC completed: ${toDelete.length} files deleted`)
	return toDelete.length
}

/**
 * 启动定时 GC
 * @param {number} interval - GC 间隔（毫秒），默认 5 分钟
 */
startAutoGC(interval = 5 * 60 * 1000) {
	this.gcTimer = setInterval(() => {
		this.gc()
	}, interval)
}

/**
 * 停止定时 GC
 */
stopAutoGC() {
	if (this.gcTimer) {
		clearInterval(this.gcTimer)
		this.gcTimer = null
	}
}
```

#### 15.3.4 获取文件路径（用于渲染）

```javascript
/**
 * 获取文件路径（用于预览）
 * @param {string} hash - 文件 hash
 * @returns {string} 文件绝对路径
 */
getFilePath(hash) {
	return `file://${path.resolve(this.poolDir, hash)}`
}

/**
 * 导出文件到目标位置（用于导出锁屏）
 * @param {string} hash - 文件 hash
 * @param {string} targetPath - 目标路径
 */
async exportFile(hash, targetPath) {
	const poolPath = path.resolve(this.poolDir, hash)
	if (fs.existsSync(poolPath)) {
		await utils.copy(poolPath, targetPath)
	} else {
		throw new Error(`File not found: ${hash}`)
	}
}
```

#### 15.3.5 持久化元数据

```javascript
/**
 * 保存元数据到磁盘
 */
saveMetadata() {
	const metaPath = path.resolve(this.poolDir, 'metadata.json')
	const data = {
		refCount: Array.from(this.refCount.entries()),
		metadata: Array.from(this.metadata.entries()),
		gcMarks: Array.from(this.gcMarks.entries())
	}

	fs.writeFileSync(metaPath, JSON.stringify(data, null, 2))
}

/**
 * 从磁盘加载元数据
 */
loadMetadata() {
	const metaPath = path.resolve(this.poolDir, 'metadata.json')

	if (fs.existsSync(metaPath)) {
		try {
			const data = JSON.parse(fs.readFileSync(metaPath, 'utf-8'))
			this.refCount = new Map(data.refCount || [])
			this.metadata = new Map(data.metadata || [])
			this.gcMarks = new Map(data.gcMarks || [])
			console.log(`[FilePool] Loaded metadata: ${this.refCount.size} files`)
		} catch (error) {
			console.error('[FilePool] Failed to load metadata:', error)
		}
	}
}
```

### 15.4 与 undo/redo 集成

```javascript
// 在 addComponentFlow 中集成 FilePool
async function addComponentFlow({ name, desc, imagePath }) {
	const newId = genId()
	let imageHash = null

	// 1. 如果有图片，先添加到 FilePool
	if (imagePath && renderTypeMap[name] === 'image') {
		imageHash = await filePool.addFile(imagePath, `drawable/${path.basename(imagePath)}`)
	}

	// 2. 使用 Immer 生成补丁
	history.modifyWithHistory(
		`add ${name}`,
		draft => {
			// ...修改 runtimeState
			if (imageHash) {
				draft.json.elements[newId].attributes.src = {
					hash: imageHash,
					androidPath: `drawable/${path.basename(imagePath)}`,
					...filePool.metadata.get(imageHash)
				}
			}
		},
		`add:${newId}`,
		{
			// ⭐ 副作用：管理文件引用计数
			redo: () => {
				if (imageHash) filePool.addRef(imageHash)
			},
			undo: () => {
				if (imageHash) filePool.removeRef(imageHash)
			}
		}
	)

	// 3. 同步 UI
	applyPatchesToStores(...)
}
```

### 15.5 文件结构对比

```
❌ 当前方案：
userData/lockscreens/ABC123/
  ├── manifest.xml
  ├── logo.png          (1MB)
  ├── logo_copy.png     (1MB，重复！)
  ├── logo_copy2.png    (1MB，重复！)
  └── time.png          (500KB)

✅ FilePool 方案：
userData/lockscreens/ABC123/
  ├── manifest.xml
  ├── .file-pool/
  │   ├── a3d2f1e9...   (1MB，logo 原文件，只存 1 份)
  │   ├── b7c4d6e8...   (500KB，time 原文件)
  │   └── metadata.json (元数据 + 引用计数)

// 结果：3 个组件使用同一 logo → 磁盘只存 1 份（节省 66%）
```

### 15.6 性能对比

| 指标          | 当前方案         | FilePool 方案   |
| ------------- | ---------------- | --------------- |
| **磁盘占用**  | 高（文件重复）   | 低（自动去重）  |
| **内存占用**  | 中（只存文件名） | 中（只存 hash） |
| **undo/redo** | ❌ 文件泄漏      | ✅ 引用计数管理 |
| **GC**        | ❌ 手动清理      | ✅ 自动延迟 GC  |
| **文件安全**  | ⚠️ 可能误删      | ✅ 引用计数保护 |

### 15.7 使用示例

```javascript
// 初始化
const filePool = new FilePoolManager(lockscreenID)
filePool.startAutoGC() // 启动定时 GC

// 添加文件
const hash = await filePool.addFile('/path/to/logo.png', 'drawable/logo.png')
// → hash: 'a3d2f1e9...'
// → refCount: 1

// 多个组件使用同一文件
const hash2 = await filePool.addFile('/path/to/logo.png', 'drawable/logo.png')
// → hash2 === hash（相同）
// → refCount: 2（不会重复复制文件）

// 删除组件
filePool.removeRef(hash)
// → refCount: 1

filePool.removeRef(hash)
// → refCount: 0（标记为 GC）

// 1 小时后，GC 自动删除文件
```

---

## 16. 验收标准

- 功能：Ctrl/Cmd+Z、Ctrl/Cmd+Y 可用；增删改移/变量/资源替换可撤销重做；历史深度 ≥100。
- 性能：单步 undo/redo < 50ms（P95）；高频操作开启聚合后历史显著减少、渲染次数下降。
- 稳定性：补丁失败可回滚；崩溃后可从 autosave/快照恢复；历史裁剪不致副作用泄漏。
- 一致性：runtimeState 与 UI 同步，无明显漂移；低频校验可重建 UI 通过。
- 文件管理：FilePool 自动去重；引用计数正确；GC 不误删；undo/redo 文件无泄漏。

---

## 17. 可选增强（方案与实现要点）

1. 路径去重 + RAF 批处理

   - 思路：同一属性/路径的连续 replace 只保留最后一次；16ms/防抖窗口聚合，窗口结束再入栈。
   - 实现：HistoryManager 增加 pendingPatchMap(pathKey → patch)，RAF/防抖触发 record；applyPatchToStores 仍逐条执行聚合后的补丁。
   - 预期：拖拽/滑块类操作历史减少 90%+，渲染次数显著下降。

2. 批量撤销聚合

   - 思路：150ms 窗口累积 undo/redo 请求，统一执行 undo(n)/redo(n)；n 大时触发快照恢复 + 补丁重放。
   - 实现：在 UI 层按钮/快捷键事件增加批处理调度器；HistoryManager 保持不变。
   - 预期：快速多次点击无闪烁，性能提升 10~20 倍（长链撤销）。

3. 历史面板

   - 思路：以补丁组 desc/ts 展示，支持跳转步数（间接调用 undo/redo(n)）。
   - 实现：暴露 undoStack/redoStack 的只读视图，UI 显示列表；点击某条时计算需要撤销/重做的步数并调用批量接口。

4. 动态快照策略

   - 思路：根据内存/变更量动态调整快照间隔（10~40 步）；大步撤销时优先使用最近快照。
   - 实现：HistoryManager.saveSnapshotIfNeeded 接收策略回调，根据 heapUsed/最近增长量调整 interval。

5. 文件监听提示

   - 思路：chokidar 监听 `userData/lockscreens/<id>`，外部修改时提示“重载/覆盖/忽略”。
   - 实现：主进程监听并通过 IPC 通知渲染；渲染弹窗选择后决定：a) 重建 runtimeState；b) 覆盖文件；c) 忽略。

6. 资源副作用细化

   - 思路：文件池内容寻址 + 引用计数 + 延迟 GC；副作用失败可忽略或重试。
   - 实现：sideEffects 中封装 addRef/removeRef，失败时抛业务错误；undo/redo 对称调用；GC 定时器分级（low/medium/high）。

7. 自动校验/重建

   - 思路：低频（如每 5 分钟或手动）从 runtimeState 重新派生 UI store，校验与现有 UI 数据一致性。
   - 实现：复用初始化流程（initLockScreenFlow 派生逻辑），比对关键节点/变量/选中；不一致时提示或直接重建 UI store。

8. 事务/批操作模式

   - 思路：transaction(fn)：在 fn 内的多次操作合并为一条历史，避免碎片记录（导入/批量对齐）。
   - 实现：HistoryManager 提供 begin/commit；commit 时计算 initial→final 的合并补丁（可用 produce 重新 diff 或合并 pending）。

9. 历史持久化
   - 思路：将补丁栈 + runtimeState/快照序列化到本地文件/IDB，支持恢复编辑态与历史。
   - 实现：提供 saveHistory/loadHistory 接口；副作用引用计数在加载时重建；可选只保存最近 N 步 + 最近快照。

---

## 附录：补丁应用器示例（可自定义/可用 Immer applyPatches）

```js
function applyFn(state, patches) {
	// 自定义遍历 patch 应用，或直接使用 immer.applyPatches(state, patches)
	// 注意保持 state 根引用不变时，需要在 applyPatches 后返回新对象给 runtimeStateManager 持有
	return applyPatches(state, patches) // 如使用 immer
}

function applyPatchGroupToStores(patches) {
	patches.forEach(p => {
		// 将通用 patch 转换成业务 patch.type
		applyPatchToStores(p) // 此处假定 p 已包含 type / payload
	})
}
```
