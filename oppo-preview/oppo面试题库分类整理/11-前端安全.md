# 前端安全

## 1. 跨域问题
**问题：** 跨域问题的解决方案

### 解答

#### 什么是跨域

**同源策略（Same-Origin Policy）**
- 协议相同（http/https）
- 域名相同
- 端口相同

```javascript
// 同源示例
http://example.com:80/page1
http://example.com:80/page2  // ✅ 同源

// 跨域示例
http://example.com
https://example.com  // ❌ 协议不同
http://www.example.com  // ❌ 域名不同
http://example.com:8080  // ❌ 端口不同
```

#### 跨域解决方案

**1. CORS（Cross-Origin Resource Sharing）**
```javascript
// 服务器端设置（Node.js/Express）
app.use((req, res, next) => {
  // 允许的域名
  res.header('Access-Control-Allow-Origin', 'http://localhost:3000');
  // 或允许所有域名（不安全）
  res.header('Access-Control-Allow-Origin', '*');

  // 允许的请求方法
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');

  // 允许的请求头
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  // 允许携带凭证（cookies）
  res.header('Access-Control-Allow-Credentials', 'true');

  // 预检请求缓存时间
  res.header('Access-Control-Max-Age', '86400');

  // 处理OPTIONS预检请求
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }

  next();
});

// 使用cors中间件
const cors = require('cors');

app.use(cors({
  origin: 'http://localhost:3000',
  credentials: true
}));

// 动态设置origin
app.use(cors({
  origin: function (origin, callback) {
    const whitelist = ['http://localhost:3000', 'https://example.com'];
    if (whitelist.indexOf(origin) !== -1 || !origin) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  }
}));
```

**2. JSONP**
```javascript
// 客户端
function jsonp(url, callback) {
  const script = document.createElement('script');
  const callbackName = `jsonp_${Date.now()}`;

  window[callbackName] = function(data) {
    callback(data);
    document.body.removeChild(script);
    delete window[callbackName];
  };

  script.src = `${url}?callback=${callbackName}`;
  document.body.appendChild(script);
}

// 使用
jsonp('http://api.example.com/data', (data) => {
  console.log(data);
});

// 服务器端（Node.js）
app.get('/data', (req, res) => {
  const callback = req.query.callback;
  const data = { name: 'John', age: 30 };
  res.send(`${callback}(${JSON.stringify(data)})`);
});
```

**3. 代理服务器**
```javascript
// Webpack Dev Server
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://api.example.com',
        changeOrigin: true,
        pathRewrite: { '^/api': '' }
      }
    }
  }
};

// Nginx反向代理
server {
  listen 80;
  server_name localhost;

  location /api/ {
    proxy_pass http://api.example.com/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
  }
}

// Node.js代理
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');

const app = express();

app.use('/api', createProxyMiddleware({
  target: 'http://api.example.com',
  changeOrigin: true,
  pathRewrite: { '^/api': '' }
}));
```

**4. postMessage**
```javascript
// 父页面
const iframe = document.getElementById('myIframe');
iframe.contentWindow.postMessage('Hello from parent', 'http://child.com');

window.addEventListener('message', (event) => {
  if (event.origin !== 'http://child.com') return;
  console.log('收到消息:', event.data);
});

// iframe页面
window.addEventListener('message', (event) => {
  if (event.origin !== 'http://parent.com') return;
  console.log('收到消息:', event.data);

  // 回复消息
  event.source.postMessage('Hello from iframe', event.origin);
});
```

**5. WebSocket**
```javascript
// WebSocket不受同源策略限制
const socket = new WebSocket('ws://api.example.com');

socket.onopen = () => {
  console.log('连接建立');
  socket.send('Hello Server');
};

socket.onmessage = (event) => {
  console.log('收到消息:', event.data);
};
```

**6. document.domain（子域名跨域）**
```javascript
// 只适用于子域名之间
// a.example.com
document.domain = 'example.com';

// b.example.com
document.domain = 'example.com';

// 现在可以互相访问
```

#### CORS深入解析

**CORS工作原理**

```javascript
// CORS（跨域资源共享）是一种基于HTTP头的机制
// 浏览器通过发送预检请求（Preflight）验证是否允许跨域

// 简单请求 vs 非简单请求

// 简单请求条件（同时满足）：
// 1. 方法: GET, HEAD, POST
// 2. 头部: 仅包含Accept, Accept-Language, Content-Language, Content-Type
// 3. Content-Type: application/x-www-form-urlencoded, multipart/form-data, text/plain

// 简单请求示例
fetch('https://api.example.com/data', {
  method: 'GET',
  headers: {
    'Accept': 'application/json'
  }
});

// 请求头:
// GET /data HTTP/1.1
// Host: api.example.com
// Origin: https://example.com

// 响应头:
// Access-Control-Allow-Origin: https://example.com
// Access-Control-Allow-Credentials: true

// 非简单请求示例（触发预检）
fetch('https://api.example.com/data', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
    'X-Custom-Header': 'value'
  },
  body: JSON.stringify({ name: 'John' })
});

// 预检请求（浏览器自动发送）:
// OPTIONS /data HTTP/1.1
// Host: api.example.com
// Origin: https://example.com
// Access-Control-Request-Method: PUT
// Access-Control-Request-Headers: Content-Type, X-Custom-Header

// 预检响应:
// HTTP/1.1 204 No Content
// Access-Control-Allow-Origin: https://example.com
// Access-Control-Allow-Methods: GET, POST, PUT, DELETE
// Access-Control-Allow-Headers: Content-Type, X-Custom-Header
// Access-Control-Max-Age: 86400

// 实际请求:
// PUT /data HTTP/1.1
// Host: api.example.com
// Origin: https://example.com
// Content-Type: application/json
// X-Custom-Header: value
```

**CORS响应头详解**

```javascript
// 1. Access-Control-Allow-Origin
// 指定允许访问的源
// ✓ 具体域名
res.set('Access-Control-Allow-Origin', 'https://example.com');

// ✓ 多个域名（需要动态设置）
const allowedOrigins = ['https://example.com', 'https://app.example.com'];
const origin = req.headers.origin;
if (allowedOrigins.includes(origin)) {
  res.set('Access-Control-Allow-Origin', origin);
}

// ✓ 所有域名（不安全）
res.set('Access-Control-Allow-Origin', '*');

// 注意：使用*时不能携带凭证（credentials）

// 2. Access-Control-Allow-Methods
// 指定允许的HTTP方法
res.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');

// 3. Access-Control-Allow-Headers
// 指定允许的请求头
res.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');

// 4. Access-Control-Allow-Credentials
// 是否允许携带凭证（cookies, HTTP认证）
res.set('Access-Control-Allow-Credentials', 'true');

// 客户端配置
fetch('https://api.example.com/data', {
  credentials: 'include'  // 携带cookies
});

// 5. Access-Control-Expose-Headers
// 指定客户端可以访问的响应头（默认只能访问6个基本头）
res.set('Access-Control-Expose-Headers', 'X-Total-Count, X-Page-Number');

// 客户端访问自定义响应头
fetch('https://api.example.com/data')
  .then(response => {
    const totalCount = response.headers.get('X-Total-Count');
    console.log(totalCount);
  });

// 6. Access-Control-Max-Age
// 预检请求的缓存时间（秒）
res.set('Access-Control-Max-Age', '86400');  // 24小时

// 在缓存时间内，浏览器不会再发送预检请求
```

**完整的CORS中间件实现**

```javascript
// Express CORS中间件
function corsMiddleware(options = {}) {
  const {
    origin = '*',
    methods = ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders = ['Content-Type', 'Authorization'],
    exposedHeaders = [],
    credentials = false,
    maxAge = 86400
  } = options;

  return (req, res, next) => {
    // 获取请求的origin
    const requestOrigin = req.headers.origin;

    // 设置Access-Control-Allow-Origin
    if (origin === '*') {
      res.set('Access-Control-Allow-Origin', '*');
    } else if (typeof origin === 'string') {
      res.set('Access-Control-Allow-Origin', origin);
    } else if (Array.isArray(origin)) {
      if (origin.includes(requestOrigin)) {
        res.set('Access-Control-Allow-Origin', requestOrigin);
        res.set('Vary', 'Origin');  // 告诉CDN缓存不同的origin
      }
    } else if (typeof origin === 'function') {
      const allowedOrigin = origin(requestOrigin);
      if (allowedOrigin) {
        res.set('Access-Control-Allow-Origin', requestOrigin);
        res.set('Vary', 'Origin');
      }
    }

    // 设置其他CORS头
    res.set('Access-Control-Allow-Methods', methods.join(', '));
    res.set('Access-Control-Allow-Headers', allowedHeaders.join(', '));

    if (exposedHeaders.length > 0) {
      res.set('Access-Control-Expose-Headers', exposedHeaders.join(', '));
    }

    if (credentials) {
      res.set('Access-Control-Allow-Credentials', 'true');
    }

    if (maxAge) {
      res.set('Access-Control-Max-Age', String(maxAge));
    }

    // 处理OPTIONS预检请求
    if (req.method === 'OPTIONS') {
      return res.sendStatus(204);
    }

    next();
  };
}

// 使用示例
const express = require('express');
const app = express();

// 基本用法
app.use(corsMiddleware({
  origin: 'https://example.com',
  credentials: true
}));

// 白名单
app.use(corsMiddleware({
  origin: ['https://example.com', 'https://app.example.com'],
  credentials: true
}));

// 动态判断
app.use(corsMiddleware({
  origin: (requestOrigin) => {
    // 验证origin是否合法
    const allowedDomains = ['.example.com', '.app.com'];
    return allowedDomains.some(domain => requestOrigin.endsWith(domain));
  },
  credentials: true
}));

// 针对特定路由
app.use('/api/public', corsMiddleware({ origin: '*' }));
app.use('/api/private', corsMiddleware({
  origin: 'https://example.com',
  credentials: true
}));
```

**CORS安全最佳实践**

```javascript
// 1. 不要使用 Access-Control-Allow-Origin: *
// ❌ 危险
res.set('Access-Control-Allow-Origin', '*');
res.set('Access-Control-Allow-Credentials', 'true');  // 无效，浏览器会拒绝

// ✓ 安全
const allowedOrigins = ['https://example.com'];
if (allowedOrigins.includes(req.headers.origin)) {
  res.set('Access-Control-Allow-Origin', req.headers.origin);
  res.set('Access-Control-Allow-Credentials', 'true');
}

// 2. 验证Origin头部
app.use((req, res, next) => {
  const origin = req.headers.origin;

  // 验证origin格式
  if (origin && !isValidOrigin(origin)) {
    return res.status(403).json({ error: 'Invalid origin' });
  }

  next();
});

function isValidOrigin(origin) {
  try {
    const url = new URL(origin);
    // 验证协议
    if (url.protocol !== 'https:' && url.protocol !== 'http:') {
      return false;
    }
    // 验证域名
    const allowedDomains = ['example.com', 'app.example.com'];
    return allowedDomains.includes(url.hostname);
  } catch (e) {
    return false;
  }
}

// 3. 限制允许的HTTP方法
// ❌ 过度开放
res.set('Access-Control-Allow-Methods', '*');

// ✓ 只允许需要的方法
res.set('Access-Control-Allow-Methods', 'GET, POST');

// 4. 限制允许的请求头
// ❌ 过度开放
res.set('Access-Control-Allow-Headers', '*');

// ✓ 明确指定
res.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');

// 5. 设置合理的预检缓存时间
// ✓ 24小时
res.set('Access-Control-Max-Age', '86400');

// 6. 使用HTTPS
// CORS应该配合HTTPS使用，防止中间人攻击

// 7. 日志记录
app.use((req, res, next) => {
  if (req.method === 'OPTIONS') {
    console.log('CORS Preflight:', {
      origin: req.headers.origin,
      method: req.headers['access-control-request-method'],
      headers: req.headers['access-control-request-headers']
    });
  }
  next();
});
```

**CORS常见问题和解决方案**

```javascript
// 问题1: 预检请求失败
// 错误: Access to fetch at 'xxx' has been blocked by CORS policy

// 解决: 确保服务器正确处理OPTIONS请求
app.options('*', (req, res) => {
  res.set('Access-Control-Allow-Origin', req.headers.origin);
  res.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.sendStatus(204);
});

// 问题2: credentials: 'include' 不生效
// 错误: The value of the 'Access-Control-Allow-Origin' header must not be '*'

// 解决: 不能使用通配符，必须指定具体的origin
// ❌ 错误
res.set('Access-Control-Allow-Origin', '*');
res.set('Access-Control-Allow-Credentials', 'true');

// ✓ 正确
res.set('Access-Control-Allow-Origin', req.headers.origin);
res.set('Access-Control-Allow-Credentials', 'true');

// 问题3: 自定义响应头无法访问
// 错误: 客户端无法读取X-Total-Count头部

// 解决: 使用Access-Control-Expose-Headers
res.set('Access-Control-Expose-Headers', 'X-Total-Count, X-Page-Number');

// 问题4: Nginx反向代理CORS配置
// Nginx配置
server {
    listen 80;
    server_name api.example.com;

    location /api/ {
        # 处理OPTIONS请求
        if ($request_method = 'OPTIONS') {
            add_header 'Access-Control-Allow-Origin' '$http_origin' always;
            add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
            add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization' always;
            add_header 'Access-Control-Allow-Credentials' 'true' always;
            add_header 'Access-Control-Max-Age' 86400 always;
            return 204;
        }

        # 添加CORS头
        add_header 'Access-Control-Allow-Origin' '$http_origin' always;
        add_header 'Access-Control-Allow-Credentials' 'true' always;

        proxy_pass http://backend;
    }
}

// 问题5: 多次设置CORS头
// 错误: The 'Access-Control-Allow-Origin' header contains multiple values

// 原因: Nginx和后端都设置了CORS头
// 解决: 只在一个地方设置（推荐在后端设置）

// Nginx配置（移除后端的CORS头）
proxy_hide_header Access-Control-Allow-Origin;
proxy_hide_header Access-Control-Allow-Credentials;
add_header 'Access-Control-Allow-Origin' '$http_origin' always;
add_header 'Access-Control-Allow-Credentials' 'true' always;
```

**CORS调试技巧**

```javascript
// 1. Chrome DevTools Network面板
// 查看预检请求（OPTIONS）
// 查看响应头是否包含CORS头

// 2. 命令行测试
// 测试简单请求
curl -H "Origin: https://example.com" \
     -H "Access-Control-Request-Method: GET" \
     -H "Access-Control-Request-Headers: X-Custom-Header" \
     -X OPTIONS \
     https://api.example.com/data

// 3. CORS测试工具
// 在浏览器控制台测试
fetch('https://api.example.com/data', {
  method: 'GET',
  headers: {
    'Content-Type': 'application/json'
  },
  credentials: 'include'
})
  .then(response => {
    console.log('Success:', response);
    // 检查可访问的响应头
    console.log('Headers:', response.headers.get('X-Total-Count'));
  })
  .catch(error => {
    console.error('CORS Error:', error);
  });

// 4. 日志中间件
app.use((req, res, next) => {
  console.log('Request:', {
    method: req.method,
    url: req.url,
    origin: req.headers.origin,
    referer: req.headers.referer
  });

  const originalSend = res.send;
  res.send = function(data) {
    console.log('Response Headers:', res.getHeaders());
    originalSend.call(this, data);
  };

  next();
});
```

## 2. XSS攻击
**问题：** XSS（Cross-Site Scripting）跨站脚本攻击

### 解答

#### XSS类型

**1. 存储型XSS**
```javascript
// 攻击者提交恶意脚本到数据库
const comment = '<script>alert("XSS")</script>';
db.save({ comment });

// 其他用户访问时执行
<div>{{ comment }}</div>  // 危险！
```

**2. 反射型XSS**
```javascript
// 恶意链接
http://example.com/search?q=<script>alert('XSS')</script>

// 服务器直接返回
<div>搜索结果：{{ query }}</div>  // 危险！
```

**3. DOM型XSS**
```javascript
// URL
http://example.com#<script>alert('XSS')</script>

// JavaScript处理
document.getElementById('content').innerHTML = location.hash;  // 危险！
```

#### 防御措施

**1. 输入验证和过滤**
```javascript
// 白名单验证
function validateInput(input) {
  const pattern = /^[a-zA-Z0-9_]+$/;
  return pattern.test(input);
}

// 黑名单过滤（不推荐）
function filterInput(input) {
  return input.replace(/<script>/gi, '');
}
```

**2. 输出编码**
```javascript
// HTML编码
function escapeHtml(str) {
  const map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '/': '&#x2F;'
  };
  return str.replace(/[&<>"'/]/g, char => map[char]);
}

// 使用
const userInput = '<script>alert("XSS")</script>';
const safe = escapeHtml(userInput);
// &lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;

// React自动转义
<div>{userInput}</div>  // 安全

// Vue自动转义
<div>{{ userInput }}</div>  // 安全

// 危险用法
<div dangerouslySetInnerHTML={{ __html: userInput }} />  // ❌
<div v-html="userInput"></div>  // ❌
```

**3. Content Security Policy（CSP）深入**

#### CSP基本概念

```javascript
// CSP是一种额外的安全层，用于检测并减轻某些类型的攻击
// 主要防御：XSS、数据注入攻击、点击劫持

// CSP工作原理：
// 1. 服务器通过HTTP响应头发送CSP策略
// 2. 浏览器执行CSP策略，阻止违规内容
// 3. 可选择将违规行为上报到指定URL

// 设置方式：
// 1. HTTP响应头（推荐）
Content-Security-Policy: default-src 'self'

// 2. HTML meta标签（功能有限）
<meta http-equiv="Content-Security-Policy" content="default-src 'self'">
```

#### CSP指令详解

```javascript
// 1. default-src：所有资源的默认策略
Content-Security-Policy: default-src 'self'
// 只允许从同源加载资源

// 2. script-src：JavaScript源
// ✓ 最严格
Content-Security-Policy: script-src 'self'

// ✓ 允许内联脚本（不推荐）
Content-Security-Policy: script-src 'self' 'unsafe-inline'

// ✓ 允许eval（不推荐）
Content-Security-Policy: script-src 'self' 'unsafe-eval'

// ✓ 使用nonce（推荐）
Content-Security-Policy: script-src 'self' 'nonce-random123'
<script nonce="random123">
  // 只有带正确nonce的脚本才能执行
  console.log('Allowed');
</script>

// ✓ 使用hash（适用于静态脚本）
Content-Security-Policy: script-src 'self' 'sha256-abc123...'
<script>
  console.log('This script'); // 计算sha256 hash
</script>

// 3. style-src：CSS源
Content-Security-Policy: style-src 'self' 'unsafe-inline'

// 4. img-src：图片源
Content-Security-Policy: img-src 'self' data: https:

// 5. font-src：字体源
Content-Security-Policy: font-src 'self' https://fonts.gstatic.com

// 6. connect-src：XHR、WebSocket、EventSource
Content-Security-Policy: connect-src 'self' https://api.example.com

// 7. media-src：音视频源
Content-Security-Policy: media-src 'self' https://media.example.com

// 8. object-src：<object>、<embed>、<applet>
Content-Security-Policy: object-src 'none'

// 9. frame-src：iframe源
Content-Security-Policy: frame-src 'self' https://trusted.com

// 10. frame-ancestors：可以嵌入此页面的源（防止点击劫持）
Content-Security-Policy: frame-ancestors 'none'  // 禁止被嵌入
Content-Security-Policy: frame-ancestors 'self'  // 只允许同源嵌入

// 11. base-uri：限制<base>标签
Content-Security-Policy: base-uri 'self'

// 12. form-action：限制表单提交目标
Content-Security-Policy: form-action 'self'

// 13. upgrade-insecure-requests：自动升级HTTP到HTTPS
Content-Security-Policy: upgrade-insecure-requests

// 14. block-all-mixed-content：阻止混合内容
Content-Security-Policy: block-all-mixed-content
```

#### CSP源值（Source Values）

```javascript
// 1. 'none'：不允许任何源
Content-Security-Policy: object-src 'none'

// 2. 'self'：同源
Content-Security-Policy: script-src 'self'

// 3. 'unsafe-inline'：允许内联（不推荐）
Content-Security-Policy: style-src 'self' 'unsafe-inline'

// 4. 'unsafe-eval'：允许eval（不推荐）
Content-Security-Policy: script-src 'self' 'unsafe-eval'

// 5. 'strict-dynamic'：信任动态加载的脚本
Content-Security-Policy: script-src 'strict-dynamic' 'nonce-random123'

// 6. 'nonce-<value>'：随机数
Content-Security-Policy: script-src 'nonce-random123'

// 7. 'sha256-<hash>'：脚本hash
Content-Security-Policy: script-src 'sha256-abc123...'

// 8. 具体域名
Content-Security-Policy: script-src https://cdn.example.com

// 9. 通配符
Content-Security-Policy: img-src https://*.example.com

// 10. 协议
Content-Security-Policy: img-src https: data:
```

#### 完整的CSP配置示例

```javascript
// Express + Helmet
const helmet = require('helmet');

app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'self'"],

    // JavaScript
    scriptSrc: [
      "'self'",
      "'unsafe-inline'",  // 如果无法避免内联脚本
      "https://cdn.example.com",
      "https://www.google-analytics.com"
    ],

    // CSS
    styleSrc: [
      "'self'",
      "'unsafe-inline'",  // 如果使用内联样式
      "https://fonts.googleapis.com"
    ],

    // 图片
    imgSrc: [
      "'self'",
      "data:",  // base64图片
      "https:",  // 所有HTTPS图片
      "blob:"
    ],

    // 字体
    fontSrc: [
      "'self'",
      "https://fonts.gstatic.com"
    ],

    // XHR/Fetch
    connectSrc: [
      "'self'",
      "https://api.example.com",
      "wss://ws.example.com"
    ],

    // iframe
    frameSrc: [
      "'self'",
      "https://www.youtube.com"
    ],

    // 禁止被嵌入iframe
    frameAncestors: ["'none'"],

    // object/embed
    objectSrc: ["'none'"],

    // 表单提交
    formAction: ["'self'"],

    // base标签
    baseUri: ["'self'"],

    // 升级不安全请求
    upgradeInsecureRequests: []
  },

  // 上报违规
  reportUri: '/csp-violation-report'
}));

// 接收CSP违规报告
app.post('/csp-violation-report', express.json(), (req, res) => {
  console.log('CSP Violation:', req.body);

  // 记录违规信息
  const violation = req.body['csp-report'];
  console.log({
    documentUri: violation['document-uri'],
    blockedUri: violation['blocked-uri'],
    violatedDirective: violation['violated-directive'],
    effectiveDirective: violation['effective-directive'],
    sourceFile: violation['source-file'],
    lineNumber: violation['line-number']
  });

  res.sendStatus(204);
});
```

#### 使用nonce的最佳实践

```javascript
// 服务器端生成nonce
const crypto = require('crypto');

function generateNonce() {
  return crypto.randomBytes(16).toString('base64');
}

app.use((req, res, next) => {
  // 为每个请求生成唯一的nonce
  res.locals.nonce = generateNonce();

  // 设置CSP头
  res.set('Content-Security-Policy',
    `script-src 'self' 'nonce-${res.locals.nonce}'; ` +
    `style-src 'self' 'nonce-${res.locals.nonce}'`
  );

  next();
});

app.get('/', (req, res) => {
  const nonce = res.locals.nonce;

  res.send(`
    <!DOCTYPE html>
    <html>
      <head>
        <style nonce="${nonce}">
          body { color: red; }
        </style>
      </head>
      <body>
        <script nonce="${nonce}">
          console.log('Allowed script');
        </script>

        <!-- 没有nonce的脚本会被阻止 -->
        <script>
          console.log('Blocked script');
        </script>
      </body>
    </html>
  `);
});

// React中使用nonce
// 1. 在HTML模板中注入nonce
<!DOCTYPE html>
<html>
  <head>
    <script nonce="<%= nonce %>">
      window.__NONCE__ = '<%= nonce %>';
    </script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>

// 2. 在React中使用nonce
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));

// 动态插入脚本时使用nonce
const script = document.createElement('script');
script.nonce = window.__NONCE__;
script.src = 'https://cdn.example.com/lib.js';
document.head.appendChild(script);
```

#### CSP报告模式（Report-Only）

```javascript
// Report-Only模式：只报告违规，不阻止
// 适用于测试CSP策略

app.use((req, res, next) => {
  res.set('Content-Security-Policy-Report-Only',
    "default-src 'self'; " +
    "script-src 'self' https://cdn.example.com; " +
    "report-uri /csp-violation-report"
  );
  next();
});

// 接收并分析违规报告
const violations = [];

app.post('/csp-violation-report', express.json(), (req, res) => {
  const report = req.body['csp-report'];

  violations.push({
    timestamp: new Date(),
    blockedUri: report['blocked-uri'],
    violatedDirective: report['violated-directive'],
    sourceFile: report['source-file'],
    lineNumber: report['line-number'],
    userAgent: req.headers['user-agent']
  });

  // 分析违规模式
  analyzeViolations();

  res.sendStatus(204);
});

function analyzeViolations() {
  // 统计最常见的违规
  const stats = violations.reduce((acc, v) => {
    const key = v.violatedDirective;
    acc[key] = (acc[key] || 0) + 1;
    return acc;
  }, {});

  console.log('Violation Statistics:', stats);
}

// 逐步加强CSP
// 1. 开始使用Report-Only模式
// 2. 分析违规报告
// 3. 修复代码中的违规
// 4. 切换到强制模式
```

#### CSP与第三方脚本

```javascript
// 问题：第三方脚本通常需要unsafe-inline和unsafe-eval
// 解决方案：

// 1. 使用nonce加载第三方脚本
<script nonce="random123" src="https://www.google-analytics.com/analytics.js"></script>

// 2. 为特定第三方服务添加域名
Content-Security-Policy:
  script-src 'self'
    https://www.google-analytics.com
    https://www.googletagmanager.com;
  connect-src 'self'
    https://www.google-analytics.com;

// 3. 使用严格动态（strict-dynamic）
Content-Security-Policy:
  script-src 'strict-dynamic' 'nonce-random123'

// strict-dynamic的行为：
// - 信任有nonce的脚本
// - 信任这些脚本动态加载的脚本
// - 忽略白名单和unsafe-inline

<script nonce="random123">
  // 这个脚本被信任
  const script = document.createElement('script');
  script.src = 'https://third-party.com/lib.js';
  document.head.appendChild(script);
  // 动态加载的脚本也被信任
</script>

// 4. 使用子资源完整性（SRI）
<script
  src="https://cdn.example.com/lib.js"
  integrity="sha384-abc123..."
  crossorigin="anonymous">
</script>

Content-Security-Policy:
  script-src 'self'
    'sha384-abc123...'
```

#### CSP最佳实践

```javascript
// 1. 从严格策略开始
Content-Security-Policy: default-src 'none'

// 2. 逐步放宽
Content-Security-Policy:
  default-src 'self';
  script-src 'self' https://cdn.example.com;
  style-src 'self' 'unsafe-inline';

// 3. 避免unsafe-inline和unsafe-eval
// ❌ 不安全
Content-Security-Policy: script-src 'self' 'unsafe-inline' 'unsafe-eval'

// ✓ 安全
Content-Security-Policy: script-src 'self' 'nonce-random123'

// 4. 使用strict-dynamic（现代浏览器）
Content-Security-Policy:
  script-src 'strict-dynamic' 'nonce-random123' 'unsafe-inline' https:;
  // unsafe-inline和https: 是为了向后兼容

// 5. 防止点击劫持
Content-Security-Policy: frame-ancestors 'none'
// 或配合X-Frame-Options
X-Frame-Options: DENY

// 6. 升级不安全请求
Content-Security-Policy: upgrade-insecure-requests

// 7. 使用Report-Only测试
Content-Security-Policy-Report-Only:
  default-src 'self';
  report-uri /csp-violation-report

// 8. 监控违规报告
app.post('/csp-violation-report', (req, res) => {
  // 发送到日志系统
  logger.warn('CSP Violation', req.body['csp-report']);

  // 发送到监控系统
  monitoring.track('csp_violation', {
    blockedUri: req.body['csp-report']['blocked-uri'],
    violatedDirective: req.body['csp-report']['violated-directive']
  });

  res.sendStatus(204);
});

// 9. Nginx配置CSP
server {
    listen 443 ssl http2;
    server_name example.com;

    # CSP头部
    add_header Content-Security-Policy
        "default-src 'self';
         script-src 'self' https://cdn.example.com;
         style-src 'self' 'unsafe-inline';
         img-src 'self' data: https:;
         font-src 'self' https://fonts.gstatic.com;
         connect-src 'self' https://api.example.com;
         frame-ancestors 'none';
         base-uri 'self';
         form-action 'self'"
        always;

    # 子资源完整性
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-Frame-Options "DENY" always;
    add_header X-XSS-Protection "1; mode=block" always;
}
```

#### CSP调试

```javascript
// 1. Chrome DevTools Console
// 查看CSP违规错误
// Refused to load the script 'xxx' because it violates the following
// Content Security Policy directive: "script-src 'self'"

// 2. 使用CSP Evaluator（Google）
// https://csp-evaluator.withgoogle.com/

// 3. 浏览器扩展
// CSP Mitigator for Chrome

// 4. 生成脚本hash
const crypto = require('crypto');

function generateHash(script) {
  return crypto
    .createHash('sha256')
    .update(script)
    .digest('base64');
}

const script = "console.log('Hello')";
const hash = generateHash(script);
console.log(`'sha256-${hash}'`);
// 'sha256-abc123...'

// 5. 测试工具
// 验证CSP配置
function testCSP() {
  // 尝试执行内联脚本
  const script = document.createElement('script');
  script.textContent = "console.log('Test inline script')";
  document.body.appendChild(script);

  // 尝试eval
  try {
    eval("console.log('Test eval')");
  } catch (e) {
    console.log('eval被CSP阻止');
  }

  // 尝试加载外部脚本
  const externalScript = document.createElement('script');
  externalScript.src = 'https://example.com/test.js';
  document.body.appendChild(externalScript);
}
```

**4. HTTPOnly Cookie**
```javascript
// 设置HTTPOnly，防止JavaScript访问cookie
res.cookie('session', sessionId, {
  httpOnly: true,
  secure: true,  // 只在HTTPS下传输
  sameSite: 'strict'
});
```

**5. 使用安全库**
```javascript
// DOMPurify
import DOMPurify from 'dompurify';

const dirty = '<script>alert("XSS")</script><p>Hello</p>';
const clean = DOMPurify.sanitize(dirty);
// <p>Hello</p>

// js-xss
const xss = require('xss');

const html = xss('<script>alert("XSS")</script><a href="javascript:alert()">link</a>');
// <a href="#">link</a>
```

## 3. CSRF攻击
**问题：** CSRF（Cross-Site Request Forgery）跨站请求伪造

### 解答

#### CSRF攻击原理

```
1. 用户登录 bank.com，获得cookie
2. 用户访问 evil.com（恶意网站）
3. evil.com发送请求到 bank.com/transfer
4. 浏览器自动携带 bank.com 的cookie
5. 转账成功
```

```html
<!-- 恶意网站的攻击代码 -->
<img src="http://bank.com/transfer?to=attacker&amount=1000">

<form action="http://bank.com/transfer" method="POST">
  <input type="hidden" name="to" value="attacker">
  <input type="hidden" name="amount" value="1000">
</form>
<script>document.forms[0].submit()</script>
```

#### 防御措施

**1. CSRF Token**
```javascript
// 服务器生成token
const csrf = require('csurf');
const csrfProtection = csrf({ cookie: true });

app.use(csrfProtection);

app.get('/form', (req, res) => {
  res.render('form', { csrfToken: req.csrfToken() });
});

app.post('/submit', (req, res) => {
  // 自动验证token
  res.send('success');
});
```

```html
<!-- 前端使用token -->
<form action="/submit" method="POST">
  <input type="hidden" name="_csrf" value="<%= csrfToken %>">
  <button type="submit">Submit</button>
</form>

<!-- AJAX请求 -->
<script>
fetch('/api/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'CSRF-Token': csrfToken
  },
  body: JSON.stringify(data)
});
</script>
```

**2. SameSite Cookie**
```javascript
// 设置SameSite属性
res.cookie('session', sessionId, {
  httpOnly: true,
  secure: true,
  sameSite: 'strict'  // 或 'lax'
});
```

**SameSite属性值：**
- `Strict`: 完全禁止第三方Cookie
- `Lax`: 允许部分第三方Cookie（GET请求）
- `None`: 允许所有第三方Cookie（需要配合Secure）

**3. 验证Referer/Origin**
```javascript
app.use((req, res, next) => {
  const referer = req.headers.referer;
  const origin = req.headers.origin;

  if (referer && !referer.startsWith('http://example.com')) {
    return res.status(403).send('Forbidden');
  }

  if (origin && origin !== 'http://example.com') {
    return res.status(403).send('Forbidden');
  }

  next();
});
```

**4. 双重Cookie验证**
```javascript
// 1. 设置cookie
res.cookie('csrf_cookie', csrfToken);

// 2. 要求请求携带相同值
app.post('/api/data', (req, res) => {
  const cookieToken = req.cookies.csrf_cookie;
  const headerToken = req.headers['x-csrf-token'];

  if (cookieToken !== headerToken) {
    return res.status(403).send('CSRF token mismatch');
  }

  // 处理请求
});
```

**5. 自定义请求头**
```javascript
// AJAX请求添加自定义头
fetch('/api/data', {
  method: 'POST',
  headers: {
    'X-Requested-With': 'XMLHttpRequest',
    'X-Custom-Header': 'value'
  }
});

// 服务器验证
app.use((req, res, next) => {
  if (!req.headers['x-requested-with']) {
    return res.status(403).send('Invalid request');
  }
  next();
});
```

## 4. SQL注入
**问题：** SQL注入攻击及防御

### 解答

#### SQL注入原理

```javascript
// 危险的SQL拼接
const username = req.body.username;
const password = req.body.password;

const sql = `SELECT * FROM users WHERE username='${username}' AND password='${password}'`;

// 攻击者输入：
// username: admin' --
// password: anything

// 实际执行的SQL：
// SELECT * FROM users WHERE username='admin' --' AND password='anything'
// -- 是注释，后面的密码验证被忽略
```

#### 防御措施

**1. 参数化查询（推荐）**
```javascript
// Node.js + MySQL
const mysql = require('mysql2/promise');

// ✅ 使用参数化查询
const [rows] = await connection.execute(
  'SELECT * FROM users WHERE username = ? AND password = ?',
  [username, password]
);

// MongoDB
// ✅ 使用参数化查询
const user = await User.findOne({
  username: username,
  password: password
});

// PostgreSQL
// ✅ 使用参数化查询
const result = await client.query(
  'SELECT * FROM users WHERE username = $1 AND password = $2',
  [username, password]
);
```

**2. ORM/ODM（对象关系映射）**
```javascript
// Sequelize（ORM）
const User = require('./models/user');

// ✅ 安全的查询
const user = await User.findOne({
  where: {
    username: username,
    password: password
  }
});

// Mongoose（ODM）
const User = require('./models/user');

// ✅ 安全的查询
const user = await User.findOne({
  username: username,
  password: password
});
```

**3. 输入验证**
```javascript
// 白名单验证
function validateUsername(username) {
  const pattern = /^[a-zA-Z0-9_]{3,20}$/;
  if (!pattern.test(username)) {
    throw new Error('Invalid username');
  }
  return username;
}

// 类型验证
function validateId(id) {
  const numId = parseInt(id, 10);
  if (isNaN(numId) || numId <= 0) {
    throw new Error('Invalid ID');
  }
  return numId;
}

// 使用
const username = validateUsername(req.body.username);
const id = validateId(req.params.id);
```

**4. 转义特殊字符**
```javascript
const mysql = require('mysql2');

// ✅ 使用mysql.escape()
const username = mysql.escape(req.body.username);
const sql = `SELECT * FROM users WHERE username=${username}`;

// ✅ 使用mysql.escapeId()转义标识符
const table = mysql.escapeId(req.body.table);
const sql = `SELECT * FROM ${table}`;
```

**5. 最小权限原则**
```sql
-- 创建只读用户
CREATE USER 'readonly'@'localhost' IDENTIFIED BY 'password';
GRANT SELECT ON database.* TO 'readonly'@'localhost';

-- 不要使用root用户连接数据库
```

**6. 错误信息处理**
```javascript
// ❌ 暴露详细错误
app.use((err, req, res, next) => {
  res.status(500).json({ error: err.message });
});

// ✅ 隐藏详细错误
app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).json({ error: 'Internal Server Error' });
});
```

## 5. 其他安全问题

### 点击劫持（Clickjacking）
```javascript
// 防御：X-Frame-Options
app.use((req, res, next) => {
  res.setHeader('X-Frame-Options', 'DENY');  // 禁止嵌入iframe
  // 或
  res.setHeader('X-Frame-Options', 'SAMEORIGIN');  // 只允许同源
  next();
});

// 或使用CSP
res.setHeader('Content-Security-Policy', "frame-ancestors 'none'");
```

### 中间人攻击（MITM）
```javascript
// 防御：使用HTTPS
const https = require('https');
const fs = require('fs');

const options = {
  key: fs.readFileSync('key.pem'),
  cert: fs.readFileSync('cert.pem')
};

https.createServer(options, app).listen(443);

// 强制HTTPS
app.use((req, res, next) => {
  if (!req.secure) {
    return res.redirect(`https://${req.headers.host}${req.url}`);
  }
  next();
});

// HSTS
app.use((req, res, next) => {
  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
  next();
});
```

### 敏感信息泄露
```javascript
// 1. 不要在前端存储敏感信息
// ❌
localStorage.setItem('password', password);
localStorage.setItem('creditCard', cardNumber);

// ✅ 只存储token
localStorage.setItem('token', accessToken);

// 2. 使用环境变量
// .env
API_KEY=secret123
DATABASE_URL=mongodb://localhost/db

// .gitignore
.env

// 3. 日志脱敏
function sanitizeLog(data) {
  const sensitiveFields = ['password', 'token', 'creditCard'];
  const sanitized = { ...data };

  sensitiveFields.forEach(field => {
    if (sanitized[field]) {
      sanitized[field] = '***';
    }
  });

  return sanitized;
}

console.log(sanitizeLog(userData));
```
