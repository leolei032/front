# 浏览器原理

## 1. 浏览器渲染流程
**问题：** 浏览器的渲染流程

**考察要点：** 浏览器从输入URL到页面展示的完整流程，DOM树、CSSOM树、渲染树的构建过程

### 解答

#### 完整渲染流程

```
1. URL输入
   ↓
2. DNS解析
   ↓
3. TCP连接（三次握手）
   ↓
4. 发送HTTP请求
   ↓
5. 服务器处理并返回响应
   ↓
6. 浏览器解析HTML
   ↓
7. 构建DOM树
   ↓
8. 解析CSS，构建CSSOM树
   ↓
9. 合并DOM和CSSOM，生成渲染树（Render Tree）
   ↓
10. 布局（Layout/Reflow）- 计算元素位置和大小
   ↓
11. 绘制（Paint）- 绘制像素
   ↓
12. 合成（Composite）- 合成图层
   ↓
13. 显示页面
```

#### 详细步骤

**1. 解析HTML构建DOM树**
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Page</title>
  </head>
  <body>
    <div>Hello</div>
  </body>
</html>
```

```javascript
// DOM树结构
Document
  └── html
      ├── head
      │   └── title
      │       └── "Page"
      └── body
          └── div
              └── "Hello"
```

**2. 解析CSS构建CSSOM树**
```css
body { font-size: 16px; }
div { color: red; }
```

```javascript
// CSSOM树结构
CSSOM
  └── body { font-size: 16px }
      └── div { color: red }
```

**3. 合并生成渲染树**
```javascript
// 渲染树（只包含可见元素）
RenderTree
  └── RenderBody { font-size: 16px }
      └── RenderDiv { color: red }
          └── RenderText "Hello"

// 注意：display: none 的元素不在渲染树中
// visibility: hidden 的元素在渲染树中
```

**4. 布局（Layout）**
```javascript
// 计算每个节点的几何信息
{
  element: 'div',
  position: { x: 10, y: 10 },
  size: { width: 200, height: 50 },
  box: {
    content: { width: 200, height: 50 },
    padding: { top: 0, right: 0, bottom: 0, left: 0 },
    border: { top: 0, right: 0, bottom: 0, left: 0 },
    margin: { top: 0, right: 0, bottom: 0, left: 0 }
  }
}
```

**5. 绘制（Paint）**
```javascript
// 将渲染树的每个节点转换为屏幕上的实际像素
// 绘制顺序：
1. background-color
2. background-image
3. border
4. children
5. outline
```

**6. 合成（Composite）**
```javascript
// 将多个图层合成最终的页面
// GPU加速的属性：
- transform
- opacity
- filter
- will-change
```

#### 关键性能指标

**FP (First Paint)** - 首次绘制
```javascript
performance.getEntriesByType('paint').forEach(entry => {
  if (entry.name === 'first-paint') {
    console.log('FP:', entry.startTime);
  }
});
```

**FCP (First Contentful Paint)** - 首次内容绘制
```javascript
performance.getEntriesByType('paint').forEach(entry => {
  if (entry.name === 'first-contentful-paint') {
    console.log('FCP:', entry.startTime);
  }
});
```

**LCP (Largest Contentful Paint)** - 最大内容绘制
```javascript
new PerformanceObserver((list) => {
  const entries = list.getEntries();
  const lastEntry = entries[entries.length - 1];
  console.log('LCP:', lastEntry.renderTime || lastEntry.loadTime);
}).observe({ entryTypes: ['largest-contentful-paint'] });
```

#### 优化建议

**1. 减少关键资源**
```html
<!-- 内联关键CSS -->
<style>
  /* 首屏关键CSS */
  .header { display: flex; }
</style>

<!-- 异步加载非关键CSS -->
<link rel="preload" href="style.css" as="style" onload="this.rel='stylesheet'">
```

**2. 减少渲染阻塞**
```html
<!-- 异步脚本 -->
<script async src="analytics.js"></script>

<!-- 延迟脚本 -->
<script defer src="app.js"></script>
```

**3. 优化关键渲染路径**
```html
<!-- DNS预解析 -->
<link rel="dns-prefetch" href="//cdn.example.com">

<!-- 预连接 -->
<link rel="preconnect" href="//api.example.com">

<!-- 预加载关键资源 -->
<link rel="preload" href="font.woff2" as="font" crossorigin>
```

## 2. 重排（Reflow）和重绘（Repaint）
**问题：** 什么是重排和重绘？如何避免？

**考察要点：** 理解浏览器渲染机制，掌握性能优化技巧

### 解答

#### 重排（Reflow）

**定义：** 当元素的几何属性（位置、尺寸）发生变化时，浏览器需要重新计算元素的几何信息，并重新构建渲染树。

**触发重排的操作：**
```javascript
// 1. 添加/删除可见DOM元素
document.body.appendChild(div);
parent.removeChild(child);

// 2. 修改元素位置
element.style.left = '100px';
element.style.top = '100px';

// 3. 修改元素尺寸
element.style.width = '200px';
element.style.height = '100px';
element.style.padding = '10px';
element.style.margin = '5px';
element.style.border = '1px solid red';

// 4. 修改内容
element.textContent = 'New text';

// 5. 修改字体
element.style.fontSize = '20px';

// 6. 读取某些属性（会强制浏览器重排以获取最新值）
const height = element.offsetHeight;
const width = element.offsetWidth;
const top = element.offsetTop;
const left = element.offsetLeft;
const scrollTop = element.scrollTop;
const scrollHeight = element.scrollHeight;
const clientHeight = element.clientHeight;
const clientWidth = element.clientWidth;
element.getBoundingClientRect();
window.getComputedStyle(element);

// 7. 改变窗口大小
window.addEventListener('resize', handler);
```

#### 重绘（Repaint）

**定义：** 当元素的外观（颜色、背景）发生变化，但不影响布局时，浏览器会重新绘制元素。

**触发重绘的操作：**
```javascript
// 修改颜色
element.style.color = 'red';
element.style.backgroundColor = 'blue';

// 修改边框颜色
element.style.borderColor = 'green';

// 修改可见性
element.style.visibility = 'hidden';  // 重绘
element.style.display = 'none';       // 重排+重绘

// 修改轮廓
element.style.outline = '1px solid red';
```

#### 性能对比

```
重排（Reflow）> 重绘（Repaint）> 合成（Composite）
```

- **重排**：最耗性能，需要重新计算布局
- **重绘**：中等性能消耗，只需要重新绘制
- **合成**：性能最好，GPU加速

#### 避免重排和重绘

**1. 批量修改样式**
```javascript
// ❌ 多次重排
element.style.width = '100px';
element.style.height = '100px';
element.style.margin = '10px';

// ✅ 一次重排
element.style.cssText = 'width: 100px; height: 100px; margin: 10px;';

// ✅ 使用class
element.className = 'new-style';
```

**2. 批量修改DOM**
```javascript
// ❌ 多次重排
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  document.body.appendChild(div);
}

// ✅ 一次重排（使用文档片段）
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  fragment.appendChild(div);
}
document.body.appendChild(fragment);

// ✅ 使用innerHTML
const html = Array.from({ length: 1000 }, (_, i) => `<div>${i}</div>`).join('');
document.body.innerHTML = html;
```

**3. 缓存布局信息**
```javascript
// ❌ 强制同步布局
for (let i = 0; i < elements.length; i++) {
  elements[i].style.width = container.offsetWidth + 'px';  // 每次都读取
}

// ✅ 缓存布局信息
const width = container.offsetWidth;
for (let i = 0; i < elements.length; i++) {
  elements[i].style.width = width + 'px';
}
```

**4. 脱离文档流**
```javascript
// ✅ 使用absolute/fixed
element.style.position = 'absolute';
// 修改样式...
element.style.position = 'static';

// ✅ 隐藏元素
element.style.display = 'none';
// 修改样式...
element.style.display = 'block';
```

**5. 使用transform代替定位**
```css
/* ❌ 触发重排 */
.element {
  position: absolute;
  left: 100px;
  top: 100px;
}

/* ✅ 只触发合成 */
.element {
  transform: translate(100px, 100px);
}
```

**6. 使用requestAnimationFrame**
```javascript
// ❌ 多次重排
function animate() {
  element.style.left = left + 'px';
  left += 1;
  setTimeout(animate, 16);
}

// ✅ 浏览器优化的时机
function animate() {
  element.style.transform = `translateX(${left}px)`;
  left += 1;
  requestAnimationFrame(animate);
}
```

**7. 使用CSS3动画**
```css
/* ✅ GPU加速，不触发重排 */
.element {
  transition: transform 0.3s;
  will-change: transform;
}

.element:hover {
  transform: translateX(100px);
}
```

**8. 虚拟列表**
```javascript
// 只渲染可见区域
import { FixedSizeList } from 'react-window';

<FixedSizeList
  height={600}
  itemCount={1000}
  itemSize={50}
>
  {({ index, style }) => (
    <div style={style}>Item {index}</div>
  )}
</FixedSizeList>
```

## 3. 浏览器事件机制
**问题：** 浏览器的事件捕获和冒泡

**考察要点：** 事件流、事件委托、阻止冒泡

### 解答

#### 事件流三个阶段

```
1. 捕获阶段（Capture Phase）
   ↓
2. 目标阶段（Target Phase）
   ↓
3. 冒泡阶段（Bubble Phase）
```

```html
<div id="outer">
  <div id="middle">
    <div id="inner">Click me</div>
  </div>
</div>
```

```javascript
// 点击inner时的事件流：
1. 捕获：window → document → html → body → outer → middle → inner
2. 目标：inner
3. 冒泡：inner → middle → outer → body → html → document → window
```

#### 事件监听

**addEventListener第三个参数**
```javascript
element.addEventListener(type, listener, options);

// options可以是：
// 1. Boolean - true表示捕获，false表示冒泡（默认）
element.addEventListener('click', handler, true);   // 捕获阶段
element.addEventListener('click', handler, false);  // 冒泡阶段

// 2. Object
element.addEventListener('click', handler, {
  capture: false,  // 是否捕获
  once: true,      // 只执行一次
  passive: true    // 不会调用preventDefault
});
```

**示例：捕获和冒泡**
```javascript
const outer = document.getElementById('outer');
const middle = document.getElementById('middle');
const inner = document.getElementById('inner');

// 冒泡阶段监听
outer.addEventListener('click', () => console.log('outer bubble'), false);
middle.addEventListener('click', () => console.log('middle bubble'), false);
inner.addEventListener('click', () => console.log('inner bubble'), false);

// 捕获阶段监听
outer.addEventListener('click', () => console.log('outer capture'), true);
middle.addEventListener('click', () => console.log('middle capture'), true);
inner.addEventListener('click', () => console.log('inner capture'), true);

// 点击inner输出：
// outer capture
// middle capture
// inner capture
// inner bubble
// middle bubble
// outer bubble
```

#### 阻止冒泡

**stopPropagation()**
```javascript
inner.addEventListener('click', (e) => {
  console.log('inner clicked');
  e.stopPropagation();  // 阻止冒泡
});

// 点击inner后，不会触发middle和outer的事件
```

**stopImmediatePropagation()**
```javascript
inner.addEventListener('click', (e) => {
  console.log('handler 1');
  e.stopImmediatePropagation();  // 阻止后续所有事件
});

inner.addEventListener('click', (e) => {
  console.log('handler 2');  // 不会执行
});
```

#### 阻止默认行为

```javascript
// 阻止链接跳转
link.addEventListener('click', (e) => {
  e.preventDefault();
  console.log('不会跳转');
});

// 阻止表单提交
form.addEventListener('submit', (e) => {
  e.preventDefault();
  // 自定义提交逻辑
});

// 阻止右键菜单
document.addEventListener('contextmenu', (e) => {
  e.preventDefault();
});
```

#### 事件委托

**原理：** 利用事件冒泡，将事件监听器绑定在父元素上。

**优点：**
- 减少内存消耗
- 动态元素也能响应事件

```javascript
// ❌ 为每个li绑定事件
const items = document.querySelectorAll('li');
items.forEach(item => {
  item.addEventListener('click', handleClick);
});

// ✅ 事件委托
const list = document.getElementById('list');
list.addEventListener('click', (e) => {
  if (e.target.tagName === 'LI') {
    handleClick(e.target);
  }
});

// 更好的实现
function delegate(element, eventType, selector, handler) {
  element.addEventListener(eventType, (e) => {
    let target = e.target;

    // 向上查找匹配的元素
    while (target && target !== element) {
      if (target.matches(selector)) {
        handler.call(target, e);
        break;
      }
      target = target.parentElement;
    }
  });
}

// 使用
delegate(list, 'click', 'li', function(e) {
  console.log('clicked:', this.textContent);
});
```

#### 自定义事件

```javascript
// 创建自定义事件
const event = new CustomEvent('myevent', {
  detail: { message: 'Hello' },
  bubbles: true,
  cancelable: true
});

// 监听自定义事件
element.addEventListener('myevent', (e) => {
  console.log(e.detail.message);
});

// 触发自定义事件
element.dispatchEvent(event);

// 使用Event构造函数
const clickEvent = new MouseEvent('click', {
  bubbles: true,
  cancelable: true,
  clientX: 100,
  clientY: 100
});

element.dispatchEvent(clickEvent);
```

#### 常见事件类型

**鼠标事件**
```javascript
element.addEventListener('click', handler);      // 点击
element.addEventListener('dblclick', handler);   // 双击
element.addEventListener('mousedown', handler);  // 按下
element.addEventListener('mouseup', handler);    // 释放
element.addEventListener('mousemove', handler);  // 移动
element.addEventListener('mouseenter', handler); // 进入（不冒泡）
element.addEventListener('mouseleave', handler); // 离开（不冒泡）
element.addEventListener('mouseover', handler);  // 悬停（冒泡）
element.addEventListener('mouseout', handler);   // 离开（冒泡）
```

**键盘事件**
```javascript
element.addEventListener('keydown', handler);   // 按下
element.addEventListener('keypress', handler);  // 按下（已废弃）
element.addEventListener('keyup', handler);     // 释放

// 判断按键
document.addEventListener('keydown', (e) => {
  console.log(e.key);      // 'a', 'Enter', 'ArrowUp'
  console.log(e.code);     // 'KeyA', 'Enter', 'ArrowUp'
  console.log(e.keyCode);  // 65, 13, 38（已废弃）

  // 组合键
  if (e.ctrlKey && e.key === 's') {
    e.preventDefault();
    console.log('Ctrl+S');
  }
});
```

**表单事件**
```javascript
input.addEventListener('focus', handler);   // 获得焦点
input.addEventListener('blur', handler);    // 失去焦点
input.addEventListener('input', handler);   // 输入（实时）
input.addEventListener('change', handler);  // 改变（失焦后）
form.addEventListener('submit', handler);   // 提交
```

**触摸事件**
```javascript
element.addEventListener('touchstart', handler);   // 触摸开始
element.addEventListener('touchmove', handler);    // 触摸移动
element.addEventListener('touchend', handler);     // 触摸结束
element.addEventListener('touchcancel', handler);  // 触摸取消

// 获取触摸点
element.addEventListener('touchstart', (e) => {
  const touch = e.touches[0];
  console.log(touch.clientX, touch.clientY);
});
```
