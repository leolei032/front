# 补充问题

## 1. Vue的$watch和computed的区别
**问题：** Vue的$watch和computed的区别

**考察要点：** 响应式系统，计算属性缓存机制，适用场景

### 解答

#### computed（计算属性）

**特点：**
- 基于依赖缓存
- 只有依赖改变时才重新计算
- 必须有返回值
- 同步操作

```javascript
export default {
  data() {
    return {
      firstName: 'John',
      lastName: 'Doe'
    };
  },

  computed: {
    // 简写（只读）
    fullName() {
      return `${this.firstName} ${this.lastName}`;
    },

    // 完整写法（可读写）
    fullName: {
      get() {
        return `${this.firstName} ${this.lastName}`;
      },
      set(value) {
        const names = value.split(' ');
        this.firstName = names[0];
        this.lastName = names[1];
      }
    }
  }
};
```

#### watch（侦听器）

**特点：**
- 监听数据变化
- 可以执行异步操作
- 不需要返回值
- 可以执行副作用

```javascript
export default {
  data() {
    return {
      question: '',
      answer: ''
    };
  },

  watch: {
    // 简单监听
    question(newVal, oldVal) {
      console.log(`${oldVal} => ${newVal}`);
      this.debouncedGetAnswer();
    },

    // 深度监听对象
    user: {
      handler(newVal, oldVal) {
        console.log('user changed');
      },
      deep: true,       // 深度监听
      immediate: true   // 立即执行
    },

    // 监听对象属性
    'user.name'(newVal, oldVal) {
      console.log('name changed');
    }
  },

  methods: {
    debouncedGetAnswer: _.debounce(function() {
      // 异步操作
      axios.get('/api/answer', {
        params: { q: this.question }
      }).then(response => {
        this.answer = response.data;
      });
    }, 500)
  }
};
```

#### $watch API

```javascript
export default {
  mounted() {
    // 基本用法
    const unwatch = this.$watch('question', (newVal, oldVal) => {
      console.log(`${oldVal} => ${newVal}`);
    });

    // 深度监听
    this.$watch('user', callback, {
      deep: true,
      immediate: true
    });

    // 取消监听
    unwatch();
  }
};
```

#### 区别对比

| 特性 | computed | watch |
|-----|----------|-------|
| 缓存 | ✅ 有缓存 | ❌ 无缓存 |
| 返回值 | ✅ 必须 | ❌ 不需要 |
| 异步 | ❌ 不支持 | ✅ 支持 |
| 副作用 | ❌ 不推荐 | ✅ 可以 |
| 使用场景 | 模板渲染 | 数据变化响应 |

#### 使用场景

**使用computed：**
```javascript
// 1. 模板中需要的值
computed: {
  totalPrice() {
    return this.items.reduce((sum, item) => sum + item.price, 0);
  }
}

// 2. 需要对多个数据进行组合
computed: {
  displayName() {
    return this.user ? `${this.user.firstName} ${this.user.lastName}` : 'Guest';
  }
}

// 3. 需要缓存的复杂计算
computed: {
  filteredList() {
    return this.list.filter(item => item.active).sort((a, b) => a.name.localeCompare(b.name));
  }
}
```

**使用watch：**
```javascript
// 1. 需要执行异步操作
watch: {
  searchText(newVal) {
    this.fetchSearchResults(newVal);
  }
}

// 2. 需要执行副作用（路由跳转、本地存储等）
watch: {
  userId(newVal) {
    this.$router.push(`/user/${newVal}`);
    localStorage.setItem('lastUserId', newVal);
  }
}

// 3. 需要在数据变化时执行复杂逻辑
watch: {
  total(newVal) {
    if (newVal > 1000) {
      this.showWarning = true;
      this.sendNotification();
    }
  }
}
```

## 2. 如何保证前端的安全性？
**问题：** 如何保证前端的安全性？

**考察要点：** 常见安全漏洞（XSS、CSRF、点击劫持等）的防御措施

### 解答（详见 [11-前端安全.md](./11-前端安全.md)）

主要防御措施：
1. XSS防御：输入验证、输出编码、CSP、HTTPOnly Cookie
2. CSRF防御：CSRF Token、SameSite Cookie、验证Referer
3. SQL注入防御：参数化查询、ORM、输入验证
4. 点击劫持防御：X-Frame-Options、CSP frame-ancestors
5. HTTPS：加密传输、HSTS

## 3. 前端监控体系
**问题：** 如何搭建前端监控体系？

**考察要点：** 性能监控、错误监控、用户行为监控、数据上报

### 解答

#### 1. 性能监控

**关键指标**
```javascript
// Performance API
const perfData = performance.getEntriesByType('navigation')[0];

const metrics = {
  // DNS查询时间
  dns: perfData.domainLookupEnd - perfData.domainLookupStart,

  // TCP连接时间
  tcp: perfData.connectEnd - perfData.connectStart,

  // SSL握手时间
  ssl: perfData.secureConnectionStart > 0
    ? perfData.connectEnd - perfData.secureConnectionStart
    : 0,

  // 请求响应时间
  ttfb: perfData.responseStart - perfData.requestStart,

  // 响应下载时间
  download: perfData.responseEnd - perfData.responseStart,

  // DOM解析时间
  domParse: perfData.domComplete - perfData.domInteractive,

  // 白屏时间
  fp: performance.getEntriesByName('first-paint')[0]?.startTime,

  // 首屏时间
  fcp: performance.getEntriesByName('first-contentful-paint')[0]?.startTime,

  // 页面加载完成时间
  load: perfData.loadEventEnd - perfData.fetchStart,

  // DOM Ready时间
  domReady: perfData.domContentLoadedEventEnd - perfData.fetchStart
};

// 上报数据
reportPerformance(metrics);
```

**Web Vitals监控**
```javascript
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

// LCP (Largest Contentful Paint) - 最大内容绘制
getLCP((metric) => {
  console.log('LCP:', metric.value);
  report(metric);
});

// FID (First Input Delay) - 首次输入延迟
getFID((metric) => {
  console.log('FID:', metric.value);
  report(metric);
});

// CLS (Cumulative Layout Shift) - 累积布局偏移
getCLS((metric) => {
  console.log('CLS:', metric.value);
  report(metric);
});

// FCP (First Contentful Paint) - 首次内容绘制
getFCP((metric) => {
  console.log('FCP:', metric.value);
  report(metric);
});

// TTFB (Time to First Byte) - 首字节时间
getTTFB((metric) => {
  console.log('TTFB:', metric.value);
  report(metric);
});
```

**资源加载监控**
```javascript
// 监听资源加载
const resourceObserver = new PerformanceObserver((list) => {
  list.getEntries().forEach((entry) => {
    if (entry.initiatorType) {
      console.log({
        name: entry.name,
        type: entry.initiatorType,
        duration: entry.duration,
        size: entry.transferSize
      });
    }
  });
});

resourceObserver.observe({ entryTypes: ['resource'] });
```

#### 2. 错误监控

**全局错误捕获**
```javascript
// JavaScript错误
window.addEventListener('error', (event) => {
  const { message, filename, lineno, colno, error } = event;

  reportError({
    type: 'javascript',
    message: message,
    filename: filename,
    line: lineno,
    column: colno,
    stack: error?.stack,
    timestamp: Date.now()
  });
}, true);

// Promise未捕获错误
window.addEventListener('unhandledrejection', (event) => {
  reportError({
    type: 'promise',
    message: event.reason?.message || event.reason,
    stack: event.reason?.stack,
    timestamp: Date.now()
  });
});

// 资源加载错误
window.addEventListener('error', (event) => {
  const target = event.target;

  if (target !== window) {
    reportError({
      type: 'resource',
      tagName: target.tagName,
      src: target.src || target.href,
      timestamp: Date.now()
    });
  }
}, true);
```

**Vue错误处理**
```javascript
// Vue 2
Vue.config.errorHandler = (err, vm, info) => {
  reportError({
    type: 'vue',
    message: err.message,
    stack: err.stack,
    component: vm.$options.name,
    info: info,
    timestamp: Date.now()
  });
};

// Vue 3
app.config.errorHandler = (err, instance, info) => {
  reportError({
    type: 'vue',
    message: err.message,
    stack: err.stack,
    component: instance?.$options.name,
    info: info,
    timestamp: Date.now()
  });
};
```

**React错误边界**
```javascript
class ErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    reportError({
      type: 'react',
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      timestamp: Date.now()
    });
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback />;
    }
    return this.props.children;
  }
}
```

**接口错误监控**
```javascript
// 拦截fetch
const originalFetch = window.fetch;
window.fetch = function(...args) {
  const startTime = Date.now();

  return originalFetch.apply(this, args)
    .then(response => {
      const duration = Date.now() - startTime;

      // 记录成功请求
      reportAPI({
        url: args[0],
        method: args[1]?.method || 'GET',
        status: response.status,
        duration: duration,
        success: response.ok
      });

      // 记录失败请求
      if (!response.ok) {
        reportError({
          type: 'api',
          url: args[0],
          status: response.status,
          statusText: response.statusText
        });
      }

      return response;
    })
    .catch(error => {
      // 网络错误
      reportError({
        type: 'api',
        url: args[0],
        message: error.message,
        stack: error.stack
      });

      throw error;
    });
};

// 拦截XMLHttpRequest
const originalOpen = XMLHttpRequest.prototype.open;
const originalSend = XMLHttpRequest.prototype.send;

XMLHttpRequest.prototype.open = function(method, url) {
  this._method = method;
  this._url = url;
  this._startTime = Date.now();
  return originalOpen.apply(this, arguments);
};

XMLHttpRequest.prototype.send = function() {
  this.addEventListener('load', function() {
    const duration = Date.now() - this._startTime;

    reportAPI({
      url: this._url,
      method: this._method,
      status: this.status,
      duration: duration,
      success: this.status >= 200 && this.status < 400
    });
  });

  this.addEventListener('error', function() {
    reportError({
      type: 'api',
      url: this._url,
      method: this._method,
      message: 'Network Error'
    });
  });

  return originalSend.apply(this, arguments);
};
```

#### 3. 用户行为监控

**页面访问统计**
```javascript
// PV（Page View）
function reportPV() {
  report({
    type: 'pv',
    page: location.pathname,
    referrer: document.referrer,
    timestamp: Date.now()
  });
}

// UV（Unique Visitor）- 使用设备指纹
function getDeviceId() {
  let deviceId = localStorage.getItem('deviceId');

  if (!deviceId) {
    deviceId = `${Date.now()}_${Math.random().toString(36).slice(2)}`;
    localStorage.setItem('deviceId', deviceId);
  }

  return deviceId;
}

reportPV();
```

**用户点击行为**
```javascript
// 点击热力图
document.addEventListener('click', (event) => {
  const { clientX, clientY, target } = event;

  report({
    type: 'click',
    x: clientX,
    y: clientY,
    element: {
      tagName: target.tagName,
      id: target.id,
      className: target.className,
      text: target.textContent?.slice(0, 100)
    },
    page: location.pathname,
    timestamp: Date.now()
  });
}, true);
```

**页面停留时间**
```javascript
let startTime = Date.now();
let isActive = true;

// 页面可见性
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // 页面隐藏
    isActive = false;
    const duration = Date.now() - startTime;
    report({
      type: 'duration',
      page: location.pathname,
      duration: duration
    });
  } else {
    // 页面显示
    isActive = true;
    startTime = Date.now();
  }
});

// 页面卸载
window.addEventListener('beforeunload', () => {
  if (isActive) {
    const duration = Date.now() - startTime;
    // 使用sendBeacon确保数据发送
    navigator.sendBeacon('/api/report', JSON.stringify({
      type: 'duration',
      page: location.pathname,
      duration: duration
    }));
  }
});
```

#### 4. 数据上报

**上报策略**
```javascript
class Monitor {
  constructor() {
    this.queue = [];
    this.maxSize = 10;
    this.timer = null;
  }

  // 添加数据到队列
  add(data) {
    this.queue.push({
      ...data,
      timestamp: Date.now(),
      page: location.pathname,
      userAgent: navigator.userAgent
    });

    // 队列满了立即上报
    if (this.queue.length >= this.maxSize) {
      this.flush();
    } else {
      // 延迟上报
      this.scheduleFlush();
    }
  }

  // 延迟上报
  scheduleFlush() {
    if (this.timer) return;

    this.timer = setTimeout(() => {
      this.flush();
      this.timer = null;
    }, 3000);
  }

  // 立即上报
  flush() {
    if (this.queue.length === 0) return;

    const data = this.queue.splice(0, this.queue.length);

    // 使用sendBeacon（页面卸载时也能发送）
    if (navigator.sendBeacon) {
      navigator.sendBeacon('/api/report', JSON.stringify(data));
    } else {
      // 降级到fetch
      fetch('/api/report', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
        keepalive: true
      });
    }
  }
}

const monitor = new Monitor();

// 使用
function report(data) {
  monitor.add(data);
}
```

**采样上报**
```javascript
// 只上报部分用户的数据
function shouldReport() {
  const samplingRate = 0.1;  // 10%采样率
  return Math.random() < samplingRate;
}

function report(data) {
  if (shouldReport()) {
    monitor.add(data);
  }
}
```

**错误去重**
```javascript
const errorCache = new Set();

function reportError(error) {
  const key = `${error.message}_${error.filename}_${error.line}`;

  // 5分钟内相同错误只上报一次
  if (errorCache.has(key)) {
    return;
  }

  errorCache.add(key);
  setTimeout(() => errorCache.delete(key), 5 * 60 * 1000);

  monitor.add(error);
}
```

## 4. 如何实现骨架屏？
**问题：** 如何实现骨架屏（Skeleton Screen）？

**考察要点：** 提升用户体验，减少白屏时间

### 解答

#### 实现方式

**1. 手动编写骨架屏**
```vue
<template>
  <div>
    <div v-if="loading" class="skeleton">
      <div class="skeleton-avatar"></div>
      <div class="skeleton-content">
        <div class="skeleton-title"></div>
        <div class="skeleton-paragraph"></div>
        <div class="skeleton-paragraph"></div>
      </div>
    </div>

    <div v-else class="content">
      <img :src="user.avatar" class="avatar">
      <div class="info">
        <h2>{{ user.name }}</h2>
        <p>{{ user.description }}</p>
      </div>
    </div>
  </div>
</template>

<style scoped>
.skeleton-avatar {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: loading 1.5s infinite;
}

.skeleton-title {
  height: 20px;
  margin-bottom: 10px;
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: loading 1.5s infinite;
}

.skeleton-paragraph {
  height: 16px;
  margin-bottom: 8px;
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: loading 1.5s infinite;
}

@keyframes loading {
  0% {
    background-position: 200% 0;
  }
  100% {
    background-position: -200% 0;
  }
}
</style>
```

**2. 使用组件库**
```vue
<!-- Element Plus -->
<el-skeleton :loading="loading" :rows="5" animated>
  <template #default>
    <div>实际内容</div>
  </template>
</el-skeleton>

<!-- Ant Design Vue -->
<a-skeleton :loading="loading" active>
  <div>实际内容</div>
</a-skeleton>
```

**3. 自动生成骨架屏**
```javascript
// 使用page-skeleton-webpack-plugin
const SkeletonWebpackPlugin = require('page-skeleton-webpack-plugin');

module.exports = {
  plugins: [
    new SkeletonWebpackPlugin({
      pathname: path.resolve(__dirname, './shell'),
      staticDir: path.resolve(__dirname, './dist'),
      routes: ['/', '/about']
    })
  ]
};
```

**4. SSR骨架屏**
```javascript
// 预渲染骨架屏
const Skeleton = () => (
  <div className="skeleton">
    <div className="skeleton-header" />
    <div className="skeleton-content" />
  </div>
);

// 服务端返回骨架屏HTML
app.get('*', (req, res) => {
  const skeleton = renderToString(<Skeleton />);
  res.send(`
    <!DOCTYPE html>
    <html>
      <body>
        <div id="root">${skeleton}</div>
        <script src="/bundle.js"></script>
      </body>
    </html>
  `);
});
```

#### 最佳实践

1. **保持骨架屏和实际内容布局一致**
2. **使用动画提升体验**
3. **避免骨架屏闪烁**（数据快速返回时）
4. **渐进式加载**（先显示重要内容的骨架屏）

```javascript
// 避免闪烁
const MIN_LOADING_TIME = 500;  // 最小显示时间

async function loadData() {
  setLoading(true);
  const startTime = Date.now();

  const data = await fetchData();

  const elapsed = Date.now() - startTime;
  if (elapsed < MIN_LOADING_TIME) {
    await new Promise(resolve => setTimeout(resolve, MIN_LOADING_TIME - elapsed));
  }

  setData(data);
  setLoading(false);
}
```

## 5. 如何进行性能监控和对比优化效果？

**问题：** 讲解有做过的性能优化项目，怎么对比性能优化前后的效果？

**考察要点：** 性能监控指标、优化策略、效果评估

### 解答

#### 性能监控指标体系

**1. 核心性能指标（Core Web Vitals）**

```javascript
// 使用web-vitals库
import { getCLS, getFID, getLCP } from 'web-vitals';

const reportPerformance = (metric) => {
  // 上报到监控平台
  fetch('/api/performance', {
    method: 'POST',
    body: JSON.stringify({
      name: metric.name,
      value: metric.value,
      id: metric.id,
      delta: metric.delta,
      entries: metric.entries
    })
  });
};

// LCP - 最大内容绘制（Good: < 2.5s）
getLCP(reportPerformance);

// FID - 首次输入延迟（Good: < 100ms）
getFID(reportPerformance);

// CLS - 累积布局偏移（Good: < 0.1）
getCLS(reportPerformance);
```

**2. 自定义性能指标**

```javascript
class PerformanceMonitor {
  constructor() {
    this.marks = new Map();
    this.measures = new Map();
  }

  // 标记时间点
  mark(name) {
    performance.mark(name);
    this.marks.set(name, performance.now());
  }

  // 测量两个时间点之间的时长
  measure(name, startMark, endMark) {
    performance.measure(name, startMark, endMark);
    const measure = performance.getEntriesByName(name, 'measure')[0];
    this.measures.set(name, measure.duration);
    return measure.duration;
  }

  // 获取所有指标
  getMetrics() {
    const navigation = performance.getEntriesByType('navigation')[0];
    const paint = performance.getEntriesByType('paint');

    return {
      // 页面加载指标
      pageLoad: {
        dns: navigation.domainLookupEnd - navigation.domainLookupStart,
        tcp: navigation.connectEnd - navigation.connectStart,
        ttfb: navigation.responseStart - navigation.requestStart,
        download: navigation.responseEnd - navigation.responseStart,
        domParse: navigation.domComplete - navigation.domInteractive,
        domReady: navigation.domContentLoadedEventEnd - navigation.fetchStart,
        load: navigation.loadEventEnd - navigation.fetchStart
      },

      // 绘制指标
      paint: {
        fp: paint.find(p => p.name === 'first-paint')?.startTime || 0,
        fcp: paint.find(p => p.name === 'first-contentful-paint')?.startTime || 0
      },

      // 资源指标
      resources: this.getResourceMetrics(),

      // 自定义指标
      custom: Object.fromEntries(this.measures)
    };
  }

  // 资源加载指标
  getResourceMetrics() {
    const resources = performance.getEntriesByType('resource');

    return {
      total: resources.length,
      totalSize: resources.reduce((sum, r) => sum + r.transferSize, 0),
      byType: this.groupResourcesByType(resources),
      slow: resources.filter(r => r.duration > 1000).length
    };
  }

  groupResourcesByType(resources) {
    const groups = {};

    resources.forEach(resource => {
      const type = resource.initiatorType;
      if (!groups[type]) {
        groups[type] = {
          count: 0,
          size: 0,
          duration: 0
        };
      }

      groups[type].count++;
      groups[type].size += resource.transferSize;
      groups[type].duration += resource.duration;
    });

    return groups;
  }

  // 清除标记
  clear() {
    performance.clearMarks();
    performance.clearMeasures();
    this.marks.clear();
    this.measures.clear();
  }
}

// 使用
const monitor = new PerformanceMonitor();

// 标记关键时间点
monitor.mark('app-start');

// 应用初始化...

monitor.mark('app-ready');
monitor.measure('app-init', 'app-start', 'app-ready');

// 监控路由切换
router.beforeEach((to, from, next) => {
  monitor.mark(`route-${to.path}-start`);
  next();
});

router.afterEach((to) => {
  monitor.mark(`route-${to.path}-end`);
  const duration = monitor.measure(
    `route-${to.path}`,
    `route-${to.path}-start`,
    `route-${to.path}-end`
  );

  console.log(`路由${to.path}加载耗时: ${duration}ms`);
});

// 页面卸载时上报
window.addEventListener('beforeunload', () => {
  const metrics = monitor.getMetrics();
  navigator.sendBeacon('/api/performance', JSON.stringify(metrics));
});
```

#### 性能优化实战案例

**案例1：首屏加载优化**

```javascript
// 优化前的指标
const beforeOptimization = {
  FCP: 3200, // ms
  LCP: 4800,
  TTI: 5600,
  bundleSize: 2.5, // MB
  requestCount: 85
};

// 优化策略
const optimizations = [
  {
    name: '代码分割',
    action: () => {
      // 路由懒加载
      const routes = [
        {
          path: '/home',
          component: () => import('./views/Home.vue')
        },
        {
          path: '/about',
          component: () => import('./views/About.vue')
        }
      ];

      // 组件懒加载
      const AsyncComponent = defineAsyncComponent(() =>
        import('./components/HeavyComponent.vue')
      );
    },
    expectedImprovement: {
      bundleSize: -40, // 减少40%
      FCP: -30 // 减少30%
    }
  },

  {
    name: '资源压缩',
    action: () => {
      // webpack配置
      module.exports = {
        optimization: {
          minimize: true,
          minimizer: [
            new TerserPlugin({
              terserOptions: {
                compress: {
                  drop_console: true
                }
              }
            }),
            new CssMinimizerPlugin()
          ]
        }
      };

      // 图片压缩
      module.exports = {
        module: {
          rules: [
            {
              test: /\.(png|jpe?g|gif|svg)$/i,
              use: [
                {
                  loader: 'image-webpack-loader',
                  options: {
                    mozjpeg: { quality: 80 },
                    pngquant: { quality: [0.65, 0.90] }
                  }
                }
              ]
            }
          ]
        }
      };
    },
    expectedImprovement: {
      bundleSize: -25,
      download: -20
    }
  },

  {
    name: '预加载关键资源',
    action: () => {
      // 预加载
      <link rel="preload" href="/fonts/main.woff2" as="font" crossorigin>
      <link rel="preload" href="/images/hero.jpg" as="image">

      // 预连接
      <link rel="preconnect" href="https://api.example.com">
      <link rel="dns-prefetch" href="https://cdn.example.com">

      // 预获取
      <link rel="prefetch" href="/next-page.js">
    },
    expectedImprovement: {
      FCP: -15,
      LCP: -20
    }
  },

  {
    name: 'CDN和缓存',
    action: () => {
      // 使用CDN
      const cdnUrl = 'https://cdn.example.com';

      // 配置强缓存
      app.use((req, res, next) => {
        if (req.url.match(/\.(js|css|png|jpg|gif|svg|woff2)$/)) {
          res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
        }
        next();
      });

      // Service Worker缓存
      self.addEventListener('fetch', (event) => {
        event.respondWith(
          caches.match(event.request).then((response) => {
            return response || fetch(event.request);
          })
        );
      });
    },
    expectedImprovement: {
      ttfb: -50, // 二次访问
      download: -80
    }
  },

  {
    name: 'SSR/SSG',
    action: () => {
      // Next.js SSG
      export async function getStaticProps() {
        const data = await fetchData();
        return {
          props: { data },
          revalidate: 60
        };
      }

      // Nuxt.js SSR
      export default {
        async asyncData({ $axios }) {
          const data = await $axios.$get('/api/data');
          return { data };
        }
      };
    },
    expectedImprovement: {
      FCP: -60,
      LCP: -50,
      TTI: -40
    }
  }
];

// 优化后的指标
const afterOptimization = {
  FCP: 1200, // -62.5%
  LCP: 1800, // -62.5%
  TTI: 2400, // -57.1%
  bundleSize: 0.8, // -68%
  requestCount: 35 // -58.8%
};

// 计算改进
const improvement = {
  FCP: ((beforeOptimization.FCP - afterOptimization.FCP) / beforeOptimization.FCP * 100).toFixed(1),
  LCP: ((beforeOptimization.LCP - afterOptimization.LCP) / beforeOptimization.LCP * 100).toFixed(1),
  TTI: ((beforeOptimization.TTI - afterOptimization.TTI) / beforeOptimization.TTI * 100).toFixed(1),
  bundleSize: ((beforeOptimization.bundleSize - afterOptimization.bundleSize) / beforeOptimization.bundleSize * 100).toFixed(1),
  requestCount: ((beforeOptimization.requestCount - afterOptimization.requestCount) / beforeOptimization.requestCount * 100).toFixed(1)
};

console.log('性能改进:', improvement);
// {
//   FCP: "62.5%",
//   LCP: "62.5%",
//   TTI: "57.1%",
//   bundleSize: "68.0%",
//   requestCount: "58.8%"
// }
```

**案例2：长列表优化**

```javascript
// 虚拟滚动组件
class VirtualScroll {
  constructor(options) {
    this.container = options.container;
    this.items = options.items;
    this.itemHeight = options.itemHeight;
    this.renderItem = options.renderItem;

    this.visibleCount = Math.ceil(this.container.clientHeight / this.itemHeight);
    this.startIndex = 0;
    this.endIndex = this.startIndex + this.visibleCount;

    this.init();
  }

  init() {
    // 创建占位容器
    this.scrollHeight = this.items.length * this.itemHeight;
    this.container.style.height = `${this.scrollHeight}px`;

    // 监听滚动
    this.container.addEventListener('scroll', this.handleScroll.bind(this));

    // 初始渲染
    this.render();
  }

  handleScroll() {
    const scrollTop = this.container.scrollTop;
    this.startIndex = Math.floor(scrollTop / this.itemHeight);
    this.endIndex = this.startIndex + this.visibleCount;

    this.render();
  }

  render() {
    const fragment = document.createDocumentFragment();
    const visibleItems = this.items.slice(this.startIndex, this.endIndex);

    visibleItems.forEach((item, index) => {
      const element = this.renderItem(item);
      element.style.position = 'absolute';
      element.style.top = `${(this.startIndex + index) * this.itemHeight}px`;
      fragment.appendChild(element);
    });

    this.container.innerHTML = '';
    this.container.appendChild(fragment);
  }
}

// 使用
const virtualScroll = new VirtualScroll({
  container: document.getElementById('list'),
  items: Array.from({ length: 10000 }, (_, i) => ({ id: i, text: `Item ${i}` })),
  itemHeight: 50,
  renderItem: (item) => {
    const div = document.createElement('div');
    div.textContent = item.text;
    return div;
  }
});

// 性能对比
const comparison = {
  before: {
    initialRender: 3200, // ms
    scrollFPS: 15,
    memoryUsage: 250 // MB
  },
  after: {
    initialRender: 80, // ms
    scrollFPS: 60,
    memoryUsage: 45 // MB
  },
  improvement: {
    initialRender: '97.5%',
    scrollFPS: '300%',
    memoryUsage: '82%'
  }
};
```

#### 性能监控平台搭建

```javascript
// 前端SDK
class PerformanceSDK {
  constructor(options) {
    this.appId = options.appId;
    this.apiUrl = options.apiUrl;
    this.sampling = options.sampling || 0.1;

    this.init();
  }

  init() {
    // 监控页面加载
    window.addEventListener('load', () => {
      setTimeout(() => this.reportPageLoad(), 0);
    });

    // 监控Web Vitals
    this.observeWebVitals();

    // 监控资源
    this.observeResources();

    // 监控长任务
    this.observeLongTasks();
  }

  reportPageLoad() {
    const navigation = performance.getEntriesByType('navigation')[0];
    const paint = performance.getEntriesByType('paint');

    const data = {
      type: 'pageLoad',
      metrics: {
        dns: navigation.domainLookupEnd - navigation.domainLookupStart,
        tcp: navigation.connectEnd - navigation.connectStart,
        ttfb: navigation.responseStart - navigation.requestStart,
        domReady: navigation.domContentLoadedEventEnd - navigation.fetchStart,
        load: navigation.loadEventEnd - navigation.fetchStart,
        fp: paint.find(p => p.name === 'first-paint')?.startTime,
        fcp: paint.find(p => p.name === 'first-contentful-paint')?.startTime
      },
      page: location.pathname,
      timestamp: Date.now()
    };

    this.report(data);
  }

  observeWebVitals() {
    import('web-vitals').then(({ getCLS, getFID, getLCP }) => {
      getCLS((metric) => this.report({ type: 'CLS', value: metric.value }));
      getFID((metric) => this.report({ type: 'FID', value: metric.value }));
      getLCP((metric) => this.report({ type: 'LCP', value: metric.value }));
    });
  }

  observeResources() {
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.duration > 1000) {
          this.report({
            type: 'slowResource',
            name: entry.name,
            duration: entry.duration,
            size: entry.transferSize
          });
        }
      });
    });

    observer.observe({ entryTypes: ['resource'] });
  }

  observeLongTasks() {
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        this.report({
          type: 'longTask',
          duration: entry.duration,
          startTime: entry.startTime
        });
      });
    });

    observer.observe({ entryTypes: ['longtask'] });
  }

  report(data) {
    if (Math.random() > this.sampling) return;

    const reportData = {
      ...data,
      appId: this.appId,
      userId: this.getUserId(),
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      page: location.pathname
    };

    navigator.sendBeacon(
      this.apiUrl,
      JSON.stringify(reportData)
    );
  }

  getUserId() {
    let userId = localStorage.getItem('userId');
    if (!userId) {
      userId = `${Date.now()}_${Math.random().toString(36).slice(2)}`;
      localStorage.setItem('userId', userId);
    }
    return userId;
  }
}

// 使用
new PerformanceSDK({
  appId: 'my-app',
  apiUrl: 'https://api.example.com/performance',
  sampling: 0.1
});
```

#### 性能数据分析

```javascript
// 后端数据聚合
class PerformanceAnalyzer {
  constructor(db) {
    this.db = db;
  }

  async getPageLoadMetrics(appId, startDate, endDate) {
    const data = await this.db.collection('performance')
      .find({
        appId: appId,
        type: 'pageLoad',
        timestamp: { $gte: startDate, $lte: endDate }
      })
      .toArray();

    return this.calculateStatistics(data);
  }

  calculateStatistics(data) {
    const metrics = ['dns', 'tcp', 'ttfb', 'domReady', 'load', 'fcp'];
    const result = {};

    metrics.forEach(metric => {
      const values = data.map(d => d.metrics[metric]).filter(v => v);

      result[metric] = {
        avg: this.average(values),
        median: this.median(values),
        p75: this.percentile(values, 0.75),
        p95: this.percentile(values, 0.95),
        p99: this.percentile(values, 0.99),
        min: Math.min(...values),
        max: Math.max(...values)
      };
    });

    return result;
  }

  average(arr) {
    return arr.reduce((sum, val) => sum + val, 0) / arr.length;
  }

  median(arr) {
    const sorted = arr.sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 === 0
      ? (sorted[mid - 1] + sorted[mid]) / 2
      : sorted[mid];
  }

  percentile(arr, p) {
    const sorted = arr.sort((a, b) => a - b);
    const index = Math.ceil(sorted.length * p) - 1;
    return sorted[index];
  }

  async compareVersions(appId, version1, version2) {
    const [data1, data2] = await Promise.all([
      this.getVersionMetrics(appId, version1),
      this.getVersionMetrics(appId, version2)
    ]);

    return this.calculateImprovement(data1, data2);
  }

  calculateImprovement(before, after) {
    const metrics = Object.keys(before);
    const improvement = {};

    metrics.forEach(metric => {
      const beforeValue = before[metric].avg;
      const afterValue = after[metric].avg;
      const change = ((beforeValue - afterValue) / beforeValue * 100).toFixed(2);

      improvement[metric] = {
        before: beforeValue,
        after: afterValue,
        change: `${change}%`,
        improved: change > 0
      };
    });

    return improvement;
  }
}

// 使用
const analyzer = new PerformanceAnalyzer(db);

// 获取指标
const metrics = await analyzer.getPageLoadMetrics(
  'my-app',
  new Date('2024-01-01'),
  new Date('2024-01-31')
);

console.log('页面加载指标:', metrics);
// {
//   dns: { avg: 45, median: 40, p95: 120, ... },
//   tcp: { avg: 80, median: 75, p95: 200, ... },
//   ttfb: { avg: 250, median: 230, p95: 600, ... },
//   ...
// }

// 版本对比
const comparison = await analyzer.compareVersions('my-app', '1.0.0', '2.0.0');

console.log('版本对比:', comparison);
// {
//   fcp: {
//     before: 2800,
//     after: 1200,
//     change: "57.14%",
//     improved: true
//   },
//   ...
// }
```

## 6. 如何设计监控上报系统？

**问题：** 如何进行静默监控上报？让你设计监控系统配置方案怎么设计？

**考察要点：** 监控架构设计、数据上报策略、系统可扩展性

### 解答（详见 [17-前端监控深度解析.md](./17-前端监控深度解析.md)）

核心要点：
1. SDK采集层：性能、错误、行为采集
2. 数据处理层：格式化、压缩、采样
3. 上报层：Image、Beacon、Fetch上报
4. 存储分析层：日志存储、数据聚合、可视化

## 7. 限制并发数的实现方案

**问题：** 限制并发数的方案怎么设计？

**考察要点：** 并发控制、队列管理、资源调度

### 解答

#### 并发控制类

```javascript
class ConcurrencyLimit {
  constructor(limit = 5) {
    this.limit = limit;
    this.running = 0;
    this.queue = [];
  }

  async add(fn) {
    // 如果达到并发限制，加入队列等待
    if (this.running >= this.limit) {
      await new Promise(resolve => this.queue.push(resolve));
    }

    this.running++;

    try {
      const result = await fn();
      return result;
    } finally {
      this.running--;
      // 处理队列中的下一个任务
      if (this.queue.length > 0) {
        const resolve = this.queue.shift();
        resolve();
      }
    }
  }

  get pending() {
    return this.queue.length;
  }

  get active() {
    return this.running;
  }
}

// 使用
const limiter = new ConcurrencyLimit(3);

const tasks = Array.from({ length: 10 }, (_, i) =>
  limiter.add(async () => {
    console.log(`Task ${i} started`);
    await new Promise(resolve => setTimeout(resolve, 1000));
    console.log(`Task ${i} completed`);
    return i;
  })
);

const results = await Promise.all(tasks);
console.log('All tasks completed:', results);
```

#### Promise池

```javascript
class PromisePool {
  constructor(limit) {
    this.limit = limit;
    this.tasks = [];
    this.activeCount = 0;
  }

  add(task) {
    return new Promise((resolve, reject) => {
      this.tasks.push({ task, resolve, reject });
      this.run();
    });
  }

  run() {
    while (this.activeCount < this.limit && this.tasks.length > 0) {
      const { task, resolve, reject } = this.tasks.shift();
      this.activeCount++;

      task()
        .then(resolve)
        .catch(reject)
        .finally(() => {
          this.activeCount--;
          this.run();
        });
    }
  }

  async all(tasks) {
    return Promise.all(tasks.map(task => this.add(task)));
  }
}

// 使用
const pool = new PromisePool(5);

const urls = Array.from({ length: 20 }, (_, i) => `https://api.example.com/data/${i}`);

const results = await pool.all(
  urls.map(url => () => fetch(url).then(r => r.json()))
);

console.log('Fetched all data:', results);
```

#### 请求并发控制（实战）

```javascript
// axios并发控制
class AxiosQueue {
  constructor(axios, options = {}) {
    this.axios = axios;
    this.maxConcurrent = options.maxConcurrent || 6;
    this.queue = [];
    this.activeCount = 0;

    // 拦截请求
    this.axios.interceptors.request.use(
      config => this.enqueue(config),
      error => Promise.reject(error)
    );
  }

  async enqueue(config) {
    // 等待队列有空位
    while (this.activeCount >= this.maxConcurrent) {
      await this.waitForSlot();
    }

    this.activeCount++;
    return config;
  }

  waitForSlot() {
    return new Promise(resolve => {
      this.queue.push(resolve);
    });
  }

  release() {
    this.activeCount--;

    if (this.queue.length > 0) {
      const resolve = this.queue.shift();
      resolve();
    }
  }

  createInstance() {
    const instance = this.axios.create();

    instance.interceptors.response.use(
      response => {
        this.release();
        return response;
      },
      error => {
        this.release();
        return Promise.reject(error);
      }
    );

    return instance;
  }
}

// 使用
import axios from 'axios';

const queue = new AxiosQueue(axios, { maxConcurrent: 6 });
const http = queue.createInstance();

// 并发请求会被自动控制
const requests = Array.from({ length: 20 }, (_, i) =>
  http.get(`/api/data/${i}`)
);

const results = await Promise.all(requests);
```

#### 浏览器并发限制

```javascript
// 利用浏览器的域名并发限制
class DomainSharding {
  constructor(domains) {
    this.domains = domains;
    this.currentIndex = 0;
  }

  getNextDomain() {
    const domain = this.domains[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.domains.length;
    return domain;
  }

  shardUrl(url) {
    const domain = this.getNextDomain();
    return url.replace(/^https?:\/\/[^\/]+/, domain);
  }
}

// 使用
const sharding = new DomainSharding([
  'https://cdn1.example.com',
  'https://cdn2.example.com',
  'https://cdn3.example.com',
  'https://cdn4.example.com'
]);

const images = Array.from({ length: 100 }, (_, i) => {
  const img = new Image();
  img.src = sharding.shardUrl(`https://cdn.example.com/images/${i}.jpg`);
  return img;
});

// 通过多个域名，突破浏览器单域名并发限制（通常是6个）
```

#### 队列调度器

```javascript
class Scheduler {
  constructor(limit) {
    this.limit = limit;
    this.running = 0;
    this.queue = [];
    this.results = [];
  }

  add(task) {
    return new Promise((resolve, reject) => {
      this.queue.push({
        task,
        resolve,
        reject
      });

      this.schedule();
    });
  }

  schedule() {
    while (this.running < this.limit && this.queue.length > 0) {
      const { task, resolve, reject } = this.queue.shift();
      this.running++;

      task()
        .then(result => {
          this.results.push(result);
          resolve(result);
        })
        .catch(reject)
        .finally(() => {
          this.running--;
          this.schedule();
        });
    }
  }

  async waitAll() {
    while (this.running > 0 || this.queue.length > 0) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    return this.results;
  }
}

// 使用
const scheduler = new Scheduler(3);

// 添加任务
scheduler.add(() => fetch('/api/1').then(r => r.json()));
scheduler.add(() => fetch('/api/2').then(r => r.json()));
scheduler.add(() => fetch('/api/3').then(r => r.json()));
scheduler.add(() => fetch('/api/4').then(r => r.json()));
scheduler.add(() => fetch('/api/5').then(r => r.json()));

// 等待所有任务完成
const results = await scheduler.waitAll();
console.log('All tasks completed:', results);
```

#### 实际应用场景

```javascript
// 场景1：批量上传文件
class FileUploader {
  constructor(options = {}) {
    this.maxConcurrent = options.maxConcurrent || 3;
    this.chunkSize = options.chunkSize || 1024 * 1024; // 1MB
    this.limiter = new ConcurrencyLimit(this.maxConcurrent);
  }

  async uploadFiles(files) {
    const tasks = files.map(file =>
      () => this.uploadFile(file)
    );

    const results = await Promise.all(
      tasks.map(task => this.limiter.add(task))
    );

    return results;
  }

  async uploadFile(file) {
    // 分片上传
    const chunks = this.createChunks(file);
    const chunkTasks = chunks.map((chunk, index) =>
      () => this.uploadChunk(file.name, chunk, index)
    );

    // 并发上传分片
    const chunkResults = await Promise.all(
      chunkTasks.map(task => this.limiter.add(task))
    );

    // 合并分片
    return this.mergeChunks(file.name, chunkResults);
  }

  createChunks(file) {
    const chunks = [];
    let start = 0;

    while (start < file.size) {
      chunks.push(file.slice(start, start + this.chunkSize));
      start += this.chunkSize;
    }

    return chunks;
  }

  async uploadChunk(filename, chunk, index) {
    const formData = new FormData();
    formData.append('file', chunk);
    formData.append('filename', filename);
    formData.append('index', index);

    const response = await fetch('/api/upload/chunk', {
      method: 'POST',
      body: formData
    });

    return response.json();
  }

  async mergeChunks(filename, chunkResults) {
    const response = await fetch('/api/upload/merge', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        filename: filename,
        chunks: chunkResults
      })
    });

    return response.json();
  }
}

// 使用
const uploader = new FileUploader({ maxConcurrent: 3 });

const files = Array.from(document.querySelector('#fileInput').files);
const results = await uploader.uploadFiles(files);

console.log('Upload completed:', results);
```

```javascript
// 场景2：爬虫并发控制
class Crawler {
  constructor(options = {}) {
    this.concurrency = options.concurrency || 5;
    this.delay = options.delay || 1000;
    this.limiter = new ConcurrencyLimit(this.concurrency);
    this.visited = new Set();
  }

  async crawl(urls) {
    const tasks = urls
      .filter(url => !this.visited.has(url))
      .map(url => () => this.fetchUrl(url));

    const results = await Promise.all(
      tasks.map(task => this.limiter.add(task))
    );

    return results;
  }

  async fetchUrl(url) {
    this.visited.add(url);

    // 延迟，避免请求过快
    await new Promise(resolve => setTimeout(resolve, this.delay));

    const response = await fetch(url);
    const html = await response.text();

    // 提取链接
    const links = this.extractLinks(html);

    return {
      url: url,
      html: html,
      links: links
    };
  }

  extractLinks(html) {
    const regex = /<a[^>]+href=["']([^"']+)["']/g;
    const links = [];
    let match;

    while ((match = regex.exec(html)) !== null) {
      links.push(match[1]);
    }

    return links;
  }
}

// 使用
const crawler = new Crawler({ concurrency: 5, delay: 1000 });

const urls = [
  'https://example.com/page1',
  'https://example.com/page2',
  'https://example.com/page3',
  // ...
];

const results = await crawler.crawl(urls);
console.log('Crawled pages:', results);
```
