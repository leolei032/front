# 前端框架细节

## 1. Vue组件通信
**问题：** Vue组件之间的通信方式（已在Vue框架章节详细说明）

参见：[04-Vue框架.md](./04-Vue框架.md#7-vue组件之间的通信方式)

## 2. VDom是什么？为什么不直接用Dom？
**问题：** VDom是什么？为什么不直接用Dom？

### 解答

#### 什么是Virtual DOM

Virtual DOM是一个JavaScript对象，用于描述真实DOM的结构。

```javascript
// 真实DOM
<div id="app">
  <p class="text">Hello</p>
</div>

// Virtual DOM
{
  type: 'div',
  props: { id: 'app' },
  children: [
    {
      type: 'p',
      props: { className: 'text' },
      children: ['Hello']
    }
  ]
}
```

#### 为什么使用Virtual DOM

**1. 性能优化**
```javascript
// 直接操作DOM（慢）
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = i;
  document.body.appendChild(div);  // 触发1000次重排重绘
}

// 使用Virtual DOM（快）
const vNodes = [];
for (let i = 0; i < 1000; i++) {
  vNodes.push({ type: 'div', children: [i] });
}
// 一次性更新
patch(oldVNode, newVNode);  // 只触发1次重排重绘
```

**2. 跨平台**
```javascript
// Virtual DOM可以渲染到不同平台
// Web
render(vNode, document.getElementById('app'));

// React Native
render(vNode, NativeComponent);

// 服务端渲染
renderToString(vNode);
```

**3. 声明式编程**
```javascript
// 命令式（直接操作DOM）
const div = document.createElement('div');
div.className = 'container';
div.textContent = 'Hello';
document.body.appendChild(div);

// 声明式（Virtual DOM）
const vNode = h('div', { className: 'container' }, 'Hello');
render(vNode, document.body);
```

#### Virtual DOM实现原理

**1. 创建Virtual DOM**
```javascript
// h函数（createElement）
function h(type, props, ...children) {
  return {
    type,
    props: props || {},
    children: children.flat()
  };
}

// 使用
const vNode = h('div', { id: 'app' },
  h('h1', null, 'Title'),
  h('p', null, 'Content')
);

// JSX编译后
// <div id="app">
//   <h1>Title</h1>
//   <p>Content</p>
// </div>
//
// 编译为：
const vNode = h('div', { id: 'app' },
  h('h1', null, 'Title'),
  h('p', null, 'Content')
);
```

**2. 渲染Virtual DOM**
```javascript
function render(vNode, container) {
  const dom = createDOM(vNode);
  container.appendChild(dom);
}

function createDOM(vNode) {
  // 文本节点
  if (typeof vNode === 'string' || typeof vNode === 'number') {
    return document.createTextNode(vNode);
  }

  // 元素节点
  const { type, props, children } = vNode;
  const dom = document.createElement(type);

  // 设置属性
  if (props) {
    Object.keys(props).forEach(key => {
      if (key === 'className') {
        dom.className = props[key];
      } else if (key.startsWith('on')) {
        const eventType = key.slice(2).toLowerCase();
        dom.addEventListener(eventType, props[key]);
      } else {
        dom.setAttribute(key, props[key]);
      }
    });
  }

  // 递归渲染子节点
  if (children) {
    children.forEach(child => {
      render(child, dom);
    });
  }

  return dom;
}
```

**3. Diff算法**
```javascript
function patch(oldVNode, newVNode) {
  // 节点类型不同，直接替换
  if (oldVNode.type !== newVNode.type) {
    const newDOM = createDOM(newVNode);
    oldVNode.dom.replaceWith(newDOM);
    return newDOM;
  }

  // 文本节点
  if (typeof newVNode === 'string') {
    if (oldVNode !== newVNode) {
      oldVNode.dom.textContent = newVNode;
    }
    return oldVNode.dom;
  }

  // 更新属性
  const dom = oldVNode.dom;
  updateProps(dom, oldVNode.props, newVNode.props);

  // 更新子节点
  updateChildren(dom, oldVNode.children, newVNode.children);

  return dom;
}

function updateProps(dom, oldProps, newProps) {
  // 删除旧属性
  Object.keys(oldProps).forEach(key => {
    if (!(key in newProps)) {
      dom.removeAttribute(key);
    }
  });

  // 更新/添加新属性
  Object.keys(newProps).forEach(key => {
    if (oldProps[key] !== newProps[key]) {
      if (key === 'className') {
        dom.className = newProps[key];
      } else {
        dom.setAttribute(key, newProps[key]);
      }
    }
  });
}

function updateChildren(dom, oldChildren, newChildren) {
  const maxLength = Math.max(oldChildren.length, newChildren.length);

  for (let i = 0; i < maxLength; i++) {
    const oldChild = oldChildren[i];
    const newChild = newChildren[i];

    if (!newChild) {
      // 删除旧子节点
      dom.removeChild(oldChild.dom);
    } else if (!oldChild) {
      // 添加新子节点
      const newDOM = createDOM(newChild);
      dom.appendChild(newDOM);
    } else {
      // 更新子节点
      patch(oldChild, newChild);
    }
  }
}
```

#### Virtual DOM vs 真实DOM

| 特性 | Virtual DOM | 真实DOM |
|-----|------------|---------|
| 操作速度 | 快（JS对象） | 慢（浏览器API） |
| 批量更新 | 支持 | 不支持 |
| Diff计算 | 支持 | 不支持 |
| 跨平台 | 支持 | 不支持 |
| 内存占用 | 较小 | 较大 |

#### 为什么不直接用DOM

**1. 性能问题**
```javascript
// 频繁操作DOM会导致：
// - 多次重排（Reflow）
// - 多次重绘（Repaint）
// - 性能下降

// Virtual DOM可以：
// - 批量更新
// - 最小化DOM操作
// - 只更新变化的部分
```

**2. 开发体验**
```javascript
// 直接操作DOM（命令式）
const div = document.createElement('div');
const span = document.createElement('span');
span.textContent = count;
div.appendChild(span);
document.body.appendChild(div);

// 更新时
span.textContent = newCount;

// Virtual DOM（声明式）
function App() {
  return (
    <div>
      <span>{count}</span>
    </div>
  );
}
// 框架自动处理更新
```

**3. 可维护性**
```javascript
// Virtual DOM让代码更容易理解和维护
// 数据驱动视图
state => VirtualDOM => RealDOM

// 而不是手动管理DOM状态
```

## 3. Keep-alive作用？工作流程是什么？
**问题：** Keep-alive作用？工作流程是什么？

### 解答

#### Keep-alive是什么

Vue的`<keep-alive>`是一个内置组件，用于缓存不活动的组件实例，而不是销毁它们。

#### 作用

**1. 保留组件状态**
```vue
<template>
  <keep-alive>
    <component :is="currentComponent"></component>
  </keep-alive>
</template>

<script>
export default {
  data() {
    return {
      currentComponent: 'ComponentA'
    };
  }
};
</script>
```

**2. 避免重复渲染**
```vue
<!-- 缓存路由组件 -->
<keep-alive>
  <router-view></router-view>
</keep-alive>
```

#### 生命周期钩子

```vue
<script>
export default {
  activated() {
    // 组件被激活时调用
    console.log('组件激活');
  },

  deactivated() {
    // 组件被停用时调用
    console.log('组件停用');
  },

  mounted() {
    // 只在第一次挂载时调用
    console.log('组件挂载');
  },

  unmounted() {
    // keep-alive的组件不会触发unmounted
    console.log('组件卸载');
  }
};
</script>
```

#### 工作流程

**1. 首次渲染**
```
1. 创建组件实例
2. 执行 mounted()
3. 缓存组件实例
4. 执行 activated()
```

**2. 切换到其他组件**
```
1. 执行 deactivated()
2. 组件实例保留在内存中（不销毁）
3. 从DOM中移除
```

**3. 再次渲染**
```
1. 从缓存中获取组件实例
2. 重新渲染到DOM
3. 执行 activated()
```

#### include/exclude

**指定缓存的组件**
```vue
<!-- 只缓存name为a或b的组件 -->
<keep-alive include="a,b">
  <component :is="view"></component>
</keep-alive>

<!-- 使用数组 -->
<keep-alive :include="['a', 'b']">
  <component :is="view"></component>
</keep-alive>

<!-- 使用正则 -->
<keep-alive :include="/a|b/">
  <component :is="view"></component>
</keep-alive>

<!-- 排除name为c的组件 -->
<keep-alive exclude="c">
  <component :is="view"></component>
</keep-alive>
```

#### max属性

```vue
<!-- 最多缓存10个组件 -->
<keep-alive :max="10">
  <component :is="view"></component>
</keep-alive>
```

**缓存策略：LRU（Least Recently Used）**
- 最近使用的组件放在前面
- 超过max时，移除最久未使用的组件

#### 路由缓存

```vue
<!-- App.vue -->
<template>
  <keep-alive>
    <router-view v-if="$route.meta.keepAlive"></router-view>
  </keep-alive>
  <router-view v-if="!$route.meta.keepAlive"></router-view>
</template>

<script>
// router.js
const routes = [
  {
    path: '/list',
    component: List,
    meta: { keepAlive: true }  // 需要缓存
  },
  {
    path: '/detail',
    component: Detail,
    meta: { keepAlive: false }  // 不需要缓存
  }
];
</script>
```

#### 实现原理

```javascript
// 简化的keep-alive实现
const KeepAlive = {
  name: 'KeepAlive',

  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },

  setup(props, { slots }) {
    const cache = new Map();  // 缓存组件实例
    const keys = new Set();   // 缓存的key

    return () => {
      const vnode = slots.default()[0];

      // 获取组件名称
      const name = vnode.type.name;

      // 检查是否需要缓存
      if (
        (props.include && !matches(props.include, name)) ||
        (props.exclude && matches(props.exclude, name))
      ) {
        return vnode;
      }

      // 获取缓存key
      const key = vnode.key == null ? vnode.type : vnode.key;

      // 从缓存中获取
      if (cache.has(key)) {
        vnode.component = cache.get(key);

        // LRU：将key移到最后
        keys.delete(key);
        keys.add(key);
      } else {
        // 添加到缓存
        cache.set(key, vnode.component);
        keys.add(key);

        // 检查缓存数量
        if (props.max && keys.size > parseInt(props.max)) {
          // 删除最久未使用的
          const oldestKey = keys.values().next().value;
          cache.delete(oldestKey);
          keys.delete(oldestKey);
        }
      }

      // 标记为keep-alive组件
      vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE;

      return vnode;
    };
  }
};
```

#### 使用场景

**1. 列表页和详情页**
```vue
<!-- 列表页需要缓存，保留滚动位置和筛选条件 -->
<keep-alive include="List">
  <router-view></router-view>
</keep-alive>
```

**2. Tab切换**
```vue
<keep-alive>
  <component :is="currentTab"></component>
</keep-alive>
```

**3. 表单页**
```vue
<!-- 缓存表单内容，防止误操作丢失 -->
<keep-alive include="Form">
  <router-view></router-view>
</keep-alive>
```

#### 注意事项

**1. 内存占用**
```vue
<!-- 设置max限制缓存数量 -->
<keep-alive :max="10">
  <router-view></router-view>
</keep-alive>
```

**2. 动态组件name**
```javascript
// 组件必须有name属性
export default {
  name: 'MyComponent',  // 必需
  // ...
};
```

**3. 清除缓存**
```javascript
// Vue 3
import { nextTick } from 'vue';

// 强制刷新
this.$forceUpdate();

// 重新创建组件
this.componentKey += 1;
<component :key="componentKey" />
```

## 4. Vue Router中的hash和history模式区别
**问题：** Vue Router中的hash和history模式区别

### 解答

#### Hash模式

**URL格式**
```
http://example.com/#/user/123
http://example.com/#/about
```

**原理**
- 使用URL的hash部分（#后面）
- hash变化不会向服务器发送请求
- 监听`hashchange`事件

**实现**
```javascript
class HashRouter {
  constructor() {
    this.routes = {};
    this.currentUrl = '';

    window.addEventListener('hashchange', this.handleHashChange.bind(this));
    window.addEventListener('load', this.handleHashChange.bind(this));
  }

  route(path, callback) {
    this.routes[path] = callback;
  }

  handleHashChange() {
    this.currentUrl = location.hash.slice(1) || '/';
    this.routes[this.currentUrl] && this.routes[this.currentUrl]();
  }

  push(path) {
    location.hash = path;
  }
}

// 使用
const router = new HashRouter();
router.route('/', () => console.log('Home'));
router.route('/about', () => console.log('About'));
```

#### History模式

**URL格式**
```
http://example.com/user/123
http://example.com/about
```

**原理**
- 使用HTML5 History API
- `pushState()` 和 `replaceState()` 修改URL
- 监听`popstate`事件

**实现**
```javascript
class HistoryRouter {
  constructor() {
    this.routes = {};

    window.addEventListener('popstate', this.handlePopState.bind(this));
    document.addEventListener('click', this.handleClick.bind(this));
  }

  route(path, callback) {
    this.routes[path] = callback;
  }

  handlePopState() {
    const path = location.pathname;
    this.routes[path] && this.routes[path]();
  }

  handleClick(e) {
    if (e.target.tagName === 'A') {
      e.preventDefault();
      const href = e.target.getAttribute('href');
      this.push(href);
    }
  }

  push(path) {
    history.pushState(null, null, path);
    this.routes[path] && this.routes[path]();
  }

  replace(path) {
    history.replaceState(null, null, path);
    this.routes[path] && this.routes[path]();
  }
}

// 使用
const router = new HistoryRouter();
router.route('/', () => console.log('Home'));
router.route('/about', () => console.log('About'));
```

#### 对比

| 特性 | Hash模式 | History模式 |
|-----|---------|-----------|
| URL美观 | ❌ 有# | ✅ 无# |
| 服务器配置 | ✅ 不需要 | ❌ 需要 |
| SEO | ❌ 较差 | ✅ 较好 |
| 兼容性 | ✅ IE8+ | ❌ IE10+ |
| 刷新页面 | ✅ 正常 | ⚠️ 需要配置 |

#### History模式服务器配置

**Nginx**
```nginx
location / {
  try_files $uri $uri/ /index.html;
}
```

**Apache**
```apache
<IfModule mod_rewrite.c>
  RewriteEngine On
  RewriteBase /
  RewriteRule ^index\.html$ - [L]
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteRule . /index.html [L]
</IfModule>
```

**Node.js**
```javascript
const express = require('express');
const path = require('path');
const app = express();

// 静态文件
app.use(express.static('dist'));

// 所有路由都返回index.html
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'dist', 'index.html'));
});
```

#### Vue Router配置

```javascript
import { createRouter, createWebHistory, createWebHashHistory } from 'vue-router';

// History模式
const router = createRouter({
  history: createWebHistory(),
  routes: [...]
});

// Hash模式
const router = createRouter({
  history: createWebHashHistory(),
  routes: [...]
});
```

#### 选择建议

**使用Hash模式**
- 不想配置服务器
- 需要兼容旧浏览器
- 纯静态站点

**使用History模式**
- 追求URL美观
- 需要SEO
- 有服务器控制权
