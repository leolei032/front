# 函数柯里化深度解析

## 1. 柯里化的本质

### 什么是柯里化

```javascript
// 柯里化（Currying）
// 定义：把接受多个参数的函数转换成接受单一参数的函数序列
// 每个函数都返回一个接受下一个参数的新函数，直到所有参数都被提供

// 普通函数
function add(a, b, c) {
  return a + b + c;
}

add(1, 2, 3);  // 6

// 柯里化后
function curriedAdd(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

curriedAdd(1)(2)(3);  // 6

// 或者使用箭头函数
const curriedAdd = a => b => c => a + b + c;

curriedAdd(1)(2)(3);  // 6

// 柯里化的特点：
// 1. 参数复用：固定部分参数，生成新函数
// 2. 延迟执行：收集参数，最后统一执行
// 3. 函数组合：易于组合其他函数
```

### 为什么需要柯里化

```javascript
// 问题场景：多次调用相同参数的函数

// ❌ 不使用柯里化：重复传参
function discount(price, discount) {
  return price * discount;
}

const price1 = discount(100, 0.9);  // 90
const price2 = discount(200, 0.9);  // 180
const price3 = discount(300, 0.9);  // 270
// discount参数重复传递

// ✓ 使用柯里化：参数复用
function curriedDiscount(discount) {
  return function(price) {
    return price * discount;
  };
}

const ninety = curriedDiscount(0.9);

const price1 = ninety(100);  // 90
const price2 = ninety(200);  // 180
const price3 = ninety(300);  // 270
// discount参数被复用

// 柯里化的优势：
// 1. 参数复用：避免重复传参
// 2. 提前返回：生成特定功能的函数
// 3. 延迟执行：收集所有参数后再执行
// 4. 函数组合：与其他函数式编程技术配合
```

## 2. 柯里化手写实现

### 基础版实现

```javascript
// 实现简单的curry函数
function curry(fn) {
  // 获取原函数的参数数量
  const arity = fn.length;

  // 返回柯里化后的函数
  return function curried(...args) {
    // 如果参数数量足够，直接执行
    if (args.length >= arity) {
      return fn.apply(this, args);
    }

    // 否则返回新函数，继续收集参数
    return function(...moreArgs) {
      return curried.apply(this, args.concat(moreArgs));
    };
  };
}

// 测试
function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3));        // 6
console.log(curriedAdd(1, 2)(3));        // 6
console.log(curriedAdd(1)(2, 3));        // 6
console.log(curriedAdd(1, 2, 3));        // 6

// 原理说明：
// 1. curry函数接收原函数fn
// 2. 返回curried函数，收集参数
// 3. 当参数够了，调用fn
// 4. 当参数不够，返回新函数继续收集
```

### 完整版实现（支持占位符）

```javascript
// 完整的curry实现，支持占位符
function curry(fn, arity = fn.length) {
  // 定义占位符
  const placeholder = curry.placeholder;

  // 返回柯里化函数
  return function curried(...args) {
    // 计算实际提供的参数数量（排除占位符）
    const actualArgs = args.filter(arg => arg !== placeholder);

    // 参数足够，执行函数
    if (actualArgs.length >= arity && !args.includes(placeholder)) {
      return fn.apply(this, args);
    }

    // 参数不够，返回新函数
    return function(...nextArgs) {
      // 合并参数，占位符会被替换
      const mergedArgs = args.map(arg =>
        arg === placeholder && nextArgs.length > 0
          ? nextArgs.shift()
          : arg
      ).concat(nextArgs);

      return curried.apply(this, mergedArgs);
    };
  };
}

// 定义占位符
curry.placeholder = Symbol('placeholder');
const _ = curry.placeholder;

// 测试
function sum(a, b, c, d) {
  return a + b + c + d;
}

const curriedSum = curry(sum);

// 正常使用
console.log(curriedSum(1)(2)(3)(4));           // 10
console.log(curriedSum(1, 2)(3, 4));           // 10

// 使用占位符
console.log(curriedSum(_, 2)(1, 3)(4));        // 10
console.log(curriedSum(_, 2, _)(1, 3)(4));     // 10
console.log(curriedSum(_, _, 3)(1)(2)(4));     // 10
```

### 通用curry实现（支持多次调用）

```javascript
// 支持无限次调用的curry
function unlimitedCurry(fn) {
  // 存储已收集的参数
  const storedArgs = [];

  // 柯里化函数
  function curried(...args) {
    // 收集参数
    storedArgs.push(...args);

    // 返回自身，支持链式调用
    return curried;
  }

  // 重写valueOf和toString，实现隐式转换
  curried.valueOf = curried.toString = function() {
    return fn.apply(null, storedArgs);
  };

  return curried;
}

// 测试
function sum(...args) {
  return args.reduce((acc, val) => acc + val, 0);
}

const curriedSum = unlimitedCurry(sum);

console.log(+curriedSum(1)(2)(3));              // 6
console.log(+curriedSum(1, 2)(3));              // 6
console.log(+curriedSum(1)(2, 3, 4)(5));        // 15

// 实现sum(1)(2)(3)...(n)()的效果
function smartCurry(fn) {
  const args = [];

  function curried(...newArgs) {
    if (newArgs.length === 0) {
      // 没有参数，执行函数
      return fn.apply(null, args);
    } else {
      // 有参数，收集并返回自身
      args.push(...newArgs);
      return curried;
    }
  }

  return curried;
}

// 测试
const add = smartCurry(sum);

console.log(add(1)(2)(3)());           // 6
console.log(add(1, 2)(3, 4)());        // 10
console.log(add(1)(2)(3)(4)(5)());     // 15
```

## 3. 柯里化的应用场景

### 案例1：参数复用

```javascript
// 场景：日志记录函数

// 不使用柯里化
function log(level, module, message) {
  console.log(`[${level}] [${module}] ${message}`);
}

log('INFO', 'User', 'User logged in');
log('INFO', 'User', 'User updated profile');
log('INFO', 'User', 'User logged out');
// level和module重复传递

// 使用柯里化
const curriedLog = curry(log);

// 创建特定级别的日志函数
const infoLog = curriedLog('INFO');
const errorLog = curriedLog('ERROR');

// 创建特定模块的日志函数
const userInfoLog = infoLog('User');
const orderInfoLog = infoLog('Order');

// 使用
userInfoLog('User logged in');
userInfoLog('User updated profile');
userInfoLog('User logged out');

orderInfoLog('Order created');
orderInfoLog('Order shipped');

// 更灵活的组合
const userErrorLog = errorLog('User');
userErrorLog('Login failed');

// 实际应用：日志系统
class Logger {
  constructor() {
    this.log = curry((level, module, message, data = {}) => {
      const timestamp = new Date().toISOString();
      const logEntry = {
        timestamp,
        level,
        module,
        message,
        data
      };

      // 根据level决定输出方式
      if (level === 'ERROR') {
        console.error(JSON.stringify(logEntry));
      } else {
        console.log(JSON.stringify(logEntry));
      }
    });
  }

  // 预定义的日志方法
  info = this.log('INFO');
  warn = this.log('WARN');
  error = this.log('ERROR');
}

// 使用
const logger = new Logger();

const userLogger = {
  info: logger.info('User'),
  error: logger.error('User')
};

userLogger.info('User registered', { userId: 123 });
userLogger.error('Registration failed', { error: 'Email exists' });
```

### 案例2：事件处理

```javascript
// 场景：DOM事件处理

// 通用的事件处理curry
const on = curry((event, selector, handler) => {
  return document.querySelector(selector)
    ?.addEventListener(event, handler);
});

// 创建特定事件的处理器
const onClick = on('click');
const onInput = on('input');
const onSubmit = on('submit');

// 使用
onClick('#button', () => {
  console.log('Button clicked');
});

onInput('#search', (e) => {
  console.log('Search value:', e.target.value);
});

onSubmit('#form', (e) => {
  e.preventDefault();
  console.log('Form submitted');
});

// 实际应用：React事件处理
class Component extends React.Component {
  // 柯里化事件处理器
  handleChange = curry((field, e) => {
    this.setState({
      [field]: e.target.value
    });
  });

  render() {
    return (
      <form>
        <input
          onChange={this.handleChange('name')}
          value={this.state.name}
        />
        <input
          onChange={this.handleChange('email')}
          value={this.state.email}
        />
        <input
          onChange={this.handleChange('phone')}
          value={this.state.phone}
        />
      </form>
    );
  }
}

// Hook版本
function useForm(initialValues) {
  const [values, setValues] = useState(initialValues);

  // 柯里化的change handler
  const handleChange = useCallback(
    curry((field, e) => {
      setValues(prev => ({
        ...prev,
        [field]: e.target.value
      }));
    }),
    []
  );

  return [values, handleChange];
}

// 使用
function MyForm() {
  const [values, handleChange] = useForm({
    name: '',
    email: ''
  });

  return (
    <form>
      <input onChange={handleChange('name')} value={values.name} />
      <input onChange={handleChange('email')} value={values.email} />
    </form>
  );
}
```

### 案例3：数据验证

```javascript
// 场景：表单验证

// 通用验证函数
const validate = curry((rule, message, value) => {
  return rule(value) ? null : message;
});

// 定义验证规则
const isRequired = value => value !== null && value !== undefined && value !== '';
const isEmail = value => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
const minLength = min => value => value.length >= min;
const maxLength = max => value => value.length <= max;
const isNumber = value => !isNaN(value);

// 创建验证器
const required = validate(isRequired, 'This field is required');
const email = validate(isEmail, 'Invalid email format');
const min6 = validate(minLength(6), 'Minimum 6 characters');
const max20 = validate(maxLength(20), 'Maximum 20 characters');

// 组合验证器
function composeValidators(...validators) {
  return value => {
    for (const validator of validators) {
      const error = validator(value);
      if (error) return error;
    }
    return null;
  };
}

// 使用
const validateUsername = composeValidators(
  required,
  min6,
  max20
);

const validateEmail = composeValidators(
  required,
  email
);

// 测试
console.log(validateUsername(''));       // "This field is required"
console.log(validateUsername('abc'));    // "Minimum 6 characters"
console.log(validateUsername('abcdef')); // null (valid)

console.log(validateEmail(''));          // "This field is required"
console.log(validateEmail('invalid'));   // "Invalid email format"
console.log(validateEmail('a@b.com'));   // null (valid)

// 实际应用：React表单验证
function FormField({ name, validators, ...props }) {
  const [value, setValue] = useState('');
  const [error, setError] = useState(null);

  const validate = composeValidators(...validators);

  const handleChange = (e) => {
    const newValue = e.target.value;
    setValue(newValue);
    setError(validate(newValue));
  };

  const handleBlur = () => {
    setError(validate(value));
  };

  return (
    <div>
      <input
        {...props}
        value={value}
        onChange={handleChange}
        onBlur={handleBlur}
      />
      {error && <span className="error">{error}</span>}
    </div>
  );
}

// 使用
<FormField
  name="username"
  validators={[required, min6, max20]}
/>
<FormField
  name="email"
  validators={[required, email]}
/>
```

### 案例4：API请求

```javascript
// 场景：HTTP请求封装

// 通用请求函数
const request = curry((method, url, options, data) => {
  return fetch(url, {
    method,
    ...options,
    body: data ? JSON.stringify(data) : undefined,
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers
    }
  }).then(res => res.json());
});

// 创建不同方法的请求函数
const get = request('GET');
const post = request('POST');
const put = request('PUT');
const del = request('DELETE');

// 创建特定API端点的函数
const getUser = get('/api/users');
const createUser = post('/api/users');
const updateUser = put('/api/users');
const deleteUser = del('/api/users');

// 使用
getUser({})({})                  // GET /api/users
  .then(users => console.log(users));

createUser({})({ name: 'John' }) // POST /api/users
  .then(user => console.log(user));

// 带认证的请求
const authOptions = {
  headers: {
    'Authorization': 'Bearer token123'
  }
};

const getAuthUser = getUser(authOptions);
const createAuthUser = createUser(authOptions);

getAuthUser({})
  .then(users => console.log(users));

// 实际应用：API客户端
class ApiClient {
  constructor(baseURL, defaultOptions = {}) {
    this.baseURL = baseURL;
    this.defaultOptions = defaultOptions;

    // 柯里化请求方法
    this.request = curry((method, endpoint, options, data) => {
      return fetch(`${this.baseURL}${endpoint}`, {
        method,
        ...this.defaultOptions,
        ...options,
        body: data ? JSON.stringify(data) : undefined,
        headers: {
          'Content-Type': 'application/json',
          ...this.defaultOptions.headers,
          ...options?.headers
        }
      }).then(res => res.json());
    });

    // 预定义方法
    this.get = this.request('GET');
    this.post = this.request('POST');
    this.put = this.request('PUT');
    this.delete = this.request('DELETE');
  }

  // 创建资源API
  resource(name) {
    const endpoint = `/api/${name}`;

    return {
      list: this.get(endpoint)({}),
      get: id => this.get(`${endpoint}/${id}`)({})({}),
      create: data => this.post(endpoint)({})(data),
      update: (id, data) => this.put(`${endpoint}/${id}`)({})(data),
      delete: id => this.delete(`${endpoint}/${id}`)({})({})
    };
  }
}

// 使用
const api = new ApiClient('https://api.example.com', {
  headers: {
    'Authorization': 'Bearer token123'
  }
});

const users = api.resource('users');

// CRUD操作
users.list({})
  .then(users => console.log(users));

users.get(1)
  .then(user => console.log(user));

users.create({ name: 'John', email: 'john@example.com' })
  .then(user => console.log(user));

users.update(1, { name: 'Jane' })
  .then(user => console.log(user));

users.delete(1)
  .then(() => console.log('Deleted'));
```

### 案例5：函数组合

```javascript
// 场景：数据处理管道

// 通用的map、filter、reduce柯里化
const map = curry((fn, array) => array.map(fn));
const filter = curry((fn, array) => array.filter(fn));
const reduce = curry((fn, initial, array) => array.reduce(fn, initial));

// 组合函数
const compose = (...fns) => x =>
  fns.reduceRight((acc, fn) => fn(acc), x);

const pipe = (...fns) => x =>
  fns.reduce((acc, fn) => fn(acc), x);

// 数据处理函数
const double = map(x => x * 2);
const filterEven = filter(x => x % 2 === 0);
const sum = reduce((acc, x) => acc + x, 0);

// 组合处理管道
const processNumbers = pipe(
  double,        // [1, 2, 3, 4] → [2, 4, 6, 8]
  filterEven,    // [2, 4, 6, 8] → [2, 4, 6, 8]
  sum            // [2, 4, 6, 8] → 20
);

console.log(processNumbers([1, 2, 3, 4]));  // 20

// 实际应用：数据转换管道
const users = [
  { id: 1, name: 'John', age: 25, active: true },
  { id: 2, name: 'Jane', age: 30, active: false },
  { id: 3, name: 'Bob', age: 35, active: true },
  { id: 4, name: 'Alice', age: 28, active: true }
];

// 定义转换函数
const prop = curry((key, obj) => obj[key]);
const filterBy = curry((key, value, array) =>
  array.filter(item => item[key] === value)
);
const mapProp = curry((key, array) => array.map(item => item[key]));
const sortBy = curry((key, array) =>
  [...array].sort((a, b) => a[key] - b[key])
);

// 获取活跃用户的名字，按年龄排序
const getActiveUserNames = pipe(
  filterBy('active', true),   // 过滤活跃用户
  sortBy('age'),              // 按年龄排序
  mapProp('name')             // 提取名字
);

console.log(getActiveUserNames(users));
// ["John", "Alice", "Bob"]

// 计算活跃用户的平均年龄
const getActiveUsersAvgAge = pipe(
  filterBy('active', true),
  mapProp('age'),
  ages => ages.reduce((sum, age) => sum + age, 0) / ages.length
);

console.log(getActiveUsersAvgAge(users));
// 29.33
```

## 4. 柯里化与偏函数

### 区别和联系

```javascript
// 柯里化：将多参数函数转换为单参数函数序列
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    return (...moreArgs) => curried(...args, ...moreArgs);
  };
}

// 偏函数：固定部分参数，返回新函数
function partial(fn, ...fixedArgs) {
  return function(...remainingArgs) {
    return fn.apply(this, [...fixedArgs, ...remainingArgs]);
  };
}

// 对比
function add(a, b, c) {
  return a + b + c;
}

// 柯里化：必须一个一个传参
const curriedAdd = curry(add);
curriedAdd(1)(2)(3);  // 6
curriedAdd(1, 2)(3);  // 6（也可以批量传）

// 偏函数：一次性固定部分参数
const add1 = partial(add, 1);
add1(2, 3);  // 6

const add1And2 = partial(add, 1, 2);
add1And2(3);  // 6

// 区别：
/*
| 特性       | 柯里化            | 偏函数           |
|-----------|------------------|-----------------|
| 参数传递   | 一个一个传        | 批量固定         |
| 返回值     | 总是返回函数      | 参数够了返回结果  |
| 参数顺序   | 从左到右固定      | 可以任意固定     |
| 灵活性     | 更灵活           | 较简单          |
*/

// 偏函数的高级实现（支持占位符）
function advancedPartial(fn, ...fixedArgs) {
  const placeholder = advancedPartial.placeholder;

  return function(...args) {
    const finalArgs = fixedArgs.map(arg =>
      arg === placeholder && args.length > 0
        ? args.shift()
        : arg
    ).concat(args);

    return fn.apply(this, finalArgs);
  };
}

advancedPartial.placeholder = Symbol('placeholder');
const _ = advancedPartial.placeholder;

// 使用
function greet(greeting, separator, name) {
  return `${greeting}${separator}${name}`;
}

const greetWithHello = advancedPartial(greet, 'Hello', _, 'World');
console.log(greetWithHello(', '));  // "Hello, World"

const greetJohn = advancedPartial(greet, _, ', ', 'John');
console.log(greetJohn('Hi'));  // "Hi, John"
```

## 5. 柯里化性能优化

### 缓存优化

```javascript
// 带缓存的柯里化
function memoizedCurry(fn) {
  const cache = new Map();

  function curried(...args) {
    // 生成缓存key
    const key = args.join(',');

    // 检查缓存
    if (cache.has(key)) {
      return cache.get(key);
    }

    // 参数足够，执行并缓存
    if (args.length >= fn.length) {
      const result = fn.apply(this, args);
      cache.set(key, result);
      return result;
    }

    // 参数不够，返回新函数
    const partial = (...moreArgs) =>
      curried.apply(this, args.concat(moreArgs));

    cache.set(key, partial);
    return partial;
  }

  return curried;
}

// 测试
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const curriedFib = memoizedCurry(fibonacci);

console.time('first');
console.log(curriedFib(40));  // 很慢
console.timeEnd('first');

console.time('second');
console.log(curriedFib(40));  // 很快（使用缓存）
console.timeEnd('second');
```

### 性能对比

```javascript
// 性能测试：柯里化 vs 普通函数

// 普通函数
function normalAdd(a, b, c, d) {
  return a + b + c + d;
}

// 柯里化函数
const curriedAdd = curry((a, b, c, d) => a + b + c + d);

// 测试
const iterations = 1000000;

console.time('normal');
for (let i = 0; i < iterations; i++) {
  normalAdd(1, 2, 3, 4);
}
console.timeEnd('normal');
// normal: ~10ms

console.time('curried');
for (let i = 0; i < iterations; i++) {
  curriedAdd(1)(2)(3)(4);
}
console.timeEnd('curried');
// curried: ~150ms

console.time('curried-batch');
for (let i = 0; i < iterations; i++) {
  curriedAdd(1, 2, 3, 4);
}
console.timeEnd('curried-batch');
// curried-batch: ~15ms

// 结论：
// 1. 柯里化有性能开销（函数调用次数多）
// 2. 批量传参可以减少开销
// 3. 缓存可以提升重复调用的性能
// 4. 适合场景：参数复用 > 性能要求

// 优化建议：
// 1. 不要过度柯里化（参数少于3个通常不需要）
// 2. 性能敏感场景避免使用
// 3. 考虑使用偏函数代替
// 4. 使用缓存优化重复调用
```

## 6. 实战综合案例

### Redux中间件实现

```javascript
// Redux中间件的柯里化应用

// 中间件签名：store => next => action
// 三层柯里化

// 日志中间件
const logger = store => next => action => {
  console.log('Dispatching:', action);
  const result = next(action);
  console.log('Next state:', store.getState());
  return result;
};

// 异步中间件
const thunk = store => next => action => {
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState);
  }
  return next(action);
};

// 应用中间件
function applyMiddleware(...middlewares) {
  return createStore => (reducer, initialState) => {
    const store = createStore(reducer, initialState);

    // 创建dispatch链
    let dispatch = store.dispatch;

    const middlewareAPI = {
      getState: store.getState,
      dispatch: action => dispatch(action)
    };

    // 应用中间件（从右到左）
    const chain = middlewares.map(middleware =>
      middleware(middlewareAPI)
    );

    dispatch = compose(...chain)(store.dispatch);

    return {
      ...store,
      dispatch
    };
  };
}

// compose实现
function compose(...fns) {
  if (fns.length === 0) return arg => arg;
  if (fns.length === 1) return fns[0];
  return fns.reduce((a, b) => (...args) => a(b(...args)));
}

// 使用
const store = applyMiddleware(logger, thunk)(createStore)(
  reducer,
  initialState
);
```

### Express中间件实现

```javascript
// Express风格的中间件系统

class App {
  constructor() {
    this.middlewares = [];
  }

  // 添加中间件（柯里化）
  use(middleware) {
    this.middlewares.push(middleware);
    return this;  // 链式调用
  }

  // 处理请求
  async handle(req, res) {
    let index = 0;

    // next函数（柯里化的精髓）
    const next = async () => {
      if (index >= this.middlewares.length) return;

      const middleware = this.middlewares[index++];
      await middleware(req, res, next);
    };

    await next();
  }
}

// 中间件示例
const app = new App();

// 日志中间件
app.use(async (req, res, next) => {
  console.log(`${req.method} ${req.url}`);
  await next();
});

// 认证中间件
app.use(async (req, res, next) => {
  if (req.headers.authorization) {
    req.user = { id: 1, name: 'John' };
    await next();
  } else {
    res.status(401).send('Unauthorized');
  }
});

// 路由中间件
app.use(async (req, res, next) => {
  if (req.url === '/api/user') {
    res.json(req.user);
  } else {
    await next();
  }
});

// 错误处理中间件
app.use(async (req, res, next) => {
  try {
    await next();
  } catch (error) {
    res.status(500).send(error.message);
  }
});
```

柯里化是函数式编程的核心技术之一，深入理解柯里化对于编写可组合、可复用的代码至关重要！
