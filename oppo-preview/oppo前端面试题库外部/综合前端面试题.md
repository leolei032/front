# 综合前端面试题

## HTTP和网络相关

### 1. 常见Http请求头

#### 解答

HTTP请求头包含请求的元信息。

**常见请求头**
```http
GET /api/users HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: application/json, text/plain, */*
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Content-Type: application/json
Content-Length: 123
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
Cookie: sessionId=abc123; token=xyz789
Referer: https://www.example.com/page
Origin: https://www.example.com
Cache-Control: no-cache
If-None-Match: "etag-value"
If-Modified-Since: Wed, 21 Oct 2020 07:28:00 GMT
```

**请求头详解**

1. **Host** - 目标服务器域名
```http
Host: www.example.com
```

2. **User-Agent** - 客户端信息
```http
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
```

3. **Accept** - 期望接收的内容类型
```http
Accept: application/json
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
```

4. **Accept-Language** - 期望的语言
```http
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
```

5. **Accept-Encoding** - 支持的编码格式
```http
Accept-Encoding: gzip, deflate, br
```

6. **Content-Type** - 请求体的媒体类型
```http
Content-Type: application/json
Content-Type: application/x-www-form-urlencoded
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary
Content-Type: text/plain
```

7. **Content-Length** - 请求体长度
```http
Content-Length: 348
```

8. **Authorization** - 身份认证信息
```http
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=
```

9. **Cookie** - Cookie信息
```http
Cookie: sessionId=abc123; userId=456; theme=dark
```

10. **Referer** - 来源页面URL
```http
Referer: https://www.example.com/products
```

11. **Origin** - 请求来源（CORS）
```http
Origin: https://www.example.com
```

12. **Connection** - 连接管理
```http
Connection: keep-alive
Connection: close
```

13. **Cache-Control** - 缓存控制
```http
Cache-Control: no-cache
Cache-Control: max-age=3600
Cache-Control: no-store
```

14. **If-None-Match** - 条件请求（ETag）
```http
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

15. **If-Modified-Since** - 条件请求（时间）
```http
If-Modified-Since: Wed, 21 Oct 2020 07:28:00 GMT
```

**JavaScript设置请求头**
```javascript
// Fetch API
fetch('/api/users', {
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token123',
    'X-Custom-Header': 'custom-value'
  }
});

// XMLHttpRequest
const xhr = new XMLHttpRequest();
xhr.open('GET', '/api/users');
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.setRequestHeader('Authorization', 'Bearer token123');
xhr.send();

// Axios
axios.get('/api/users', {
  headers: {
    'Authorization': 'Bearer token123'
  }
});

// Axios全局设置
axios.defaults.headers.common['Authorization'] = 'Bearer token123';
axios.defaults.headers.post['Content-Type'] = 'application/json';
```

### 2. 403、301、302是什么

#### 解答

这些是HTTP状态码，表示请求的处理结果。

**HTTP状态码分类**
- 1xx: 信息性状态码
- 2xx: 成功状态码
- 3xx: 重定向状态码
- 4xx: 客户端错误状态码
- 5xx: 服务器错误状态码

#### 301 Moved Permanently（永久重定向）

```http
HTTP/1.1 301 Moved Permanently
Location: https://www.new-site.com
```

**特点：**
- 资源永久移动到新位置
- 浏览器会缓存重定向
- SEO权重会转移到新URL
- 后续请求直接访问新URL

```javascript
// Node.js设置301
res.writeHead(301, {
  'Location': 'https://www.new-site.com'
});
res.end();

// Express
res.redirect(301, 'https://www.new-site.com');

// Nginx配置
server {
  listen 80;
  server_name old-site.com;
  return 301 https://new-site.com$request_uri;
}
```

#### 302 Found（临时重定向）

```http
HTTP/1.1 302 Found
Location: https://www.example.com/temp-page
```

**特点：**
- 资源临时移动
- 浏览器不会缓存
- SEO权重不会转移
- 后续请求仍访问原URL

```javascript
// Node.js设置302
res.writeHead(302, {
  'Location': '/temp-page'
});
res.end();

// Express
res.redirect('/temp-page');  // 默认302

// 使用场景
app.get('/login', (req, res) => {
  if (req.user) {
    res.redirect(302, '/dashboard');  // 已登录，临时重定向
  } else {
    res.render('login');
  }
});
```

#### 403 Forbidden（禁止访问）

```http
HTTP/1.1 403 Forbidden
Content-Type: text/html

<html>
  <body>
    <h1>Access Denied</h1>
  </body>
</html>
```

**特点：**
- 服务器理解请求但拒绝执行
- 通常是权限不足
- 与401不同，即使认证也无法访问

```javascript
// Node.js返回403
res.writeHead(403, {
  'Content-Type': 'application/json'
});
res.end(JSON.stringify({
  error: 'Access Denied',
  message: 'You do not have permission to access this resource'
}));

// Express中间件
function checkPermission(req, res, next) {
  if (!req.user || !req.user.hasPermission('admin')) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'Admin access required'
    });
  }
  next();
}

app.get('/admin', checkPermission, (req, res) => {
  res.json({ data: 'admin data' });
});

// Nginx配置
location /admin {
  deny all;  # 返回403
}
```

#### 其他常见状态码

**2xx 成功**
```javascript
// 200 OK - 请求成功
res.status(200).json({ data: 'success' });

// 201 Created - 资源已创建
res.status(201).json({ id: newUser.id });

// 204 No Content - 成功但无内容返回
res.status(204).end();
```

**3xx 重定向**
```javascript
// 304 Not Modified - 资源未修改（缓存有效）
res.status(304).end();

// 307 Temporary Redirect - 临时重定向（保持请求方法）
res.redirect(307, '/new-location');

// 308 Permanent Redirect - 永久重定向（保持请求方法）
res.redirect(308, '/new-location');
```

**4xx 客户端错误**
```javascript
// 400 Bad Request - 请求语法错误
res.status(400).json({ error: 'Invalid request' });

// 401 Unauthorized - 未认证
res.status(401).json({ error: 'Authentication required' });

// 403 Forbidden - 禁止访问
res.status(403).json({ error: 'Access denied' });

// 404 Not Found - 资源不存在
res.status(404).json({ error: 'Not found' });

// 405 Method Not Allowed - 方法不允许
res.status(405).json({ error: 'Method not allowed' });

// 429 Too Many Requests - 请求过多
res.status(429).json({ error: 'Rate limit exceeded' });
```

**5xx 服务器错误**
```javascript
// 500 Internal Server Error - 服务器内部错误
res.status(500).json({ error: 'Internal server error' });

// 502 Bad Gateway - 网关错误
res.status(502).json({ error: 'Bad gateway' });

// 503 Service Unavailable - 服务不可用
res.status(503).json({ error: 'Service unavailable' });

// 504 Gateway Timeout - 网关超时
res.status(504).json({ error: 'Gateway timeout' });
```

### 3. HTTPS怎么建立安全通道

#### 解答

HTTPS通过TLS/SSL协议建立加密通道。

#### HTTPS握手过程

```
客户端                               服务器
  |                                    |
  |  1. Client Hello                  |
  |----------------------------------->|
  |  (支持的加密套件、随机数)             |
  |                                    |
  |  2. Server Hello                  |
  |<-----------------------------------|
  |  (选择的加密套件、随机数、证书)        |
  |                                    |
  |  3. 验证证书                        |
  |  (检查CA签名、有效期、域名)           |
  |                                    |
  |  4. Client Key Exchange           |
  |----------------------------------->|
  |  (预主密钥，用服务器公钥加密)          |
  |                                    |
  |  5. 生成会话密钥                     |
  |  (使用三个随机数生成)                 |
  |                                    |
  |  6. Finished                      |
  |----------------------------------->|
  |  (使用会话密钥加密的握手消息)          |
  |                                    |
  |  7. Finished                      |
  |<-----------------------------------|
  |  (服务器确认)                        |
  |                                    |
  |  8. 加密通信                        |
  |<---------------------------------->|
```

**详细步骤**

1. **Client Hello（客户端问候）**
```javascript
// 客户端发送
{
  version: 'TLS 1.3',
  cipherSuites: [
    'TLS_AES_128_GCM_SHA256',
    'TLS_AES_256_GCM_SHA384',
    'TLS_CHACHA20_POLY1305_SHA256'
  ],
  clientRandom: '28位随机数',
  supportedGroups: ['x25519', 'secp256r1'],
  signatureAlgorithms: ['rsa_pss_rsae_sha256']
}
```

2. **Server Hello（服务器问候）**
```javascript
// 服务器响应
{
  version: 'TLS 1.3',
  selectedCipherSuite: 'TLS_AES_256_GCM_SHA384',
  serverRandom: '28位随机数',
  certificate: '服务器证书',
  publicKey: '服务器公钥'
}
```

3. **证书验证**
```javascript
// 客户端验证证书
function verifyCertificate(cert) {
  // 1. 检查证书是否由可信CA签发
  const isValidCA = checkCA(cert.issuer);

  // 2. 检查证书是否在有效期内
  const now = new Date();
  const isValidDate = now >= cert.notBefore && now <= cert.notAfter;

  // 3. 检查域名是否匹配
  const isValidDomain = cert.subject.CN === window.location.hostname;

  // 4. 检查证书是否被吊销
  const isNotRevoked = checkCRL(cert) && checkOCSP(cert);

  return isValidCA && isValidDate && isValidDomain && isNotRevoked;
}
```

4. **密钥交换**
```javascript
// 客户端生成预主密钥
const preMasterSecret = generateRandom(48);

// 使用服务器公钥加密
const encryptedPreMasterSecret = rsaEncrypt(preMasterSecret, serverPublicKey);

// 发送给服务器
sendToServer(encryptedPreMasterSecret);

// 服务器解密
const preMasterSecret = rsaDecrypt(encryptedData, serverPrivateKey);
```

5. **生成会话密钥**
```javascript
// 双方使用相同算法生成会话密钥
function generateSessionKeys(preMasterSecret, clientRandom, serverRandom) {
  const masterSecret = PRF(
    preMasterSecret,
    'master secret',
    clientRandom + serverRandom
  );

  const keyBlock = PRF(
    masterSecret,
    'key expansion',
    serverRandom + clientRandom
  );

  return {
    clientWriteKey: keyBlock.slice(0, 16),
    serverWriteKey: keyBlock.slice(16, 32),
    clientWriteIV: keyBlock.slice(32, 48),
    serverWriteIV: keyBlock.slice(48, 64)
  };
}
```

6. **加密通信**
```javascript
// 使用AES-GCM加密
function encryptData(data, key, iv) {
  const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
  let encrypted = cipher.update(data, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  const authTag = cipher.getAuthTag();
  return { encrypted, authTag };
}

// 解密
function decryptData(encrypted, key, iv, authTag) {
  const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);
  decipher.setAuthTag(authTag);
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}
```

#### 证书链验证

```
根证书CA (Root CA)
  ↓ 签名
中间证书CA (Intermediate CA)
  ↓ 签名
服务器证书 (example.com)
```

```javascript
// 证书链验证
function verifyCertificateChain(serverCert, intermediateCerts, rootCerts) {
  let currentCert = serverCert;

  // 验证每一级证书
  for (const intermediateCert of intermediateCerts) {
    // 验证签名
    if (!verifySignature(currentCert, intermediateCert.publicKey)) {
      return false;
    }
    currentCert = intermediateCert;
  }

  // 验证根证书
  for (const rootCert of rootCerts) {
    if (verifySignature(currentCert, rootCert.publicKey)) {
      return true;
    }
  }

  return false;
}
```

#### Node.js HTTPS服务器

```javascript
const https = require('https');
const fs = require('fs');

// 读取证书
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('certificate.pem'),
  ca: fs.readFileSync('ca-certificate.pem')  // 可选
};

// 创建HTTPS服务器
const server = https.createServer(options, (req, res) => {
  res.writeHead(200);
  res.end('Hello Secure World!');
});

server.listen(443, () => {
  console.log('HTTPS server running on port 443');
});
```

#### 自签名证书（开发环境）

```bash
# 生成私钥
openssl genrsa -out private-key.pem 2048

# 生成证书签名请求
openssl req -new -key private-key.pem -out csr.pem

# 生成自签名证书
openssl x509 -req -in csr.pem -signkey private-key.pem -out certificate.pem -days 365

# 查看证书信息
openssl x509 -in certificate.pem -text -noout
```

### 4. 前端如何和后端联调

#### 解答

前后端联调涉及多种方式和工具。

#### 1. 本地开发环境联调

**Webpack Dev Server代理**
```javascript
// webpack.config.js
module.exports = {
  devServer: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',  // 后端服务地址
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        },
        onProxyReq: (proxyReq, req, res) => {
          console.log('Proxying:', req.method, req.url);
        }
      }
    }
  }
};

// 前端请求
fetch('/api/users')  // 实际请求: http://localhost:8080/users
  .then(res => res.json());
```

**Vite代理配置**
```javascript
// vite.config.js
export default {
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  }
};
```

#### 2. Mock数据

**Mock Service Worker（MSW）**
```javascript
// mocks/handlers.js
import { rest } from 'msw';

export const handlers = [
  // 拦截GET请求
  rest.get('/api/users', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json([
        { id: 1, name: 'John' },
        { id: 2, name: 'Jane' }
      ])
    );
  }),

  // 拦截POST请求
  rest.post('/api/users', (req, res, ctx) => {
    const { name } = req.body;
    return res(
      ctx.status(201),
      ctx.json({ id: 3, name })
    );
  }),

  // 模拟错误
  rest.get('/api/error', (req, res, ctx) => {
    return res(
      ctx.status(500),
      ctx.json({ error: 'Internal Server Error' })
    );
  }),

  // 模拟延迟
  rest.get('/api/slow', (req, res, ctx) => {
    return res(
      ctx.delay(2000),  // 延迟2秒
      ctx.json({ data: 'slow response' })
    );
  })
];

// mocks/browser.js
import { setupWorker } from 'msw';
import { handlers } from './handlers';

export const worker = setupWorker(...handlers);

// src/index.js
if (process.env.NODE_ENV === 'development') {
  const { worker } = await import('./mocks/browser');
  worker.start();
}
```

**JSON Server（快速Mock）**
```bash
# 安装
npm install -g json-server

# 创建db.json
{
  "users": [
    { "id": 1, "name": "John" },
    { "id": 2, "name": "Jane" }
  ],
  "posts": [
    { "id": 1, "title": "Post 1", "userId": 1 }
  ]
}

# 启动
json-server --watch db.json --port 3001

# 使用
fetch('http://localhost:3001/users')
  .then(res => res.json());
```

#### 3. API文档和契约

**Swagger/OpenAPI**
```yaml
# openapi.yaml
openapi: 3.0.0
info:
  title: User API
  version: 1.0.0

paths:
  /api/users:
    get:
      summary: Get all users
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/User'

components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: integer
        name:
          type: string
        email:
          type: string
```

**TypeScript类型生成**
```bash
# 从OpenAPI生成TypeScript类型
npx openapi-typescript openapi.yaml --output types/api.ts

# 使用生成的类型
import type { paths } from './types/api';

type GetUsersResponse = paths['/api/users']['get']['responses']['200']['content']['application/json'];

const users: GetUsersResponse = await fetch('/api/users').then(r => r.json());
```

#### 4. 环境配置

```javascript
// .env.development
VITE_API_URL=http://localhost:8080
VITE_USE_MOCK=false

// .env.production
VITE_API_URL=https://api.example.com
VITE_USE_MOCK=false

// api.ts
const API_URL = import.meta.env.VITE_API_URL;
const USE_MOCK = import.meta.env.VITE_USE_MOCK === 'true';

export async function getUsers() {
  if (USE_MOCK) {
    return mockUsers;
  }

  const response = await fetch(`${API_URL}/users`);
  return response.json();
}
```

#### 5. 调试工具

**Chrome DevTools Network**
```javascript
// 查看请求详情
// 1. 打开DevTools -> Network标签
// 2. 刷新页面
// 3. 点击请求查看：
//    - Headers（请求头/响应头）
//    - Preview（预览响应）
//    - Response（原始响应）
//    - Timing（时间线）

// 过滤请求
// - XHR: 只看Ajax请求
// - Fetch: 只看Fetch请求
// - JS/CSS/Img: 按资源类型过滤

// 模拟慢速网络
// Network -> Throttling -> Slow 3G
```

**Postman联调**
```javascript
// 1. 创建Collection
// 2. 添加请求
// 3. 设置环境变量
// 4. 编写测试脚本

// Tests标签（验证响应）
pm.test("Status code is 200", function () {
  pm.response.to.have.status(200);
});

pm.test("Response has data", function () {
  const jsonData = pm.response.json();
  pm.expect(jsonData).to.have.property('data');
});

// Pre-request Script（请求前处理）
const timestamp = Date.now();
pm.environment.set("timestamp", timestamp);
```

#### 6. 错误处理和日志

```javascript
// 封装请求方法
async function request(url, options = {}) {
  const startTime = Date.now();

  try {
    console.log(`[API] ${options.method || 'GET'} ${url}`);

    const response = await fetch(url, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      }
    });

    const duration = Date.now() - startTime;
    console.log(`[API] ${response.status} ${url} (${duration}ms)`);

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Request failed');
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error(`[API Error] ${url}:`, error);

    // 上报错误
    reportError({
      url,
      method: options.method,
      error: error.message,
      duration: Date.now() - startTime
    });

    throw error;
  }
}

// 使用
const users = await request('/api/users');
```

#### 7. WebSocket联调

```javascript
// 前端
const ws = new WebSocket('ws://localhost:8080');

ws.onopen = () => {
  console.log('Connected');
  ws.send(JSON.stringify({ type: 'ping' }));
};

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log('Received:', data);
};

ws.onerror = (error) => {
  console.error('WebSocket error:', error);
};

ws.onclose = () => {
  console.log('Disconnected');
};

// 后端（Node.js）
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', (ws) => {
  console.log('Client connected');

  ws.on('message', (message) => {
    const data = JSON.parse(message);
    console.log('Received:', data);

    // 回复
    ws.send(JSON.stringify({ type: 'pong' }));
  });
});
```

## CSS相关

### 1. CSS3+position:sticky

#### 解答

`position: sticky` 是CSS3的粘性定位，结合了相对定位和固定定位的特点。

**基础用法**
```css
.sticky-element {
  position: sticky;
  top: 0;  /* 距离顶部的偏移量 */
}
```

**完整示例**
```html
<div class="container">
  <div class="header sticky">Sticky Header</div>
  <div class="content">
    <!-- 长内容 -->
  </div>
</div>

<style>
.container {
  height: 2000px;
}

.sticky {
  position: sticky;
  top: 0;
  background: white;
  padding: 20px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  z-index: 100;
}

/* 滚动到指定位置时"粘住" */
/* 在父容器范围内有效 */
</style>
```

**工作原理**
```
┌─────────────────────┐
│   Viewport          │
├─────────────────────┤  ← top: 0
│  [Sticky Element]   │  ← 粘在这里
├─────────────────────┤
│                     │
│   Content           │
│                     │
└─────────────────────┘
```

**多个sticky元素**
```html
<div class="table-wrapper">
  <table>
    <thead>
      <tr class="sticky-row">
        <th class="sticky-col">Name</th>
        <th>Age</th>
        <th>Email</th>
      </tr>
    </thead>
    <tbody>
      <!-- 表格内容 -->
    </tbody>
  </table>
</div>

<style>
.table-wrapper {
  max-height: 500px;
  overflow: auto;
}

/* 粘性表头 */
.sticky-row {
  position: sticky;
  top: 0;
  background: #f0f0f0;
  z-index: 2;
}

/* 粘性列 */
.sticky-col {
  position: sticky;
  left: 0;
  background: #f0f0f0;
  z-index: 3;  /* 列的z-index要比行高 */
}

/* 左上角单元格同时粘住行和列 */
.sticky-row .sticky-col {
  z-index: 4;
}
</style>
```

**底部粘性**
```css
.sticky-footer {
  position: sticky;
  bottom: 0;  /* 粘在底部 */
  background: white;
  padding: 20px;
}
```

**注意事项**
```css
/* 1. 父元素不能有overflow: hidden/auto/scroll */
.parent {
  /* ❌ 会导致sticky失效 */
  /* overflow: hidden; */
}

/* 2. 必须指定至少一个方向的偏移 */
.sticky {
  position: sticky;
  /* ✅ 必须设置 top/bottom/left/right */
  top: 0;
}

/* 3. sticky元素的父容器必须有高度 */
.container {
  min-height: 100vh;  /* ✅ 必须有高度 */
}

/* 4. 需要设置z-index避免被覆盖 */
.sticky {
  position: sticky;
  top: 0;
  z-index: 100;  /* ✅ 设置层级 */
}
```

**实用场景**

1. **粘性导航栏**
```css
.navbar {
  position: sticky;
  top: 0;
  background: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  z-index: 1000;
}
```

2. **侧边栏**
```css
.sidebar {
  position: sticky;
  top: 20px;
  align-self: flex-start;  /* 防止拉伸 */
}
```

3. **滚动提示**
```css
.scroll-indicator {
  position: sticky;
  top: 0;
  height: 3px;
  background: linear-gradient(to right, blue var(--scroll), transparent 0);
}
```

**兼容性处理**
```javascript
// 检测是否支持sticky
function supportSticky() {
  const element = document.createElement('div');
  element.style.position = 'sticky';
  return element.style.position === 'sticky';
}

// Polyfill或降级处理
if (!supportSticky()) {
  // 使用fixed定位 + scroll监听
  window.addEventListener('scroll', () => {
    const element = document.querySelector('.sticky');
    const rect = element.getBoundingClientRect();

    if (rect.top <= 0) {
      element.classList.add('is-stuck');
    } else {
      element.classList.remove('is-stuck');
    }
  });
}
```

### 2. div垂直水平居中（flex、绝对定位）

#### 解答

有多种方法实现div的垂直水平居中。

#### 1. Flexbox（推荐）

```css
/* 父元素 */
.parent {
  display: flex;
  justify-content: center;  /* 水平居中 */
  align-items: center;      /* 垂直居中 */
  height: 100vh;
}

.child {
  width: 200px;
  height: 200px;
}
```

```html
<div class="parent">
  <div class="child">居中内容</div>
</div>
```

#### 2. 绝对定位 + Transform

```css
.parent {
  position: relative;
  height: 100vh;
}

.child {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 200px;
  height: 200px;
}
```

#### 3. 绝对定位 + Margin Auto

```css
.parent {
  position: relative;
  height: 100vh;
}

.child {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  margin: auto;
  width: 200px;   /* 必须指定宽高 */
  height: 200px;
}
```

#### 4. Grid布局

```css
.parent {
  display: grid;
  place-items: center;  /* 简写 */
  /* 或 */
  /* justify-items: center; */
  /* align-items: center; */
  height: 100vh;
}

.child {
  width: 200px;
  height: 200px;
}
```

#### 5. Table布局

```css
.parent {
  display: table;
  width: 100%;
  height: 100vh;
}

.child-wrapper {
  display: table-cell;
  vertical-align: middle;
  text-align: center;
}

.child {
  display: inline-block;
  width: 200px;
  height: 200px;
}
```

```html
<div class="parent">
  <div class="child-wrapper">
    <div class="child">居中内容</div>
  </div>
</div>
```

#### 6. Line-height（单行文本）

```css
.parent {
  text-align: center;
  line-height: 100vh;
  height: 100vh;
}

.child {
  display: inline-block;
  vertical-align: middle;
  line-height: normal;  /* 重置line-height */
}
```

#### 各方法对比

| 方法 | 优点 | 缺点 | 适用场景 |
|-----|------|------|---------|
| **Flexbox** | 简单、强大、响应式 | 旧浏览器不支持 | 现代项目首选 |
| **定位+Transform** | 兼容性好 | 需要父元素定位 | 固定宽高元素 |
| **定位+Margin** | 简单 | 必须知道宽高 | 固定尺寸 |
| **Grid** | 最简洁 | 兼容性要求高 | 现代项目 |
| **Table** | 兼容性最好 | 语义不佳 | 老项目 |

#### 实际应用示例

**Modal居中**
```css
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  padding: 20px;
  border-radius: 8px;
  max-width: 500px;
  max-height: 80vh;
  overflow: auto;
}
```

**Loading居中**
```css
.loading-container {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  background: rgba(255,255,255,0.9);
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #f3f3f3;
  border-top: 4px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
```

**响应式居中**
```css
.responsive-center {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  padding: 20px;
}

.content {
  width: 100%;
  max-width: 600px;
}

@media (max-width: 768px) {
  .responsive-center {
    align-items: flex-start;  /* 移动端顶部对齐 */
    padding-top: 60px;
  }
}
```

