# 原型链继承深度解析

## 1. 原型和原型链回顾

### 核心概念

```javascript
// 原型链的本质：对象之间的继承关系

// 三个核心概念
/*
1. prototype: 函数的原型对象（只有函数有）
2. __proto__: 对象的原型指针（所有对象都有）
3. constructor: 原型对象的构造函数引用
*/

// 示例
function Person(name) {
  this.name = name;
}

Person.prototype.sayName = function() {
  console.log(this.name);
};

const person = new Person('John');

// 原型链关系
console.log(person.__proto__ === Person.prototype);  // true
console.log(Person.prototype.constructor === Person);  // true
console.log(Person.prototype.__proto__ === Object.prototype);  // true
console.log(Object.prototype.__proto__ === null);  // true

// 完整的原型链
/*
person
  → person.__proto__ (Person.prototype)
    → Person.prototype.__proto__ (Object.prototype)
      → Object.prototype.__proto__ (null)
*/

// 属性查找机制
person.sayName();  // 查找顺序:
// 1. person自身 ✗
// 2. person.__proto__ (Person.prototype) ✓ 找到

person.toString();  // 查找顺序:
// 1. person自身 ✗
// 2. person.__proto__ (Person.prototype) ✗
// 3. Person.prototype.__proto__ (Object.prototype) ✓ 找到
```

## 2. 六种继承方式

### 1. 原型链继承

```javascript
// 方式1: 原型链继承
// 核心思想：子类的prototype指向父类的实例

function Parent() {
  this.name = 'parent';
  this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function() {
  return this.name;
};

function Child() {
  this.type = 'child';
}

// 关键：让Child的prototype指向Parent的实例
Child.prototype = new Parent();

// 使用
const child1 = new Child();
console.log(child1.getName());  // 'parent'

const child2 = new Child();
child1.colors.push('black');
console.log(child2.colors);  // ['red', 'blue', 'green', 'black']

// 优点：
// 1. 简单易懂
// 2. 可以继承父类原型的方法

// 缺点：
// 1. 引用类型的属性被所有实例共享
// 2. 创建子类实例时，无法向父类构造函数传参

// 原型链图示
/*
child1
  → child1.__proto__ (Child.prototype，即Parent的实例)
    → Child.prototype.__proto__ (Parent.prototype)
      → Parent.prototype.__proto__ (Object.prototype)
        → Object.prototype.__proto__ (null)
*/

// 问题演示
function Parent() {
  this.colors = ['red', 'blue'];
}

function Child() {}
Child.prototype = new Parent();

const child1 = new Child();
const child2 = new Child();

child1.colors.push('green');
console.log(child1.colors);  // ['red', 'blue', 'green']
console.log(child2.colors);  // ['red', 'blue', 'green'] ✗ 污染了child2
```

### 2. 构造函数继承（经典继承）

```javascript
// 方式2: 构造函数继承
// 核心思想：在子类构造函数中调用父类构造函数

function Parent(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function() {
  return this.name;
};

function Child(name, age) {
  // 关键：调用父类构造函数，绑定this
  Parent.call(this, name);
  this.age = age;
}

// 使用
const child1 = new Child('John', 18);
const child2 = new Child('Jane', 20);

child1.colors.push('black');
console.log(child1.colors);  // ['red', 'blue', 'green', 'black']
console.log(child2.colors);  // ['red', 'blue', 'green'] ✓ 没有污染

console.log(child1.getName);  // undefined ✗ 无法继承原型方法

// 优点：
// 1. 避免了引用类型的属性被所有实例共享
// 2. 可以在子类构造函数中向父类传参

// 缺点：
// 1. 只能继承父类的实例属性和方法，不能继承原型属性/方法
// 2. 每次创建子类实例都要执行父类构造函数
// 3. 方法都定义在构造函数中，每次创建实例都会创建一遍方法（无法复用）

// 内存问题演示
function Parent() {
  this.sayHello = function() {
    console.log('Hello');
  };
}

function Child() {
  Parent.call(this);
}

const child1 = new Child();
const child2 = new Child();

console.log(child1.sayHello === child2.sayHello);  // false
// 每个实例都有自己的sayHello方法，浪费内存
```

### 3. 组合继承（最常用）

```javascript
// 方式3: 组合继承
// 核心思想：结合原型链继承和构造函数继承

function Parent(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function() {
  return this.name;
};

function Child(name, age) {
  // 第二次调用Parent()
  // 继承实例属性
  Parent.call(this, name);
  this.age = age;
}

// 第一次调用Parent()
// 继承原型方法
Child.prototype = new Parent();
Child.prototype.constructor = Child;

Child.prototype.getAge = function() {
  return this.age;
};

// 使用
const child1 = new Child('John', 18);
const child2 = new Child('Jane', 20);

child1.colors.push('black');
console.log(child1.colors);  // ['red', 'blue', 'green', 'black']
console.log(child2.colors);  // ['red', 'blue', 'green'] ✓

console.log(child1.getName());  // 'John' ✓
console.log(child1.getAge());  // 18 ✓

// 优点：
// 1. 可以继承实例属性/方法，也可以继承原型属性/方法
// 2. 不存在引用类型的属性共享问题
// 3. 可以向父类传参
// 4. 函数可以复用

// 缺点：
// 1. 调用了两次父类构造函数，浪费性能
// 2. 子类原型上会有一份父类实例的属性（多余）

// 问题演示
function Parent(name) {
  this.name = name;
  console.log('Parent constructor called');
}

function Child(name, age) {
  Parent.call(this, name);  // 第二次调用
  this.age = age;
}

Child.prototype = new Parent();  // 第一次调用
Child.prototype.constructor = Child;

const child = new Child('John', 18);
// 输出:
// Parent constructor called  (第一次)
// Parent constructor called  (第二次)

// Child.prototype上有多余的属性
console.log(Child.prototype.name);  // undefined (多余)
console.log(child.name);  // 'John'
```

### 4. 原型式继承

```javascript
// 方式4: 原型式继承
// 核心思想：利用一个空对象作为中介，将某个对象直接赋值给空对象的原型

function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}

// 或使用ES5的Object.create()
// Object.create() 就是原型式继承的实现

const parent = {
  name: 'parent',
  colors: ['red', 'blue', 'green'],
  getName: function() {
    return this.name;
  }
};

// 使用自定义的object函数
const child1 = object(parent);
child1.name = 'child1';
child1.colors.push('black');

// 使用Object.create()
const child2 = Object.create(parent);
child2.name = 'child2';

console.log(child1.getName());  // 'child1'
console.log(child2.getName());  // 'child2'
console.log(child1.colors);  // ['red', 'blue', 'green', 'black']
console.log(child2.colors);  // ['red', 'blue', 'green', 'black'] ✗ 共享

// 优点：
// 1. 不需要创建构造函数
// 2. 实现了对象间的继承

// 缺点：
// 1. 引用类型的属性被所有实例共享（同原型链继承）
// 2. 无法传递参数

// Object.create()的第二个参数
const child3 = Object.create(parent, {
  name: {
    value: 'child3',
    writable: true,
    enumerable: true,
    configurable: true
  },
  age: {
    value: 18,
    writable: true,
    enumerable: true,
    configurable: true
  }
});

console.log(child3.name);  // 'child3'
console.log(child3.age);  // 18
```

### 5. 寄生式继承

```javascript
// 方式5: 寄生式继承
// 核心思想：在原型式继承的基础上，增强对象，返回构造函数

function createAnother(original) {
  // 创建一个新对象
  const clone = Object.create(original);

  // 增强对象
  clone.sayHi = function() {
    console.log('Hi');
  };

  // 返回对象
  return clone;
}

const parent = {
  name: 'parent',
  colors: ['red', 'blue', 'green']
};

const child1 = createAnother(parent);
const child2 = createAnother(parent);

child1.sayHi();  // 'Hi'
child2.sayHi();  // 'Hi'

console.log(child1.sayHi === child2.sayHi);  // false ✗ 无法复用

// 优点：
// 1. 可以在不影响原对象的情况下，对对象进行增强

// 缺点：
// 1. 跟构造函数继承一样，每次创建对象都会创建一遍方法（无法复用）
// 2. 引用类型的属性被所有实例共享

// 实际应用：工厂函数
function createPerson(name) {
  const person = Object.create({
    sayName: function() {
      console.log(this.name);
    }
  });

  person.name = name;

  // 增强对象
  person.greet = function() {
    console.log(`Hello, I'm ${this.name}`);
  };

  return person;
}

const john = createPerson('John');
const jane = createPerson('Jane');

john.greet();  // "Hello, I'm John"
jane.greet();  // "Hello, I'm Jane"
```

### 6. 寄生组合式继承（最佳）

```javascript
// 方式6: 寄生组合式继承
// 核心思想：通过寄生方式，砍掉父类的实例属性，避免组合继承的两次调用

function inheritPrototype(child, parent) {
  // 创建父类原型的副本
  const prototype = Object.create(parent.prototype);

  // 增强对象，弥补因重写原型而失去的constructor属性
  prototype.constructor = child;

  // 指定对象，将新创建的对象赋值给子类的原型
  child.prototype = prototype;
}

function Parent(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function() {
  return this.name;
};

function Child(name, age) {
  // 继承实例属性（只调用一次Parent构造函数）
  Parent.call(this, name);
  this.age = age;
}

// 继承原型方法（不调用Parent构造函数）
inheritPrototype(Child, Parent);

Child.prototype.getAge = function() {
  return this.age;
};

// 使用
const child1 = new Child('John', 18);
const child2 = new Child('Jane', 20);

child1.colors.push('black');
console.log(child1.colors);  // ['red', 'blue', 'green', 'black']
console.log(child2.colors);  // ['red', 'blue', 'green'] ✓

console.log(child1.getName());  // 'John' ✓
console.log(child1.getAge());  // 18 ✓

// Child.prototype没有多余的属性
console.log(Child.prototype.name);  // undefined ✓
console.log(Child.prototype.colors);  // undefined ✓

// 优点：
// 1. 只调用一次父类构造函数
// 2. 避免在子类原型上创建不必要的属性
// 3. 原型链保持不变
// 4. 能够正常使用instanceof和isPrototypeOf()

// 缺点：
// 实现相对复杂

// 这是最理想的继承方式，被认为是引用类型最理想的继承范式

// 完整实现（加上注释）
function inheritPrototype(child, parent) {
  // 步骤1: 创建对象 - 创建父类原型的副本
  const prototype = Object.create(parent.prototype);

  // 步骤2: 增强对象 - 弥补因重写原型而失去的constructor
  prototype.constructor = child;

  // 步骤3: 指定对象 - 将新创建的对象赋值给子类原型
  child.prototype = prototype;
}

// 对比组合继承
function Parent(name) {
  this.name = name;
  console.log('Parent constructor called');
}

// 组合继承
function Child1(name, age) {
  Parent.call(this, name);  // 第二次调用
  this.age = age;
}
Child1.prototype = new Parent();  // 第一次调用
Child1.prototype.constructor = Child1;

const child1 = new Child1('John', 18);
// 输出: Parent constructor called (两次)

// 寄生组合式继承
function Child2(name, age) {
  Parent.call(this, name);  // 只调用一次
  this.age = age;
}
inheritPrototype(Child2, Parent);

const child2 = new Child2('Jane', 20);
// 输出: Parent constructor called (一次)
```

## 3. ES6 Class继承

### Class语法糖

```javascript
// ES6的Class本质上是寄生组合式继承的语法糖

// ES6 Class
class Parent {
  constructor(name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
  }

  getName() {
    return this.name;
  }

  static staticMethod() {
    return 'static method';
  }
}

class Child extends Parent {
  constructor(name, age) {
    // 必须先调用super()
    super(name);  // 相当于Parent.call(this, name)
    this.age = age;
  }

  getAge() {
    return this.age;
  }

  // 重写父类方法
  getName() {
    return `Child: ${super.getName()}`;
  }
}

// 使用
const child = new Child('John', 18);
console.log(child.getName());  // 'Child: John'
console.log(child.getAge());  // 18

// 静态方法也被继承
console.log(Child.staticMethod());  // 'static method'

// Class与寄生组合式继承的对比
// ES5
function Parent(name) {
  this.name = name;
}
Parent.prototype.getName = function() {
  return this.name;
};
Parent.staticMethod = function() {
  return 'static method';
};

function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}
inheritPrototype(Child, Parent);
// 继承静态方法
Child.staticMethod = Parent.staticMethod;

Child.prototype.getAge = function() {
  return this.age;
};

// Class的特点
/*
1. 必须使用new调用
2. 类的所有方法都定义在原型上
3. 类的内部所有方法都是不可枚举的
4. 类的方法不能被new调用
5. 必须先调用super()才能使用this
*/

// 验证
class Test {
  method() {}
}

// 1. 必须使用new
Test();  // TypeError: Class constructor Test cannot be invoked without 'new'

// 2. 方法在原型上
console.log(Test.prototype.method);  // function

// 3. 不可枚举
console.log(Object.keys(Test.prototype));  // []

// 4. 方法不能被new
new Test.prototype.method();  // TypeError

// 5. super必须先调用
class Child extends Test {
  constructor() {
    console.log(this);  // ReferenceError: Must call super constructor
    super();
  }
}
```

### super关键字

```javascript
// super关键字详解

class Parent {
  constructor(name) {
    this.name = name;
  }

  getName() {
    return this.name;
  }

  static staticMethod() {
    return 'Parent static';
  }
}

class Child extends Parent {
  constructor(name, age) {
    // 1. super作为函数：调用父类构造函数
    super(name);  // 必须在使用this之前调用
    this.age = age;
  }

  // 2. super作为对象：在普通方法中指向父类原型
  getInfo() {
    // super.getName() 相当于 Parent.prototype.getName.call(this)
    return `${super.getName()}, ${this.age}`;
  }

  // 3. super作为对象：在静态方法中指向父类
  static getStatic() {
    return super.staticMethod();
  }
}

const child = new Child('John', 18);
console.log(child.getInfo());  // 'John, 18'
console.log(Child.getStatic());  // 'Parent static'

// super的陷阱
class A {
  constructor() {
    this.x = 1;
  }

  print() {
    console.log(this.x);
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
    super.x = 3;  // 通过super赋值给this.x
    console.log(super.x);  // undefined（super.x读取的是A.prototype.x）
    console.log(this.x);  // 3
  }

  m() {
    super.print();  // 相当于A.prototype.print.call(this)
  }
}

const b = new B();
b.m();  // 2（this指向b）

// super的实现原理（简化）
class Child extends Parent {
  constructor(name, age) {
    super(name);
    this.age = age;
  }

  getInfo() {
    return super.getName();
  }
}

// 相当于
function Child(name, age) {
  // super(name)
  Parent.call(this, name);
  this.age = age;
}

inheritPrototype(Child, Parent);

Child.prototype.getInfo = function() {
  // super.getName()
  return Parent.prototype.getName.call(this);
};
```

## 4. 继承方式对比

### 完整对比表

```javascript
// 六种继承方式对比

/*
┌─────────────────┬──────────┬──────────┬──────────┬──────────┬──────────┐
│      方式        │引用共享  │传参      │方法复用  │原型链    │构造调用  │
├─────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
│ 原型链继承       │    ✗     │    ✗     │    ✓     │    ✓     │    1次   │
├─────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
│ 构造函数继承     │    ✓     │    ✓     │    ✗     │    ✗     │   每次   │
├─────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
│ 组合继承         │    ✓     │    ✓     │    ✓     │    ✓     │    2次   │
├─────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
│ 原型式继承       │    ✗     │    ✗     │    ✓     │    ✓     │    0次   │
├─────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
│ 寄生式继承       │    ✗     │    ✗     │    ✗     │    ✓     │    0次   │
├─────────────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
│ 寄生组合式继承   │    ✓     │    ✓     │    ✓     │    ✓     │    1次   │
└─────────────────┴──────────┴──────────┴──────────┴──────────┴──────────┘

✓ = 支持/解决
✗ = 不支持/存在问题
*/

// 详细说明
const comparison = {
  '原型链继承': {
    优点: ['简单易懂', '可以复用父类方法'],
    缺点: ['引用类型共享', '无法传参'],
    适用场景: '不需要传参且没有引用类型的简单继承'
  },

  '构造函数继承': {
    优点: ['避免引用类型共享', '可以传参'],
    缺点: ['无法继承原型方法', '方法无法复用'],
    适用场景: '只需要继承实例属性，不需要继承方法'
  },

  '组合继承': {
    优点: ['可以传参', '方法复用', '原型链完整'],
    缺点: ['调用两次父类构造函数', '子类原型有多余属性'],
    适用场景: '最常用的继承方式（次优）'
  },

  '原型式继承': {
    优点: ['不需要构造函数'],
    缺点: ['引用类型共享', '无法传参'],
    适用场景: '对象间的简单继承'
  },

  '寄生式继承': {
    优点: ['可以增强对象'],
    缺点: ['方法无法复用'],
    适用场景: '需要在继承基础上增强对象'
  },

  '寄生组合式继承': {
    优点: ['只调用一次父类构造函数', '原型链完整', '最佳性能'],
    缺点: ['实现相对复杂'],
    适用场景: '最理想的继承方式（推荐）'
  }
};

// 性能对比
/*
场景：创建10000个子类实例

原型链继承:
- 内存: 低（共享引用类型）
- 速度: 快
- 问题: 引用类型污染

构造函数继承:
- 内存: 高（每个实例都有方法副本）
- 速度: 慢
- 问题: 无法继承原型方法

组合继承:
- 内存: 中（多余的原型属性）
- 速度: 中
- 问题: 调用两次构造函数

寄生组合式继承:
- 内存: 低（无多余属性）
- 速度: 快
- 问题: 无

结论：寄生组合式继承 > 组合继承 > 其他
*/
```

## 5. 实战最佳实践

### 现代JavaScript继承

```javascript
// 推荐：使用ES6 Class + 工具函数

// 1. 基础继承
class Animal {
  constructor(name) {
    this.name = name;
  }

  eat() {
    console.log(`${this.name} is eating`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name);
    this.breed = breed;
  }

  bark() {
    console.log(`${this.name} is barking`);
  }
}

// 2. 多层继承
class Puppy extends Dog {
  constructor(name, breed, age) {
    super(name, breed);
    this.age = age;
  }

  play() {
    console.log(`${this.name} is playing`);
  }
}

// 3. Mixin模式（实现多继承）
const FlyMixin = {
  fly() {
    console.log(`${this.name} is flying`);
  }
};

const SwimMixin = {
  swim() {
    console.log(`${this.name} is swimming`);
  }
};

// 应用多个Mixin
function applyMixins(targetClass, ...mixins) {
  mixins.forEach(mixin => {
    Object.assign(targetClass.prototype, mixin);
  });
}

class Bird extends Animal {
  constructor(name) {
    super(name);
  }
}

applyMixins(Bird, FlyMixin);

const bird = new Bird('Tweety');
bird.eat();  // 'Tweety is eating'
bird.fly();  // 'Tweety is flying'

// 4. 组合优于继承
// 避免深层继承，使用组合
class Engine {
  start() {
    console.log('Engine started');
  }
}

class Wheel {
  roll() {
    console.log('Wheel rolling');
  }
}

class Car {
  constructor() {
    this.engine = new Engine();
    this.wheels = [new Wheel(), new Wheel(), new Wheel(), new Wheel()];
  }

  drive() {
    this.engine.start();
    this.wheels.forEach(wheel => wheel.roll());
  }
}

const car = new Car();
car.drive();

// 5. 工厂函数 + 闭包（避免继承）
function createCounter(initialValue = 0) {
  let count = initialValue;

  return {
    increment() {
      count++;
      return count;
    },
    decrement() {
      count--;
      return count;
    },
    getCount() {
      return count;
    }
  };
}

const counter = createCounter(10);
console.log(counter.increment());  // 11
console.log(counter.getCount());  // 11

// 6. TypeScript中的继承
/*
interface IAnimal {
  name: string;
  eat(): void;
}

abstract class Animal implements IAnimal {
  constructor(public name: string) {}

  abstract eat(): void;

  sleep(): void {
    console.log(`${this.name} is sleeping`);
  }
}

class Dog extends Animal {
  constructor(name: string, public breed: string) {
    super(name);
  }

  eat(): void {
    console.log(`${this.name} is eating`);
  }

  bark(): void {
    console.log(`${this.name} is barking`);
  }
}
*/

// 7. 继承检测
const dog = new Dog('Buddy', 'Golden Retriever');

console.log(dog instanceof Dog);  // true
console.log(dog instanceof Animal);  // true
console.log(Dog.prototype.isPrototypeOf(dog));  // true
console.log(Animal.prototype.isPrototypeOf(dog));  // true

// 8. 性能优化
// 避免频繁修改原型链
// ❌ 差
class MyClass {
  constructor() {
    this.method = function() {};  // 每个实例都有副本
  }
}

// ✓ 好
class MyClass {
  method() {}  // 在原型上，所有实例共享
}
```

原型链继承是JavaScript的核心机制，理解六种继承方式及其优缺点对于编写高质量代码至关重要！
