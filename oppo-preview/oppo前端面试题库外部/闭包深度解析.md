# 闭包深度解析

## 1. 闭包的本质

### 什么是闭包

闭包（Closure）是JavaScript中最重要也最容易被误解的概念之一。

```javascript
// 闭包的本质：函数 + 函数能够访问的外部变量
function createCounter() {
  let count = 0;  // 外部变量

  return function() {  // 内部函数
    count++;
    return count;
  };
}

const counter = createCounter();
console.log(counter());  // 1
console.log(counter());  // 2
console.log(counter());  // 3

// 关键点：
// 1. counter函数可以访问外部变量count
// 2. 即使createCounter已经执行完毕，count仍然存在
// 3. count被"封闭"在闭包中，外部无法直接访问
```

### 闭包的形成条件

```javascript
// 条件1：函数嵌套
// 条件2：内部函数引用外部函数的变量
// 条件3：内部函数被返回或以某种方式保存

// 示例1：返回函数
function outer() {
  const name = 'closure';
  return function inner() {
    console.log(name);  // 引用外部变量
  };
}
const fn = outer();  // fn形成闭包
fn();  // 'closure'

// 示例2：回调函数
function setupHandler() {
  const message = 'Hello';

  document.getElementById('btn').addEventListener('click', function() {
    console.log(message);  // 闭包：回调函数引用外部变量
  });
}

// 示例3：定时器
function delayedGreeting() {
  const greeting = 'Hi';

  setTimeout(function() {
    console.log(greeting);  // 闭包：定时器回调引用外部变量
  }, 1000);
}

// ❌ 不是闭包：内部函数没有引用外部变量
function notClosure() {
  const x = 1;
  return function() {
    const y = 2;
    console.log(y);  // 只使用自己的变量
  };
}
```

### 闭包的内存结构

```javascript
// 词法作用域和作用域链
function createStack() {
  const items = [];  // 存储在闭包的[[Scope]]中

  return {
    push(item) {
      items.push(item);
    },
    pop() {
      return items.pop();
    },
    size() {
      return items.length;
    }
  };
}

const stack = createStack();

// 内存结构分析：
/*
全局执行上下文
  └─ stack (指向闭包对象)

闭包对象
  ├─ push: function
  ├─ pop: function
  ├─ size: function
  └─ [[Scope]]: 词法环境
        └─ items: []  (持久存在于内存中)

关键点：
1. items数组不在全局作用域，外部无法直接访问
2. 三个方法共享同一个items引用
3. 只要stack对象存在，items就不会被回收
*/

stack.push(1);
stack.push(2);
console.log(stack.size());  // 2
console.log(stack.pop());   // 2
```

## 2. 闭包的应用场景

### 场景1：数据私有化（模块化）

```javascript
// 使用闭包实现私有变量
const BankAccount = (function() {
  // 私有变量
  let balance = 0;
  const transactionHistory = [];

  // 私有方法
  function logTransaction(type, amount) {
    transactionHistory.push({
      type,
      amount,
      date: new Date(),
      balance
    });
  }

  // 公开API
  return {
    deposit(amount) {
      if (amount <= 0) {
        throw new Error('金额必须大于0');
      }
      balance += amount;
      logTransaction('deposit', amount);
      return balance;
    },

    withdraw(amount) {
      if (amount > balance) {
        throw new Error('余额不足');
      }
      balance -= amount;
      logTransaction('withdraw', amount);
      return balance;
    },

    getBalance() {
      return balance;
    },

    getHistory() {
      // 返回副本，防止外部修改
      return [...transactionHistory];
    }
  };
})();

// 使用
BankAccount.deposit(100);
BankAccount.withdraw(30);
console.log(BankAccount.getBalance());  // 70

// ❌ 无法直接访问私有变量
console.log(BankAccount.balance);  // undefined
console.log(BankAccount.transactionHistory);  // undefined
```

### 场景2：函数柯里化

```javascript
// 基础柯里化
function curry(fn) {
  return function curried(...args) {
    // 闭包：保存已收集的参数
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }

    return function(...moreArgs) {
      return curried.apply(this, [...args, ...moreArgs]);
    };
  };
}

// 应用示例
function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3));  // 6
console.log(curriedAdd(1, 2)(3));  // 6
console.log(curriedAdd(1)(2, 3));  // 6

// 实战：API请求
function request(baseUrl) {
  return function(endpoint) {
    return function(method) {
      return function(data) {
        return fetch(`${baseUrl}${endpoint}`, {
          method,
          body: JSON.stringify(data)
        });
      };
    };
  };
}

// 创建API实例
const api = request('https://api.example.com');
const userApi = api('/users');
const postUser = userApi('POST');

// 使用
postUser({ name: 'John', age: 30 });

// 或者使用curry简化
const apiRequest = curry((baseUrl, endpoint, method, data) => {
  return fetch(`${baseUrl}${endpoint}`, {
    method,
    body: JSON.stringify(data)
  });
});

const createUser = apiRequest('https://api.example.com', '/users', 'POST');
createUser({ name: 'John' });
```

### 场景3：缓存/记忆化

```javascript
// 斐波那契数列优化
function createMemoizedFibonacci() {
  const cache = {};  // 闭包：缓存计算结果

  return function fibonacci(n) {
    if (n in cache) {
      console.log(`从缓存读取 fib(${n})`);
      return cache[n];
    }

    console.log(`计算 fib(${n})`);

    if (n <= 1) {
      cache[n] = n;
      return n;
    }

    const result = fibonacci(n - 1) + fibonacci(n - 2);
    cache[n] = result;
    return result;
  };
}

const fib = createMemoizedFibonacci();
console.log(fib(10));  // 多次计算
console.log(fib(10));  // 直接从缓存读取

// 通用记忆化函数
function memoize(fn) {
  const cache = new Map();

  return function(...args) {
    const key = JSON.stringify(args);

    if (cache.has(key)) {
      return cache.get(key);
    }

    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// 应用：昂贵的计算
const expensiveCalculation = memoize((a, b) => {
  console.log('执行昂贵的计算...');
  let result = 0;
  for (let i = 0; i < 1000000; i++) {
    result += a * b;
  }
  return result;
});

console.log(expensiveCalculation(2, 3));  // 执行计算
console.log(expensiveCalculation(2, 3));  // 从缓存读取
```

### 场景4：函数工厂

```javascript
// 创建特定行为的函数
function createMultiplier(multiplier) {
  return function(num) {
    return num * multiplier;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15

// 实战：创建验证器
function createValidator(pattern, errorMessage) {
  return function(value) {
    if (!pattern.test(value)) {
      throw new Error(errorMessage);
    }
    return true;
  };
}

const validateEmail = createValidator(
  /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
  '邮箱格式不正确'
);

const validatePhone = createValidator(
  /^1[3-9]\d{9}$/,
  '手机号格式不正确'
);

try {
  validateEmail('test@example.com');  // ✓
  validatePhone('13812345678');       // ✓
  validateEmail('invalid');           // ✗ 抛出错误
} catch (error) {
  console.error(error.message);
}

// 高级：创建带配置的组件
function createComponent(config) {
  const { name, defaultProps = {}, state = {} } = config;

  return {
    render(props = {}) {
      const finalProps = { ...defaultProps, ...props };
      console.log(`Rendering ${name} with:`, finalProps, state);
    },

    setState(newState) {
      Object.assign(state, newState);
      this.render();
    },

    getState() {
      return { ...state };
    }
  };
}

const Button = createComponent({
  name: 'Button',
  defaultProps: { color: 'blue', size: 'medium' },
  state: { clicked: 0 }
});

Button.render({ label: 'Click me' });
Button.setState({ clicked: 1 });
```

### 场景5：事件处理和循环

```javascript
// ❌ 经典错误：循环中的闭包陷阱
function createButtons() {
  const buttons = [];

  for (var i = 0; i < 5; i++) {
    const button = document.createElement('button');
    button.textContent = `Button ${i}`;

    // 错误：所有按钮都会显示5
    button.addEventListener('click', function() {
      console.log(`Clicked button ${i}`);
    });

    buttons.push(button);
  }

  return buttons;
}

// 为什么？因为i是同一个变量，循环结束时i=5
// 所有闭包都引用同一个i

// ✅ 解决方案1：使用let（块级作用域）
function createButtonsCorrect1() {
  const buttons = [];

  for (let i = 0; i < 5; i++) {  // let代替var
    const button = document.createElement('button');
    button.textContent = `Button ${i}`;

    button.addEventListener('click', function() {
      console.log(`Clicked button ${i}`);
    });

    buttons.push(button);
  }

  return buttons;
}

// ✅ 解决方案2：立即执行函数（IIFE）
function createButtonsCorrect2() {
  const buttons = [];

  for (var i = 0; i < 5; i++) {
    (function(index) {  // 创建新的作用域
      const button = document.createElement('button');
      button.textContent = `Button ${index}`;

      button.addEventListener('click', function() {
        console.log(`Clicked button ${index}`);
      });

      buttons.push(button);
    })(i);
  }

  return buttons;
}

// ✅ 解决方案3：使用bind
function createButtonsCorrect3() {
  const buttons = [];

  for (var i = 0; i < 5; i++) {
    const button = document.createElement('button');
    button.textContent = `Button ${i}`;

    function handleClick(index) {
      console.log(`Clicked button ${index}`);
    }

    button.addEventListener('click', handleClick.bind(null, i));
    buttons.push(button);
  }

  return buttons;
}
```

## 3. 闭包的内存泄漏问题

### 什么情况会造成内存泄漏

```javascript
// ❌ 问题1：意外的全局变量
function createLeak1() {
  const largeData = new Array(1000000).fill('data');

  // 忘记用let/const，创建了全局变量
  leaked = function() {
    console.log(largeData[0]);
  };
}

createLeak1();
// largeData无法被回收，因为全局的leaked函数引用了它

// ❌ 问题2：未清理的定时器
function createLeak2() {
  const largeData = new Array(1000000).fill('data');

  setInterval(function() {
    console.log(largeData.length);
  }, 1000);

  // 定时器一直运行，largeData无法被回收
}

// ❌ 问题3：未清理的事件监听器
function createLeak3() {
  const element = document.getElementById('container');
  const largeData = new Array(1000000).fill('data');

  function handleClick() {
    console.log(largeData.length);
  }

  element.addEventListener('click', handleClick);

  // 如果element被移除但监听器未清理，largeData仍然存在
}

// ❌ 问题4：DOM引用
function createLeak4() {
  const elements = [];

  for (let i = 0; i < 100; i++) {
    const element = document.createElement('div');
    element.innerHTML = 'Item ' + i;
    document.body.appendChild(element);

    // 保存DOM引用
    elements.push(element);
  }

  // 即使从DOM中移除，elements数组仍保存引用
  document.body.innerHTML = '';
  // elements中的DOM节点无法被回收
}
```

### 如何避免内存泄漏

```javascript
// ✅ 解决方案1：清理全局变量
function noLeak1() {
  const largeData = new Array(1000000).fill('data');

  const localFn = function() {
    console.log(largeData[0]);
  };

  // 使用完后清理
  localFn();
  return null;  // 不返回闭包
}

// ✅ 解决方案2：清理定时器
function noLeak2() {
  const largeData = new Array(1000000).fill('data');

  const timer = setInterval(function() {
    console.log(largeData.length);
  }, 1000);

  // 返回清理函数
  return function cleanup() {
    clearInterval(timer);
  };
}

const cleanup2 = noLeak2();
// 使用完后调用
cleanup2();

// ✅ 解决方案3：清理事件监听器
function noLeak3() {
  const element = document.getElementById('container');
  const largeData = new Array(1000000).fill('data');

  function handleClick() {
    console.log(largeData.length);
  }

  element.addEventListener('click', handleClick);

  // 返回清理函数
  return function cleanup() {
    element.removeEventListener('click', handleClick);
  };
}

const cleanup3 = noLeak3();
cleanup3();

// ✅ 解决方案4：使用WeakMap避免DOM引用泄漏
function noLeak4() {
  const elements = new WeakMap();  // 使用WeakMap

  for (let i = 0; i < 100; i++) {
    const element = document.createElement('div');
    element.innerHTML = 'Item ' + i;
    document.body.appendChild(element);

    // WeakMap不会阻止垃圾回收
    elements.set(element, { index: i });
  }

  // DOM移除后，WeakMap中的引用会自动清理
  document.body.innerHTML = '';
}

// ✅ React Hooks中的清理
function useEventListener(eventName, handler, element = window) {
  const savedHandler = React.useRef();

  React.useEffect(() => {
    savedHandler.current = handler;
  }, [handler]);

  React.useEffect(() => {
    const eventListener = (event) => savedHandler.current(event);
    element.addEventListener(eventName, eventListener);

    // 清理函数
    return () => {
      element.removeEventListener(eventName, eventListener);
    };
  }, [eventName, element]);
}
```

### 内存泄漏检测工具

```javascript
// Chrome DevTools Memory Profiler使用
// 1. 打开开发者工具 → Memory标签
// 2. 选择"Heap snapshot"
// 3. 执行操作，拍摄快照
// 4. 对比多个快照，查找未释放的对象

// 代码中的手动检测
function detectMemoryLeak() {
  const before = performance.memory.usedJSHeapSize;

  // 执行可能泄漏的操作
  const leakyArray = [];
  for (let i = 0; i < 1000000; i++) {
    leakyArray.push(new Array(100).fill('data'));
  }

  const after = performance.memory.usedJSHeapSize;
  const leaked = after - before;

  console.log(`内存增加: ${(leaked / 1024 / 1024).toFixed(2)} MB`);

  // 如果leaked持续增长，可能存在内存泄漏
}

// 使用performance.measureUserAgentSpecificMemory() (Chrome 89+)
async function measureMemory() {
  if (performance.measureUserAgentSpecificMemory) {
    const result = await performance.measureUserAgentSpecificMemory();
    console.log('详细内存信息:', result);
  }
}
```

## 4. 实战案例

### 案例1：实现一个完整的模块系统

```javascript
const ModuleSystem = (function() {
  // 私有：存储所有模块
  const modules = {};

  return {
    // 定义模块
    define(name, dependencies, factory) {
      if (modules[name]) {
        throw new Error(`模块 ${name} 已存在`);
      }

      modules[name] = {
        dependencies,
        factory,
        exports: null,
        loaded: false
      };
    },

    // 加载模块
    require(name) {
      const module = modules[name];

      if (!module) {
        throw new Error(`模块 ${name} 不存在`);
      }

      // 如果已加载，直接返回
      if (module.loaded) {
        return module.exports;
      }

      // 递归加载依赖
      const deps = module.dependencies.map(dep => this.require(dep));

      // 执行工厂函数
      module.exports = module.factory(...deps);
      module.loaded = true;

      return module.exports;
    },

    // 查看所有模块
    list() {
      return Object.keys(modules);
    }
  };
})();

// 使用
ModuleSystem.define('math', [], function() {
  return {
    add: (a, b) => a + b,
    multiply: (a, b) => a * b
  };
});

ModuleSystem.define('calculator', ['math'], function(math) {
  return {
    calculate(a, b, operation) {
      if (operation === 'add') return math.add(a, b);
      if (operation === 'multiply') return math.multiply(a, b);
    }
  };
});

const calc = ModuleSystem.require('calculator');
console.log(calc.calculate(5, 3, 'add'));  // 8
```

### 案例2：实现防抖和节流（带取消和立即执行）

```javascript
// 完整的防抖实现
function debounce(func, wait, options = {}) {
  let timeout, result;
  const { leading = false, trailing = true, maxWait } = options;
  let lastCallTime = 0;
  let lastInvokeTime = 0;

  function invokeFunc(time) {
    const args = lastArgs;
    const thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;

    return (
      lastCallTime === 0 ||
      timeSinceLastCall >= wait ||
      (maxWait && timeSinceLastInvoke >= maxWait)
    );
  }

  let lastArgs, lastThis;

  function debounced(...args) {
    const time = Date.now();
    const isInvoking = shouldInvoke(time);

    lastArgs = args;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (!timeout && leading) {
        result = invokeFunc(lastCallTime);
      }

      if (maxWait) {
        timeout = setTimeout(() => invokeFunc(Date.now()), wait);
      }
    }

    if (!timeout && trailing) {
      timeout = setTimeout(() => {
        result = invokeFunc(Date.now());
        timeout = null;
      }, wait);
    }

    return result;
  }

  // 取消
  debounced.cancel = function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = undefined;
  };

  // 立即执行
  debounced.flush = function() {
    return timeout ? invokeFunc(Date.now()) : result;
  };

  return debounced;
}

// 使用示例
const saveData = debounce(
  (data) => {
    console.log('保存数据:', data);
    return fetch('/api/save', {
      method: 'POST',
      body: JSON.stringify(data)
    });
  },
  500,
  { leading: false, trailing: true, maxWait: 2000 }
);

// 用户快速输入
saveData({ text: 'a' });
saveData({ text: 'ab' });
saveData({ text: 'abc' });
// 只在停止输入500ms后执行一次

// 可以取消
saveData.cancel();

// 可以立即执行
saveData.flush();
```

### 案例3：React中的闭包陷阱和解决方案

```javascript
// ❌ 问题：useEffect中的闭包陷阱
function BrokenCounter() {
  const [count, setCount] = React.useState(0);

  React.useEffect(() => {
    const timer = setInterval(() => {
      // 闭包捕获了初始的count=0
      console.log('Count:', count);  // 永远打印0
      setCount(count + 1);  // 永远设置为1
    }, 1000);

    return () => clearInterval(timer);
  }, []);  // 空依赖数组

  return <div>{count}</div>;
}

// ✅ 解决方案1：函数式更新
function FixedCounter1() {
  const [count, setCount] = React.useState(0);

  React.useEffect(() => {
    const timer = setInterval(() => {
      setCount(c => {
        console.log('Count:', c);  // 获取最新值
        return c + 1;
      });
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  return <div>{count}</div>;
}

// ✅ 解决方案2：使用useRef
function FixedCounter2() {
  const [count, setCount] = React.useState(0);
  const countRef = React.useRef(count);

  // 保持countRef最新
  React.useEffect(() => {
    countRef.current = count;
  });

  React.useEffect(() => {
    const timer = setInterval(() => {
      console.log('Count:', countRef.current);
      setCount(countRef.current + 1);
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  return <div>{count}</div>;
}

// ✅ 解决方案3：自定义Hook
function useInterval(callback, delay) {
  const savedCallback = React.useRef();

  // 保存最新的callback
  React.useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  // 设置定时器
  React.useEffect(() => {
    if (delay !== null) {
      const id = setInterval(() => savedCallback.current(), delay);
      return () => clearInterval(id);
    }
  }, [delay]);
}

function FixedCounter3() {
  const [count, setCount] = React.useState(0);

  useInterval(() => {
    console.log('Count:', count);
    setCount(count + 1);
  }, 1000);

  return <div>{count}</div>;
}
```

### 案例4：实现一个发布-订阅系统

```javascript
function createEventEmitter() {
  // 闭包：存储所有事件和监听器
  const events = new Map();

  return {
    // 订阅事件
    on(event, listener) {
      if (!events.has(event)) {
        events.set(event, []);
      }
      events.get(event).push(listener);

      // 返回取消订阅函数
      return () => {
        const listeners = events.get(event);
        const index = listeners.indexOf(listener);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      };
    },

    // 订阅一次
    once(event, listener) {
      const unsubscribe = this.on(event, (...args) => {
        unsubscribe();
        listener(...args);
      });
      return unsubscribe;
    },

    // 发布事件
    emit(event, ...args) {
      if (!events.has(event)) return;

      events.get(event).forEach(listener => {
        try {
          listener(...args);
        } catch (error) {
          console.error('事件处理错误:', error);
        }
      });
    },

    // 移除所有监听器
    off(event) {
      if (event) {
        events.delete(event);
      } else {
        events.clear();
      }
    },

    // 获取监听器数量
    listenerCount(event) {
      return events.has(event) ? events.get(event).length : 0;
    }
  };
}

// 使用
const emitter = createEventEmitter();

// 订阅
const unsubscribe = emitter.on('data', (data) => {
  console.log('收到数据:', data);
});

emitter.once('ready', () => {
  console.log('系统就绪');
});

// 发布
emitter.emit('data', { id: 1, name: 'Test' });
emitter.emit('ready');
emitter.emit('ready');  // 只执行一次

// 取消订阅
unsubscribe();
```

## 5. 性能影响和优化

### 闭包的性能考虑

```javascript
// 性能测试：闭包 vs 普通函数
function performanceTest() {
  const iterations = 1000000;

  // 测试1：普通函数
  function normalAdd(a, b) {
    return a + b;
  }

  console.time('普通函数');
  for (let i = 0; i < iterations; i++) {
    normalAdd(i, i + 1);
  }
  console.timeEnd('普通函数');  // ~3ms

  // 测试2：闭包
  function createAdder() {
    const cache = {};
    return function(a, b) {
      const key = `${a},${b}`;
      if (key in cache) return cache[key];
      cache[key] = a + b;
      return cache[key];
    };
  }

  const closureAdd = createAdder();

  console.time('闭包');
  for (let i = 0; i < iterations; i++) {
    closureAdd(i, i + 1);
  }
  console.timeEnd('闭包');  // ~15ms

  // 结论：
  // 1. 闭包有轻微的性能开销
  // 2. 但性能差异在大多数场景下可以忽略
  // 3. 闭包的功能性价值远大于性能损失
}

// 优化建议
function optimizeClosure() {
  // ❌ 避免：在循环中创建闭包
  const handlers = [];
  for (let i = 0; i < 1000; i++) {
    handlers.push(function() {  // 创建1000个函数
      console.log(i);
    });
  }

  // ✅ 优化：复用闭包
  function createHandler(index) {
    return function() {
      console.log(index);
    };
  }

  const betterHandlers = [];
  for (let i = 0; i < 1000; i++) {
    betterHandlers.push(createHandler(i));
  }

  // ✅ 更好：使用工厂函数
  const factory = (function() {
    const pool = new Map();

    return function getHandler(index) {
      if (!pool.has(index)) {
        pool.set(index, function() {
          console.log(index);
        });
      }
      return pool.get(index);
    };
  })();
}
```

### 总结：闭包的最佳实践

```javascript
// 1. 明确闭包的生命周期
function goodPractice1() {
  // ✅ 短期闭包
  function process(data) {
    const cache = new Map();  // 局部缓存

    return data.map(item => {
      if (cache.has(item)) return cache.get(item);
      const result = expensiveOperation(item);
      cache.set(item, result);
      return result;
    });
  }
  // cache随着函数执行完毕被回收
}

// 2. 提供清理机制
function goodPractice2() {
  function createResource() {
    const resources = [];

    const api = {
      add(resource) {
        resources.push(resource);
      },
      // ✅ 提供显式清理方法
      cleanup() {
        resources.length = 0;
      }
    };

    return api;
  }
}

// 3. 避免过度使用闭包
// ❌ 不必要的闭包
function badPractice() {
  return function() {
    return function() {
      return function() {
        console.log('Too many closures!');
      };
    };
  };
}

// ✅ 简化
function goodPractice3() {
  return function() {
    console.log('Simple and clear');
  };
}

// 4. 使用WeakMap/WeakSet避免内存泄漏
function goodPractice4() {
  const cache = new WeakMap();  // 不阻止垃圾回收

  return function(obj) {
    if (cache.has(obj)) return cache.get(obj);
    const result = compute(obj);
    cache.set(obj, result);
    return result;
  };
}
```

闭包是JavaScript最强大的特性之一，掌握闭包的原理和应用对于成为高级前端工程师至关重要。记住：闭包不是目的，而是实现功能的手段。合理使用闭包可以写出更优雅、更安全的代码！
